import{_ as l,j as i,o as u,c as r,f as a,g as c,w as s,a as p,i as n}from"./app-aea90057.js";const k="/assets/base-type-fa548d7e.jpg",d="/assets/wrapper_class-15ce3d56.png",g="/assets/t-01-a2fd61f9.png",h="/assets/diamond_problem-bbb6df86.png",m="/assets/throwable-59a159de.jpg",v="/assets/thread-c419ee70.jpg",b={},f=p(`<h2 id="java-基础知识" tabindex="-1"><a class="header-anchor" href="#java-基础知识" aria-hidden="true">#</a> Java 基础知识</h2><h3 id="java-和-c-主要区别有哪些-各有哪些优缺点" tabindex="-1"><a class="header-anchor" href="#java-和-c-主要区别有哪些-各有哪些优缺点" aria-hidden="true">#</a> Java 和 C++主要区别有哪些？各有哪些优缺点？</h3><p><u class="under-wave">Java 和 C++分别代表了两种类型的语言：</u><br> ① <strong>C++是编译型语言</strong><br>   首先将源代码编译生成机器语言，再由机器运行机器码。执行速度快、效率高；依赖编译器、跨平台性差些。</p><p>② <strong>Java 是解释型语言</strong><br>   源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。执行速度慢、效率低；依赖解释器、跨平台性好。</p><blockquote><p>也有说 Java 是半编译、半解释型语言。Java 编译器(javac)现将源程序编译成 Java 字节码(.class)，JVM 负责解释执行字节码文件。</p></blockquote><hr><p><u class="under-wave">二者的主要区别：</u><br>  ① C++ 是<mark>平台相关</mark>的，Java 是<mark>平台无关</mark>的；<br>  ② C++ 对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样。Java 在所有平台上对所有的基本数据类型都有标准的范围限制和字节长度。<br>  ③ C++ 除了一些比较少见的情况之外和 C 语言兼容。Java 没有对任何之前的语言向前兼容，但是在语法上受 C/C++ 的影响很大。<br>  ④ C++ 允许直接调用本地的系统库。Java 要通过 JNI 或者 JNA 调用。<br>  ⑤ C++ 允许<u class="under-dot">过程式程序设计和面向对象程序设计</u>。Java 必须使用面向对象的程序设计方式。<br>  ⑥ C++ 支持指针、引用、传值调用。Java 只有值传递。<br>  ⑦ C++ 需要显式的内存管理，但有第三方的框架可以提供垃圾搜集的支持，支持析构函数。Java 是自动垃圾收集的，也没有析构函数的概念。<br>  ⑧ C++ 支持多重继承，包括虚拟继承。Java 只允许单继承，需要多继承的情况要使用接口。</p><hr><details class="hint-container details"><summary>知识扩展：Java 与 C 的参数方法有什么区别？</summary><p>① C 语言是通过指针的引用传递<br> ② Java 会拷贝当前栈中的值传递过去</p><p>⭐️ 编程语言中需要进行方法间的参数传递，这个传递的策略叫做<mark>求值策略</mark>。<br> ⭐️ 在程序设计中，求值策略有很多种，比较常见的就是<u class="under-dash">值传递和引用传递</u>，还有一种值传递的特例——共享对象传递。<br> ⭐️ 值传递和引用传递的最大区别是传递过程中有没有复制出一个副本来，<u class="under-wave">如果是传递副本，那就是值传递，否则就是引用传递。</u><br> ⭐️ Java 对象的传递，是通过复制的方式把引用关系传递了，因为有复制的过程，所以是值传递，只不过对于 Java 对象的传递，传递的内容是对象的引用。</p></details><h3 id="jdk、jre、jvm-的区别-必会" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-的区别-必会" aria-hidden="true">#</a> JDK、JRE、JVM 的区别(必会)</h3><blockquote><p><strong>JDK</strong>：JDK(Java Development Kit)即 Java 开发工具包，是整个 Java 的核心，其包括了 Java 运行环境(JRE)、Java 工具和 Java 基础类库。</p><hr><p><strong>JRE</strong>：JRE(Java Runtime Environment)即 Java 运行环境，它是运行 Java 程序所必须得环境的集合，包含 Java 虚拟机和 Java 程序的一些核心类库。</p><hr><p><strong>JVM</strong>：JVM(Java Virtual Machine)即 Java 虚拟机，是整个 Java 实现跨平台的最核心部分，能够运行以 Java 语言写的软件程序。</p></blockquote><h3 id="说一下-java-的三种注释" tabindex="-1"><a class="header-anchor" href="#说一下-java-的三种注释" aria-hidden="true">#</a> 说一下 JAVA 的三种注释</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>// 单行注释
/*...*/ 多行注释
/...*/ 文档注释
</code></pre></div><h3 id="java-的数据类型" tabindex="-1"><a class="header-anchor" href="#java-的数据类型" aria-hidden="true">#</a> Java 的数据类型</h3><div class="hint-container tip"><p class="hint-container-title">数据类型</p><p>  Java 数据类型包括两大类：基本数据类型和引用数据类型；其中八个基本数据类型包括整型(byte、short、int、long)、浮点型(float、double)、字符型(char)、布尔型(boolean)；除此之外的都为引用数据类型，比如类、接口、数组。</p></div><figure><img src="`+k+`" alt="基本数据类型.jpg" width="600" tabindex="0" loading="lazy"><figcaption>基本数据类型.jpg</figcaption></figure><table><thead><tr><th>数据类型</th><th>字节数</th><th>位数</th><th>默认值</th><th>包装类型</th><th>使用说明[取值范围]</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>0</td><td>Byte</td><td>-128~127</td></tr><tr><td>short</td><td>2</td><td>16</td><td>0</td><td>Short</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int</td><td>4</td><td>32</td><td>0</td><td>Integer</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>long</td><td>8</td><td>64</td><td>0L 或 0l</td><td>Long</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>float</td><td>4</td><td>32</td><td>0.0F 或 0.0f</td><td>Float</td><td>1.4E-45~3.4E38</td></tr><tr><td>double</td><td>8</td><td>64</td><td>0.0d</td><td>Double</td><td>4.9E-324~1.8E308</td></tr><tr><td>char</td><td>2</td><td>16</td><td>空</td><td>Character</td><td>使用 Unicode 编码(2 个字节)，可存汉字</td></tr><tr><td>boolean</td><td>-</td><td>-</td><td>false</td><td>Boolean</td><td>只有 true 和 false 两个取值</td></tr></tbody></table><h3 id="整型的默认数据类型是什么-浮点型的数据类型是什么" tabindex="-1"><a class="header-anchor" href="#整型的默认数据类型是什么-浮点型的数据类型是什么" aria-hidden="true">#</a> 整型的默认数据类型是什么，浮点型的数据类型是什么？</h3><blockquote><p>整型默认数据类型：int<br> 浮点型默认数据类型：double</p></blockquote><h3 id="为什么不能用浮点型表示金额" tabindex="-1"><a class="header-anchor" href="#为什么不能用浮点型表示金额" aria-hidden="true">#</a> 为什么不能用浮点型表示金额？</h3><blockquote><p>  因为<u class="under-wave">不是所有的小数都能用二进制表示</u>，所以为了解决这个问题，IEEE 提出了一种使用近似值表示小数的方式，并且引入了精度的概念，这就是浮点数。<u class="under-wave">浮点数只是近似值，并不是精确值，所以不能用来表示金额，否则会有精度丢失。</u><br>   为了解决精度问题，可以使用<code>BigDecimal</code>。</p></blockquote><hr><p><strong>数据库涉及金额时，同样需要注意</strong>：</p><div class="project-panel-custom"><a class="project project0" href="/backend/database/base/data_type.html#浮点类型" style="width:50%;" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-info"></span><div class="name">MySQL数据类型-浮点类型</div><div class="desc">精度误差说明</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> info
  <span class="token key atrule">name</span><span class="token punctuation">:</span> MySQL数据类型<span class="token punctuation">-</span>浮点类型
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> 精度误差说明
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/database/base/data_type.html<span class="token comment">#浮点类型</span>
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="java-中有了基本类型为什么还需要包装类" tabindex="-1"><a class="header-anchor" href="#java-中有了基本类型为什么还需要包装类" aria-hidden="true">#</a> Java 中有了基本类型为什么还需要包装类？</h3><p>  Java 是一个面向对象的编程语言，但是 Java 中的八种基本数据类型却是不面向对象的 <mark>(比如：集合类中，无法将 int、double 等类型放进去，因为集合的容器要求是 Object 类型。)</mark>，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于 java.lang 包。</p><figure><img src="`+d+'" alt="包装类.png" width="700" tabindex="0" loading="lazy"><figcaption>包装类.png</figcaption></figure>',28),x={class:"hint-container details"},y=p(`<summary>知识扩展</summary><p>① <strong>基本类型和包装类型的区别</strong><br> （1）默认值不同，基本类型的默认值为<code>0</code>、<code>false</code>或<code>\\u0000</code>等，包装类默认为<code>null</code><br> （2）初始化方式不同，一个需要 new，一个不需要<br> （3）存储方式不同，基本类型保存在栈上，包装类对象保存在堆上（通常情况下，在没有 JIT 优化栈上分配时）</p><p>② <strong>如何理解拆装箱</strong><br>   包装类是对基本类型的包装，所以，<u class="under-wave">把基本数据类型转换成包装类的过程就是装箱</u>；反之，<u class="under-wave">把包装类转换成基本数据类型的过程就是拆箱</u>。在 Java SE5 中，为了减少开发人员的工作，Java 提供了自动拆箱与自动装箱功能。</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// Java SE5 之前</span>
<span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Java SE5 之后</span>
<span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">;</span>      <span class="token comment">// 自动拆箱</span>
</code></pre></div><p>利用工具<code>JD-GUI</code>查看<code>class</code>字节码文件：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过分析上面的代码，可以看出<u class="under-wave">自动装箱都是通过<mark>包装类</mark>的<code>valueOf()</code>方法实现；自动拆箱都是通过<mark>包装类对象</mark>的<code>xxxValue()</code>来实现。</u></p><p>③ <strong>哪些地方涉及自动拆装箱</strong></p><p> 场景一：将基本数据类型放入集合类(自动装箱)</p>`,9),w=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"List"),a("span",{class:"token generics"},[a("span",{class:"token punctuation"},"<"),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},">")]),n(" list "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"ArrayList"),a("span",{class:"token generics"},[a("span",{class:"token punctuation"},"<"),a("span",{class:"token punctuation"},">")]),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"for"),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token keyword"},"int"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(" i "),a("span",{class:"token operator"},"<"),n(),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},";"),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
    list`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"add"),a("span",{class:"token punctuation"},"("),n("i"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),j=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"List"),a("span",{class:"token generics"},[a("span",{class:"token punctuation"},"<"),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},">")]),n(" list "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"ArrayList"),a("span",{class:"token generics"},[a("span",{class:"token punctuation"},"<"),a("span",{class:"token punctuation"},">")]),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"for"),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token keyword"},"int"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(" i "),a("span",{class:"token operator"},"<"),n(),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},";"),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},")"),n(`
    list`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"add"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),n("i"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),S=a("p",null," 场景二：包装类型和基本类型的大小比较",-1),_=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"Integer"),n(" a "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),n("a "),a("span",{class:"token operator"},"=="),n(),a("span",{class:"token number"},"1"),n(),a("span",{class:"token operator"},"?"),n(),a("span",{class:"token string"},'"等于"'),n(),a("span",{class:"token operator"},":"),n(),a("span",{class:"token string"},'"不等于"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token class-name"},"Boolean"),n(" bool "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token boolean"},"false"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),n("bool "),a("span",{class:"token operator"},"?"),n(),a("span",{class:"token string"},'"真"'),n(),a("span",{class:"token operator"},":"),n(),a("span",{class:"token string"},'"假"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),J=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"Integer"),n(" a "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},"("),n("a"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"intValue"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token operator"},"=="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token operator"},"?"),n(),a("span",{class:"token string"},'"等于"'),n(),a("span",{class:"token operator"},":"),n(),a("span",{class:"token string"},'"不等于"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token class-name"},"Boolean"),n(" bool "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Boolean"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),a("span",{class:"token boolean"},"false"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),n("bool"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"booleanValue"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token operator"},"?"),n(),a("span",{class:"token string"},'"真"'),n(),a("span",{class:"token operator"},":"),n(),a("span",{class:"token string"},'"假"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),C=a("blockquote",null,[a("p",null,"⭐️ 包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。")],-1),A=a("p",null," 场景三：包装类型的运算",-1),q=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"Integer"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"Integer"),n(" j "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"20"),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),n("i "),a("span",{class:"token operator"},"+"),n(" j"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),z=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token class-name"},"Integer"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"Integer"),n(" j "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"20"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),n("i"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"intValue"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token operator"},"+"),n(" j"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"intValue"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),I=a("blockquote",null,[a("p",null,"⭐️ 两个包装类型之间的运算，会被自动拆箱成基本类型进行。")],-1),D=a("p",null," 场景四：三目运算符的使用",-1),B=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"boolean"),n(" flag "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token boolean"},"true"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"Integer"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"0"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"int"),n(" j "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"int"),n(" k "),a("span",{class:"token operator"},"="),n(" flag "),a("span",{class:"token operator"},"?"),n(" i "),a("span",{class:"token operator"},":"),n(" j"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"k = "'),n(),a("span",{class:"token operator"},"+"),n(" k"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),E=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"boolean"),n(" flag "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token boolean"},"true"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"Integer"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Integer"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"valueOf"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"0"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"int"),n(" j "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"int"),n(" k "),a("span",{class:"token operator"},"="),n(" flag "),a("span",{class:"token operator"},"?"),n(" i"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"intValue"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token operator"},":"),n(" j"),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"k = "'),n(),a("span",{class:"token operator"},"+"),n(" k"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])])],-1),N=p(`<blockquote><p>⭐️ 三目运算符的语法规范：当第二、第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。假如此处的<code>i</code>为<code>null</code>，自动拆箱就会出现 NPE 异常(空指针)。</p></blockquote><p> 场景五：函数参数与返回值</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 自动拆箱：num.intValue()</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum1</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 自动装箱：Integer.valueOf(num)</span>
<span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>④ <strong>自动拆装箱与缓存</strong></p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(100);</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(100);</span>
<span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(200);</span>
<span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(200);</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印false</span>
</code></pre></div><blockquote><p>⭐️ 在 Java 中，<code>==</code>比较的是对象的引用，而<code>equals</code>比较的是值。所以，在这个例子中，不同的对象有不同的引用，那么应该都返回 false。但是结果与我们预想的不一致，这里和 Integer 中的缓存机制有关。在 Java5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用 <mark>（适用于整数-128 ~ 127，且只适用于自动装箱）</mark>。当需要进行自动装箱时，如果数字在-128 ~ 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。<br> ⭐️ 在 Java5 中引入这个功能时，这个范围是固定的，后面在 Java6 中，可以通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>或者在 VM 初始化期间使用<code>java.lang.Integer.IntegerCache.high</code>设置最大值。</p></blockquote>`,6),O=p('<h3 id="重载-overload-与重写-override-的区别" tabindex="-1"><a class="header-anchor" href="#重载-overload-与重写-override-的区别" aria-hidden="true">#</a> 重载(overload)与重写(override)的区别</h3><blockquote><p><strong>重载</strong>：同一个类中，方法名相同，方法的参数的<u class="under-wave">类型、顺序、数量</u>不同的一组方法 <mark>(返回值不同，但是方法名和参数列表都相同的两个方法，不是重载。)</mark><br><strong>重写</strong>：子类对父类中的同名方法进行覆盖</p></blockquote><h3 id="java-中-与equals的区别-必会" tabindex="-1"><a class="header-anchor" href="#java-中-与equals的区别-必会" aria-hidden="true">#</a> Java 中<code>==</code>与<code>equals</code>的区别(必会)</h3><blockquote><p><code>==</code>：<br>   基本类型：比较的就是值是否相同<br>   引用类型：比较的就是地址是否相同</p><p><code>equals</code>：<br>   此方法是 Object 类中定义方法，只能实现两个引用类型的变量进行比较，默认比较的是两个对象是否相同，在 String 类，对此方法进行了重写，实现的是比较两个字符串的值是否相同；</p></blockquote><h3 id="为什么不能用-bigdecimal-的-equals-方法做等值比较" tabindex="-1"><a class="header-anchor" href="#为什么不能用-bigdecimal-的-equals-方法做等值比较" aria-hidden="true">#</a> 为什么不能用 BigDecimal 的 equals 方法做等值比较？</h3><blockquote><p>因为 BigDecimal 的 equals 方法和 compareTo 并不一样，equals 方法会比较两个部分的内容，分别是值(value)和标度(scale)，比如比如 0.1 和 0.10 这两个数字，它们的值虽然一样，但是由于精度不一样，所以使用 equals 会返回 false。</p></blockquote><hr><p><strong>知识扩展(阿里巴巴 Java 开发手册)</strong>：</p><p><span style="color:red;">【强制】</span>如上所示 BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。<br><span style="font-size:12px;">说明：equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</span></p><hr><h3 id="bigdecimal-double-和-bigdecimal-string-有什么区别" tabindex="-1"><a class="header-anchor" href="#bigdecimal-double-和-bigdecimal-string-有什么区别" aria-hidden="true">#</a> BigDecimal(double)和 BigDecimal(String)有什么区别？</h3><blockquote><p>因为 double 是不精确的，所以使用一个不精确的数字来创建 BigDecimal，得到的数字也是不精确的。如 0.1 这个数，double 只能表示它的近似值。而对于 BigDecimal(String)，创建出来的值就是精确的。</p></blockquote><hr><p><strong>知识扩展(阿里巴巴 Java 开发手册)</strong>：</p><p><span style="color:red;">【强制】</span>禁止使用构造方法 BigDecimal(double)的方式把 double 转化为 BigDecimal 对象。<br><span style="font-size:12px;">说明：BigDecimal(double)存在精度损失风险，在精度计算或值比较的场景中可能会导致业务逻辑异常。</span><br><span style="font-size:12px;">如：BigDecimal g = new BigDecimal(0.1F)；实际的存储值为：0.10000000149</span><br><span style="font-size:12px;">正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 类的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</span><br><span class="under-wave" style="font-size:12px;">BigDecimal recommand1 = new BigDecimal(&quot;0.1&quot;);</span><br><span class="under-wave" style="font-size:12px;">BigDecimal recommand2 = BigDecimal.valueOf (0.1);</span></p><hr><h3 id="为什么对-java-中的负数取绝对值结果不一定是正数" tabindex="-1"><a class="header-anchor" href="#为什么对-java-中的负数取绝对值结果不一定是正数" aria-hidden="true">#</a> 为什么对 Java 中的负数取绝对值结果不一定是正数？</h3><blockquote><p>  <u class="under-wave">使用<code>Math.abs</code>对一个 Interger 取绝对值的时候，可能出现负数情况</u>。int 的取值范围是 -2<sup>31</sup> ~ 2<sup>31</sup>-1，即-2147483648 ~ 2147483647。假设对-2147483648 取绝对值，正数就大于了 int 的最大取值范围，这时候就会发生越界。2147483647 用二进制的补码表示是：<code>01111111 11111111 11111111 11111111</code>，这个数 + 1 得到<code>10000000 00000000 00000000 00000000</code>，这个二进制称为-2147483648 的补码。针对这种情况可以把 int 类型转成 long 类型，就不会出现越界了。</p></blockquote><h3 id="string、stringbuffer-与-stringbuilder-的区别-必会" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer-与-stringbuilder-的区别-必会" aria-hidden="true">#</a> String、StringBuffer 与 StringBuilder 的区别(必会)</h3><blockquote><p><strong>String</strong>：字符串常量<br><strong>StringBuffer</strong>：字符串变量(线程安全)<br><strong>StringBuilder</strong>：字符串变量(非线程安全)</p></blockquote><p>  String 构建一个不可变的字符序列，StringBuffer 和 StringBuilder 都是构建一个可变的字符序列。在对字符串进行追加操作时 StringBuffer 比 String 效率高。</p><p>  此外 StringBuffer 是线程安全的，而 StringBuilder 是线程非安全的，在对字符串进行修改操作时，StringBuilder 效率优于 StringBuffer。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  String 中的 String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，String 对象是不可变的，也就可以理解为常量，线程安全。</p><p>  AbstractStringBuilder 是 StringBuffer 与 StringBuilder 的公共父类，定义了一些字符串的基本操作，如：expandCapacity、append、insert、indexOf 等公共方法。</p><p>  StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>  StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></div><p><strong>小结</strong>：<br> ① 如果要操作少量的数据用 String；<br> ② 多线程操作字符串缓冲区下操作大量数据用 StringBuffer；<br> ③ 单线程操作字符串缓冲区孝操作大量数据用 StringBuilder。</p><h3 id="说一下字符串操作常见的-api-10-个左右即可" tabindex="-1"><a class="header-anchor" href="#说一下字符串操作常见的-api-10-个左右即可" aria-hidden="true">#</a> 说一下字符串操作常见的 API ？(10 个左右即可)</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code>、<code>concat(String str)</code></td><td>字符串连接</td></tr><tr><td><code>==</code>、<code>equals(Object anObject)</code>、<code>equalsIgnoreCase(String another String)</code></td><td>字符串比对</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定位置字符值</td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取指定字符串第一次出现的下标值</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>字符串替换</td></tr><tr><td><code>startsWith(String prefix)</code>、<code>endsWith(String prefix)</code></td><td>判断是否以指定字符串开始|结束</td></tr><tr><td><code>toLowerCase()</code>、<code>toUpperCase()</code></td><td>所有字符转换为小写|大写</td></tr><tr><td><code>substring(index)</code></td><td>字符串截取</td></tr><tr><td><code>trim()</code></td><td>去除左右空格</td></tr><tr><td><code>String.valueOf(int i)</code></td><td>将整型转为字符串</td></tr><tr><td><code>contains(String str)</code></td><td>判断字符串是否包含某子字符串</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>split(String regex)</code></td><td>指定分隔符返回分割后的字符数组</td></tr><tr><td><code>toCharArray()</code></td><td>将字符串转为字符数组</td></tr><tr><td><code>getBytes()</code>、<code>getBytes(String charsetName)</code></td><td>返回字符串的 byte 类型数组(可指定字符集)</td></tr></tbody></table><h3 id="自增-如下代码的运行结果" tabindex="-1"><a class="header-anchor" href="#自增-如下代码的运行结果" aria-hidden="true">#</a> 自增(如下代码的运行结果)</h3>',27),L=a("div",{class:"language-java line-numbers-mode","data-ext":"java"},[a("pre",{java:"",class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Test"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
        i `),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" j "),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" k "),a("span",{class:"token operator"},"="),n(" i "),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token operator"},"++"),n("i "),a("span",{class:"token operator"},"*"),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"i="'),n(),a("span",{class:"token operator"},"+"),n(" i"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"j="'),n(),a("span",{class:"token operator"},"+"),n(" j"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"k="'),n(),a("span",{class:"token operator"},"+"),n(" k"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])]),a("div",{class:"highlight-lines"},[a("br"),a("br"),a("br"),a("div",{class:"highlight-line"}," "),a("br"),a("br"),a("br"),a("br"),a("br"),a("br"),a("br")]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),P=a("div",{class:"language-text line-numbers-mode","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`i=4
j=1
k=11
`)]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),M=p('<div class="hint-container tip"><p class="hint-container-title">解析</p><p><strong>行 4</strong>：先将 1 压入操作数栈，然后局部变量表中的 i 自增变为 2，最后操作树栈中的 1 赋值给 i，2 被覆盖；</p><figure><img src="'+g+`" alt="处理过程.png" tabindex="0" loading="lazy"><figcaption>处理过程.png</figcaption></figure><p><strong>总结</strong>：<br> ① 先赋值再自增、自减(i = i++ 、i = i--)，先自增、自减再赋值(i = ++i 、i = --i)<br> ② = 右边的从左到右加载值依次压入操作数栈<br> ③ 实际先算哪个，看运算符优先级<br> ④ 自增、自减操作都是<mark>直接修改变量的值，不经过操作数栈</mark><br> ⑤ 最后的赋值之前，临时结果也是存储在操作数栈中</p></div><h3 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h3><div class="hint-container tip"><p class="hint-container-title">什么是 Singleton ？</p><p><strong>Singleton</strong> : 在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。单例设计模式，即某个类在整个系统中<mark>只能有一个实例对象</mark>可被获取和使用的代码模式。例如：代表 JVM 运行环境的 Runtime 类</p><p><strong>要点</strong>：</p><p>① 某个类只能有一个实例【构造器私有化】<br> ② 它必须自行创建这个实例【含有一个该类的静态变量来保存这个唯一的实例)】<br> ③ 它必须自行向整个系统提供这个实例【对外提供获取该实例对象的方式：(1)直接暴露 (2)用静态变量的 get 方法获取】</p></div><h4 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 直接实例化(简洁直观)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 枚举式(最简洁)</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块(适合复杂实例化)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在类初始化时直接创建实例对象，不管是否需要这个对象，不存在线程安全问题</p></blockquote><h4 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 静态内部类形式(适用于多线程)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Inner</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟创建对象<br> 线程不安全(适用于单线程)、线程安全(适用于多线程)</p></blockquote><h3 id="反射-了解" tabindex="-1"><a class="header-anchor" href="#反射-了解" aria-hidden="true">#</a> 反射(了解)</h3><p>  在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>  反射的好处是可以提升程序的灵活性和扩展性，比较容易在运行期间干很多事情。但是带来的问题更多，主要有：<br>    ① 代码可读性及可维护性<br>    ② 反射代码执行的性能低<br>    ③ 反射破坏了封装性<br>   所以，在业务代码中应该尽量避免使用反射，但是也要读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p><p><strong>获取 Class 对象的 3 种方法</strong>：<br> ① 调用某个对象的 getClass()方法</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clzz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>② 调用某个类的 class 属性来获取该类对应的 Class 对象</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre></div><p>③ 使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 最常用</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类的全路径&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><hr><p><strong>扩展</strong>：为什么反射慢？<br> ① 由于反射涉及动态解析类型，因此不能执行某些 Java 虚拟机优化，如 JIT 优化<br> ② 在使用反射时，参数需要包装成 Object[]类型，但是真正方法执行的时候，有需要再拆包成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致 GC，GC 会导致应变变慢<br> ③ 反射调用方法时会从方法数组中遍历查找，并且会检查可见性，这些动作都是耗时的<br> ④ 不仅方法的可见性要做检查，参数也需要做很多额外的检查</p><h3 id="通过反射如何创建对象" tabindex="-1"><a class="header-anchor" href="#通过反射如何创建对象" aria-hidden="true">#</a> 通过反射如何创建对象？</h3><blockquote><p>① 通过 Class 类的 newInstance()方法<br> ② 通过 Constructor 的 newInstance(Object[] args)方法</p></blockquote><p><strong>代码示例</strong>：</p>`,23),T={class:"hint-container details"},V=a("summary",null,"通过反射如何创建对象(代码示例)",-1),F=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"package"),n(),a("span",{class:"token namespace"},[n("cn"),a("span",{class:"token punctuation"},"."),n("bt66")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"Constructor")]),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"Field")]),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"InvocationTargetException")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token doc-comment comment"},[n(`/**
 * `),a("span",{class:"token keyword"},"@author"),n(` zhangxiaojun
 */`)]),n(`
`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"App"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token keyword"},"throws"),n(),a("span",{class:"token class-name"},"ClassNotFoundException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"NoSuchMethodException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"InstantiationException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"IllegalAccessException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"InvocationTargetException"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token comment"},"// 调用某个对象的 getClass() 方法"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" person "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_1 "),a("span",{class:"token operator"},"="),n(" person"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"getClass"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_1"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 调用某个类的 class 属性来获取该类对应的 Class 对象"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_2 "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"."),a("span",{class:"token keyword"},"class"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_2 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_2"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 使用 Class 类中的 forName() 静态方法"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_3 "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Class"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"forName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"cn.bt66.Person"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_3 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_3"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 比较"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 == clazz_2 : "'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token punctuation"},"("),n("clazz_1 "),a("span",{class:"token operator"},"=="),n(" clazz_2"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 == clazz_3 : "'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token punctuation"},"("),n("clazz_1 "),a("span",{class:"token operator"},"=="),n(" clazz_3"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 通过 Class 类的 newInstance()方法"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" p "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},")"),n(" clazz_1"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"newInstance"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        p`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        p`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Zhang"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"String"),n(" pString "),a("span",{class:"token operator"},"="),n(" p"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"pString = "'),n(),a("span",{class:"token operator"},"+"),n(" pString"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 通过 Constructor 的 newInstance(Object[] args)方法"),n(`
        `),a("span",{class:"token class-name"},"Constructor"),n(" con "),a("span",{class:"token operator"},"="),n(" clazz_1"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"getConstructor"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" o "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},")"),n(" con"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"newInstance"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        o`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"20"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        o`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Li"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"String"),n(" oString "),a("span",{class:"token operator"},"="),n(" o"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"oString = "'),n(),a("span",{class:"token operator"},"+"),n(" oString"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),R=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"package"),n(),a("span",{class:"token namespace"},[n("cn"),a("span",{class:"token punctuation"},"."),n("bt66")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token doc-comment comment"},[n(`/**
 * `),a("span",{class:"token keyword"},"@author"),n(` zhangxiaojun
 */`)]),n(`
`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Person"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},";"),n(`

    `),a("span",{class:"token doc-comment comment"},`/**
     * 无参构造函数
     * 注意：当没有有参构造函数时，会隐式声明
     */`),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age "),a("span",{class:"token operator"},"="),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"String"),n(),a("span",{class:"token function"},"getName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"int"),n(),a("span",{class:"token function"},"getAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age "),a("span",{class:"token operator"},"="),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"eat"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Eating！"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token annotation punctuation"},"@Override"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"String"),n(),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(),a("span",{class:"token string"},'"Name:"'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token string"},'","'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token string"},'"Age:"'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),H=a("div",{class:"language-text","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`clazz_1 = class cn.bt66.Person
clazz_2 = class cn.bt66.Person
clazz_3 = class cn.bt66.Person
clazz_1 == clazz_2 : true
clazz_1 == clazz_3 : true
pString = Name:Zhang,Age:10
oString = Name:Li,Age:20
`)])],-1),K=p(`<hr><p><strong>反射更多介绍</strong>：</p><div class="project-panel-custom"><a class="project project0" href="/backend/java/java-reflect.html" style="width:50%;" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-structure"></span><div class="name">反射</div><div class="desc">Java-反射</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> structure
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 反射
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> Java<span class="token punctuation">-</span>反射
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/java/java<span class="token punctuation">-</span>reflect.html
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="如何理解面向对象和面向过程" tabindex="-1"><a class="header-anchor" href="#如何理解面向对象和面向过程" aria-hidden="true">#</a> 如何理解面向对象和面向过程？</h3><blockquote><p>① 面向过程把问题分解成一个一个步骤，每个步骤用函数实现，依次调用。<br> ② 面向对象将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p></blockquote><details class="hint-container details"><summary>知识扩展：面向对象的五大基本原则？</summary><p>五大基本原则：<br>  单一职责原则(Single-Responsibility Principle)：一个类最好只做一件事<br>  开放封闭原则(Open-Closed principle)：对扩展开放、对修改封闭<br>  里氏替换原则(Liskov-Substituion Principle)：子类必须能够替换其基类<br>  依赖倒置原则(Dependency-Inversion Principle)：程序要依赖于抽象接口，而不是具体的实现<br>  接口隔离原则(Interface-Segregation Principle)：使用多个小的专门的接口，而不要使用一个大的总接口</p></details><h3 id="面向对象的特征-了解" tabindex="-1"><a class="header-anchor" href="#面向对象的特征-了解" aria-hidden="true">#</a> 面向对象的特征(了解)</h3><p><strong>面向对象的特征</strong>：<u class="under-dot">封装、继承、多态、抽象</u></p><blockquote><p><strong>封装</strong>：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，但提供对外访问的接口。由于隐藏了实现细节，同时又可以对属性赋值进行校验，所以增加了安全性；另外封装的各种方法，可以任意调用，不需要关心实现细节，提高了代码复用性。</p><hr><p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p><hr><p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力（<mark>多态是父类行为的多面性。---子类重写造成的</mark>）</p><hr><p><strong>抽象</strong>：表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用此关键字修饰类时，此类就不能被实例化，这这里可以看出，抽象类(接口)就是为了继承而存在的。</p></blockquote><h3 id="java-中的多态三个条件" tabindex="-1"><a class="header-anchor" href="#java-中的多态三个条件" aria-hidden="true">#</a> Java 中的多态三个条件？</h3><blockquote><p>① 要有继承；<br> ② 要有重写；<br> ③ 必须通过父类的对象调用(即：父类的引用指向子类的对象 <code>Animal cat = new Cat();</code>)。</p></blockquote><h3 id="解释一下向上转型与向下转型" tabindex="-1"><a class="header-anchor" href="#解释一下向上转型与向下转型" aria-hidden="true">#</a> 解释一下向上转型与向下转型</h3><blockquote><p>向上转型：通过子类对象 (小范围) 实例化父类对象 (大范围)， 这种属于自动转换<br> 向下转型：通过父类对象 (大范围) 实例化子类对象 (小范围)， 这种属于强制转换</p></blockquote><p><strong>代码示例</strong>：</p>`,15),U={class:"hint-container details"},X=a("summary",null,"展开查看",-1),G=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Animal"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Animal makes sound"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`

`),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Dog"),n(),a("span",{class:"token keyword"},"extends"),n(),a("span",{class:"token class-name"},"Animal"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Dog barks"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"playFetch"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Dog plays fetch"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`

`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Main"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"Dog"),n(" dog "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"Dog"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"Animal"),n(" animal "),a("span",{class:"token operator"},"="),n(" dog"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// 向上转型"),n(`
        animal`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},'// 输出 "Dog barks"'),n(`
        `),a("span",{class:"token comment"},"// animal.playFetch(); 编译错误，无法访问子类新增的方法"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),Q=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Animal"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Animal makes sound"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`

`),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Dog"),n(),a("span",{class:"token keyword"},"extends"),n(),a("span",{class:"token class-name"},"Animal"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Dog barks"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"playFetch"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Dog plays fetch"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`

`),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Cat"),n(),a("span",{class:"token keyword"},"extends"),n(),a("span",{class:"token class-name"},"Animal"),n(),a("span",{class:"token punctuation"},"{"),n(),a("span",{class:"token punctuation"},"}"),n(`

`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Main"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"Animal"),n(" animal "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"Dog"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"if"),n(),a("span",{class:"token punctuation"},"("),n("animal "),a("span",{class:"token keyword"},"instanceof"),n(),a("span",{class:"token class-name"},"Dog"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
            `),a("span",{class:"token class-name"},"Dog"),n(" dog "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Dog"),a("span",{class:"token punctuation"},")"),n(" animal"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// 向下转型"),n(`
            dog`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},'// 输出 "Dog barks"'),n(`
            dog`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"playFetch"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},'// 输出 "Dog plays fetch"'),n(`
        `),a("span",{class:"token punctuation"},"}"),n(`

        `),a("span",{class:"token class-name"},"Cat"),n(),a("span",{class:"token class-name"},"Cat"),n(),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Cat"),a("span",{class:"token punctuation"},")"),n(" animal"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// ClassCastException：Dog cannot be cast to Cat"),n(`
        `),a("span",{class:"token class-name"},"Cat"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"sound"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),W=p('<blockquote><p>⭐️ 向上转型(Upcasting)：将一个子类的实例赋值给其父类的引用变量。这个操作是安全的，因为子类继承了父类的所有属性和方法。在向上转型中，只能访问父类中定义的属性和方法，无法访问子类新增的属性和方法。<br> ⭐️ 向下转型(Downcasting)：将一个父类的引用变量转换为其子类的引用变量。这个操作需要显式地将父类的引用转换为子类的引用，因为编译器无法确定父类引用所指向的对象是否是子类的实例。如果转换不正确，会引发 ClassCastException 异常。</p></blockquote><h3 id="final-关键字作用" tabindex="-1"><a class="header-anchor" href="#final-关键字作用" aria-hidden="true">#</a> final 关键字作用？</h3><blockquote><p>① final 修饰变量，表示该变量为常量，只能赋值一次;<br> ② final 修饰方法，表示该方法不能被重写;<br> ③ final 修饰类，表示该类不能被继承。</p></blockquote><h3 id="说一下-java-中类的四种封装" tabindex="-1"><a class="header-anchor" href="#说一下-java-中类的四种封装" aria-hidden="true">#</a> 说一下 java 中类的四种封装？</h3><table><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:center;">类内部</th><th style="text-align:center;">同一个包中</th><th style="text-align:center;">子类</th><th style="text-align:center;">任何地方</th></tr></thead><tbody><tr><td style="text-align:left;">private</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">default</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">public</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td></tr></tbody></table><h3 id="java-中如何实现继承-java-中能实现多重继承吗" tabindex="-1"><a class="header-anchor" href="#java-中如何实现继承-java-中能实现多重继承吗" aria-hidden="true">#</a> java 中如何实现继承？java 中能实现多重继承吗？</h3><blockquote><p>📖 继承概念：继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。<br> 📖 如何实现继承：使用 extends 关键字;一个子类只有一个直接父类。</p></blockquote><h3 id="为什么-java-不支持多继承" tabindex="-1"><a class="header-anchor" href="#为什么-java-不支持多继承" aria-hidden="true">#</a> 为什么 Java 不支持多继承？</h3><blockquote><p>  因为如果要实现多继承，就会像 C++ 中一样，存在<mark>菱形继承</mark>的问题，C++ 为了解决菱形继承问题，又引入了<mark>虚继承</mark>。而经过分析，发现我们需要使用多继承的情况并不多，所以在 Java 中，不允许多继承，即一个类不允许继承多个父类。<br>   在 Java 8 之前，接口中是不能有方法的实现的，所以一个类同时实现多个接口的话，也不会出现 C++ 中歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中。但是，Java8 中支持了默认函数(default method)，即接口中可以定义一个有方法体的方法了。<br>   而又因为 Java 支持同时实现多个接口，这就相当于通过 implements 就可以从多个接口中继承到多个方法。但是 Java8 中为了避免菱形继承的问题，在实现的多个接口中如果有相同方法，就会要求该类必须重写这个方法。</p></blockquote><details class="hint-container details"><summary>知识扩展</summary><p>① <strong>菱形继承问题</strong><br>   Java 创始人詹姆斯·高斯林(James Gosling)曾经回答过：<u class="under-wave">&quot;Java 之所以不支持一个类继承多个类，主要是因为在设计之初我们听取了来自 C++和 Objective-C 等阵营的人的意见。因为多继承会产生很多歧义问题。&quot;</u><br>   这里提到的歧义，其实就是 C++ 因为支持多继承之后带来的菱形继承问题。</p><figure><img src="'+h+`" alt="菱形问题.png" width="600" tabindex="0" loading="lazy"><figcaption>菱形问题.png</figcaption></figure><p>  结合上图，假设我们有类 B 和类 C，它们都继承了相同的类 A，另外还有类 D，它通过多重继承的机制继承了类 B 和类 C。此时 D 就具有了 B 和 A 分别的<code>display()</code>方法，那么编译器无法确定应该调用哪个父类的方法，从而产生歧义。</p><p>  因为这样的继承关系的形状类似于菱形，因此被称为菱形继承问题。而 C++ 为了解决这个问题，又引入了<mark>虚继承</mark>。</p><p>  所以，在 Java 中，不允许声明多继承，即一个类不允许继承多个父类。但是 Java 允许&quot;实现多继承&quot;，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现(Java 8 之前)，这就避免了 C++ 中多继承的歧义问题。</p><p>② <strong>Java8 中的多继承</strong><br>   Java 不支持多继承，但是可以支持多实现，也就是说，同一个类可以同时实现多个接口。<br>   我们知道，在 Java8 之前，接口中是不能有方法实现的，所以一个类同时实现多个接口的话，也不会出现 C++ 中的歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中的。<br>   但是，在 Java8 中支持了默认函数(default method)，即接口中可以定义一个有方法体的方法。而又因为 Java 支持同时实现多个接口，这就相当于通过 implements 就可以从多个接口继承到多个方法，这就相当于变相支持了多继承。假如被实现的类中有同名方法，实现类中就必须进行重写，否则编译报错。</p><p>下面通过代码配合注释可以更直观的理解上面的内容：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Java 8 支持默认函数，实现类可以重写，也可以不重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Mammal-Run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">,</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 被实现的类中都存在同名方法，必须重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Dog-eat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 相当于 Java 8 以前 实现类必须重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Dog-breath&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出</span>
<span class="token class-name">Dog</span><span class="token operator">-</span>eat
<span class="token class-name">Mammal</span><span class="token operator">-</span><span class="token class-name">Run</span>
<span class="token class-name">Dog</span><span class="token operator">-</span>breath
</code></pre></div><p>  所以可以看到，Java 并没有帮我们解决多继承的歧义问题，而是把这个问题留给开发者，通过重写方法的方式自己解决。</p></details><h3 id="string-能被继承吗" tabindex="-1"><a class="header-anchor" href="#string-能被继承吗" aria-hidden="true">#</a> String 能被继承吗？</h3><blockquote><p>String 被 final 关键字修饰属于最终类，不能被继承。<br> ⭐️ 底层源码：<code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {...}</code></p></blockquote><h3 id="请解释一下-this-与-super-关键字" tabindex="-1"><a class="header-anchor" href="#请解释一下-this-与-super-关键字" aria-hidden="true">#</a> 请解释一下 this 与 super 关键字？</h3><blockquote><p>this: ① 本类的对象；② 本类的构造函数。<br> super: ① 父类的对象；② 父类的构造函数。</p></blockquote><h3 id="说一下类与对象的区别" tabindex="-1"><a class="header-anchor" href="#说一下类与对象的区别" aria-hidden="true">#</a> 说一下类与对象的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类是具有相同属性和行为的一个群体，而对象则是这个群体中的一个个体;我们在使用时，先设计类，在创建对象，也就是说，类是创建对象的模板。</p></div><h3 id="类与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#类与抽象类的区别" aria-hidden="true">#</a> 类与抽象类的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类和抽象类的本质是一样的，都是类;但是抽象类一般是以基类的身份出现的，服务于子类的，可以包含抽象方法，普通类不可以，换句话说，抽象类可以不含抽象方法，但含抽象方法的类一定是抽象类。抽象类不可以被实例化，而普通类则可以。</p></div><h3 id="什么是接口" tabindex="-1"><a class="header-anchor" href="#什么是接口" aria-hidden="true">#</a> 什么是接口？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>接口是一系列方法的声明，是一些抽象方法的集合，是对类的行为定制的一套标准、一套规范、一套约束;
</code></pre></div><h3 id="接口中能定义的主要成员有哪些" tabindex="-1"><a class="header-anchor" href="#接口中能定义的主要成员有哪些" aria-hidden="true">#</a> 接口中能定义的主要成员有哪些？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>属性和方法;
</code></pre></div><h3 id="接口和抽象类的区别是什么-必会" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的区别是什么-必会" aria-hidden="true">#</a> 接口和抽象类的区别是什么？(必会)</h3><p>① <strong>实现</strong>：抽象类的子类使用<code>extends</code>来继承；接口必须使用<code>implements</code>来实现接口。<br> ② <strong>构造函数</strong>：抽象类可以有构造函数；接口不能有。<br> ③ <strong>main 方法</strong>：抽象类可以有 main 方法，并且我们可以允许它；接口不能有 main 方法。<br> ④ <strong>实现数量</strong>：类可以实现很多个接口；但是只能继承一个抽象类。<br> ⑤ <strong>访问修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h3 id="抽象类与接口的区别" tabindex="-1"><a class="header-anchor" href="#抽象类与接口的区别" aria-hidden="true">#</a> 抽象类与接口的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>相同点:不能实例化;
不同点:
    ①定义抽象类用abstract关键字，定义接口用interface;
    ②抽象类的本质为类，接口的本质是给类的行为定制规范;
    ③一个类只能有一个父类，但可以实现多个接口;
    ④抽象类中除了有抽象方法外，还可以有普通类中有的所有类成员，但接口中只能有抽象方法与属性(jdk8做了扩展，可以有默认方法与静态方法)
    ⑤访问权限：抽象类(protected -- jdk1.8之前，default/public -- jdk1.8)
    接口(public -- jdk1.8之前，public/default -- jdk1.8)
</code></pre></div><h3 id="如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" tabindex="-1"><a class="header-anchor" href="#如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" aria-hidden="true">#</a> 如何将一个整型转为字符串，反之，将一个字符串类型的数据转为整型</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>整型→字符串:String.valueOf(int parameter)
字符串→整型:Interger.parseInt(String parameter)
</code></pre></div><h3 id="说一下-break-与-continue-作用" tabindex="-1"><a class="header-anchor" href="#说一下-break-与-continue-作用" aria-hidden="true">#</a> 说一下 break 与 continue 作用</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>break</code>语句有两个作用：一是跳出当前循环体，执行循环之外的语句；二是跳出 switch 语句，而 continue 语句表示中止本次循环，继续执行下一次循环。</p></div><h3 id="说一下值传递与引用传递" tabindex="-1"><a class="header-anchor" href="#说一下值传递与引用传递" aria-hidden="true">#</a> 说一下值传递与引用传递</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  Java 数据类型包括基本数据类型和引用数据类型，其中基本数据类型使用值传递，实质是传递数值的副本，当调用使用值传递交换数据时，原数据不会发生改变；而引用数据类型使用引用传递，传递的实质是引用的地址，当调用引用传递交换数据时，因为地址指向变了，所以原数据发生改变。</p></div><h3 id="如何获取数组元素的数量" tabindex="-1"><a class="header-anchor" href="#如何获取数组元素的数量" aria-hidden="true">#</a> 如何获取数组元素的数量</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>数组-属性:length
字符串-方法:length()
</code></pre></div><h3 id="写出数组排序-冒泡法排序" tabindex="-1"><a class="header-anchor" href="#写出数组排序-冒泡法排序" aria-hidden="true">#</a> 写出数组排序(冒泡法排序)</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  冒泡排序就是依次比较相邻的两个数，以升序为例，就是将小数放前面，大数放后面；假设需要排序的序列个数为 n，则需要经过 n-1 轮，最终完成排序。在第一轮中，比较的次数是 n-1 次，之后每轮次数减一。</p></div><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment">// 临时变量</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 需要比较n-1轮</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 每轮需要比较的次数逐轮减少1次</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 相邻元素比较，符合条件交换</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="说一下你知道的-java-中常见的包" tabindex="-1"><a class="header-anchor" href="#说一下你知道的-java-中常见的包" aria-hidden="true">#</a> 说一下你知道的 java 中常见的包</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang:系统基础类库。比如:String、Math、System、Thread等等;
java.util:Java工具类，包含对集合的操作、日期时间设置等等各种使用工具类;
java.io:io流文件的读写操作;
java.net:为实现网络应用程序而提供的类;
java.awt/javax.swing:用于窗体开发的类;
java.sql:数据库操作类库。
</code></pre></div><h3 id="final-、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final-、finally、finalize-的区别" aria-hidden="true">#</a> final 、finally、finalize 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>final三个作用:修饰变量、方法、类;
finally是java的一种异常处理机制，通常放在try、catch后面，正常情况下此结构体使代码[总会执行]，(虚拟机终止，语句块终止、打断其实不会执行)而不管异常是否发生。
finalize是java.lang.Object类中的一个方法，用于垃圾回收机制中资源的释放。
</code></pre></div><h3 id="说一下-java-中的异常分类" tabindex="-1"><a class="header-anchor" href="#说一下-java-中的异常分类" aria-hidden="true">#</a> 说一下 JAVA 中的异常分类</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>异常包括:Error和Exception
Exception:RuntimeException(运行时异常)和CheckedException(检查时异常)
</code></pre></div><figure><img src="`+m+`" alt="异常分类.jpg" width="550" tabindex="0" loading="lazy"><figcaption>异常分类.jpg</figcaption></figure><h3 id="java-中异常父类-根父类-是哪一个" tabindex="-1"><a class="header-anchor" href="#java-中异常父类-根父类-是哪一个" aria-hidden="true">#</a> JAVA 中异常父类(根父类)是哪一个？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang.Throwable
</code></pre></div><h3 id="说出常见的几个运行时异常-5-个以上" tabindex="-1"><a class="header-anchor" href="#说出常见的几个运行时异常-5-个以上" aria-hidden="true">#</a> 说出常见的几个运行时异常？(5 个以上)</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>运行时异常(RuntimeException):
    NullPointerException(空指针异常)
    ClassCastException(类型转换异常)
    IndexOutOfBoundsException(角标越界异常)
    ArithmeticException(数学运算异常)  /əˈrɪθmətɪk/
    IllegalArgumentException(不合法参数异常)
    SystemException(系统异常)
    NumberFormatException(数字格式化异常)

检查时异常(CheckedExcption):
 IOException(IO异常)
 ClassNotFoundException(类没找到异常)
 FileNotFoundException(文件找不到异常)
 SQLException(SQL异常)
</code></pre></div><h3 id="throw-与-throws-区别" tabindex="-1"><a class="header-anchor" href="#throw-与-throws-区别" aria-hidden="true">#</a> throw 与 throws 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>throw关键字表示手动抛异常
throws关键字表示声明异常(在定义方法，同时给方法声明一个异常)
</code></pre></div><h3 id="异常处理的基本结构" tabindex="-1"><a class="header-anchor" href="#异常处理的基本结构" aria-hidden="true">#</a> 异常处理的基本结构？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① try / catch
② try / catch / finally
③ try / finally
</code></pre></div><h3 id="jdk-1-8-新特性" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-新特性" aria-hidden="true">#</a> JDK 1.8 新特性</h3><p>① <strong>Lambda 表达式</strong><br>   允许把函数作为一个方法的参数。</p><p>② <strong>方法引用</strong><br>   方法引用允许直接引用已有 Java 类或对象的方法或构造方法。</p><p>③ <strong>函数式接口</strong><br>   有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为 Lambda 表达式。通常函数式接口上会添加<code>@FunctionalInterface</code>注解。</p><p>④ <strong>接口允许定义默认方法和静态方法</strong><br>   从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法。</p><p>⑤ <strong>Stream API</strong><br>   新添加的 Stream API（java.util.stream）把真正的函数式编程风格引入到 Java 中。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。</p><p>⑥ <strong>日期/时间类改进</strong><br>   之前的 JDK 自带的日期处理类非常不方便，我们处理的时候经常是使用的第三方工具包，比如 commons-lang 包等。不过 JDK8 出现之后这个改观了很多，比如日期时间的创建、比较、调整、 格式化、时间间隔等。这些类都在 java.time 包下，LocalDate/LocalTime/LocalDateTime。</p><p>⑦ <strong>Optional 类</strong><br>   Optional 类是一个可以为 null 的容器对象。如果值存在则 isPresent()方法会返 回 true，调用 get()方法会返回该对象。</p><p>⑧ <strong>Java 8 Base64 实现</strong><br>   Java 8 内置了 Base64 编码的编码器和解码器。</p><h2 id="集合-⭐️" tabindex="-1"><a class="header-anchor" href="#集合-⭐️" aria-hidden="true">#</a> 集合 ⭐️</h2><h3 id="栈与队列的区别" tabindex="-1"><a class="header-anchor" href="#栈与队列的区别" aria-hidden="true">#</a> 栈与队列的区别？</h3><blockquote><p>队列：先进先出(FIFO)，它只允许在前端进行删除操作，在后端进行插入操作。<br> 栈：先进后出，它只能在一端进行插入和删除操作。</p></blockquote><h3 id="顺序存储结构与链式存储结构的优缺点" tabindex="-1"><a class="header-anchor" href="#顺序存储结构与链式存储结构的优缺点" aria-hidden="true">#</a> 顺序存储结构与链式存储结构的优缺点</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>顺序存储结构:
 优:一是节省存储空间;二是访问速度快;
 缺:进行插入、删除元素时效率低。

链式存储结构:
 优:进行插入、删除元素时效率高;
 缺:一是对空间的占用比较大;二是访问速度慢。
</code></pre></div><h3 id="数据查找-遍历、二分查找-说一下二分查找的条件" tabindex="-1"><a class="header-anchor" href="#数据查找-遍历、二分查找-说一下二分查找的条件" aria-hidden="true">#</a> 数据查找：遍历、二分查找，说一下二分查找的条件</h3><p>必须是有序数组</p><h3 id="java-中常见的三种集合是哪三种" tabindex="-1"><a class="header-anchor" href="#java-中常见的三种集合是哪三种" aria-hidden="true">#</a> java 中常见的三种集合是哪三种？</h3><p><code>List、Set、Map</code></p><h3 id="list-与-set-的区别" tabindex="-1"><a class="header-anchor" href="#list-与-set-的区别" aria-hidden="true">#</a> List 与 Set 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>List集合元素按进入先后有序保存，可重复;
Set集合仅接收一次，无序，不可重复;
</code></pre></div><h3 id="arraylist-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-linkedlist-的区别" aria-hidden="true">#</a> ArrayList 与 LinkedList 的区别</h3><p>  ArrayList 是基于数组来实现的，比较节省存储空间，在查询时访问元素速度快效率高，但在进行修改操作时性能差；<br>   LinkedList 是基于双向链表来实现的，在进行修改操作时性能好，效率高，但对空间的占用大，在查询时访问速度慢。</p><h3 id="arraylist-与-vector-区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-vector-区别" aria-hidden="true">#</a> ArrayList 与 Vector 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>两者都是List集合，但ArrayList是线程非安全的，Vector是线程安全的。
</code></pre></div><h3 id="hashmap-与-hashtable-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-区别" aria-hidden="true">#</a> HashMap 与 Hashtable 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>HashMap集合中的key可以为null，值也可以是null，(只能由一个key为null)，它是线程非安全的;
Hashtable集合中的key-value都不能为空，它是线程安全的。
</code></pre></div><h3 id="hashmap-与-treemap-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-treemap-区别" aria-hidden="true">#</a> HashMap 与 TreeMap 区别？</h3><p>TreeMap 相对 HashMap，多了一个排序的功能</p><h3 id="集合迭代器的接口" tabindex="-1"><a class="header-anchor" href="#集合迭代器的接口" aria-hidden="true">#</a> 集合迭代器的接口？</h3><p><code>iterator</code></p><h3 id="遍历-list-有哪些不同的方式" tabindex="-1"><a class="header-anchor" href="#遍历-list-有哪些不同的方式" aria-hidden="true">#</a> 遍历 List 有哪些不同的方式？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>for循环、增强for循环、iterator迭代器
</code></pre></div><h3 id="hashset-和-treeset-的区别" tabindex="-1"><a class="header-anchor" href="#hashset-和-treeset-的区别" aria-hidden="true">#</a> HashSet 和 TreeSet 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>TreeSet相对于HashSet，多了一个排序的功能;
</code></pre></div><h3 id="collection-与-collections-的区别" tabindex="-1"><a class="header-anchor" href="#collection-与-collections-的区别" aria-hidden="true">#</a> Collection 与 Collections 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>Collection是集合的父接口，Collections是集合工具类。
</code></pre></div><h3 id="什么是-properties-类" tabindex="-1"><a class="header-anchor" href="#什么是-properties-类" aria-hidden="true">#</a> 什么是 Properties 类？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>该类主要用于读取 Java 的配置文件，不同的编程语言有自己所支持的配置文件，配置文件中很多变量是经常改变的，为了方便用户的配置，能让用户够脱离程序本身去修改相关的变量设置。就像在 Java 中，其配置文件常为*.properties 文件，是以键值对的形式进行参数配置的。</p></div><h3 id="java-中有几种类型的流" tabindex="-1"><a class="header-anchor" href="#java-中有几种类型的流" aria-hidden="true">#</a> JAVA 中有几种类型的流？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>①数据单位:字节流、字符流
②流向:输入流、输出流
③角色:节点流、处理流
</code></pre></div><h3 id="字节流与字符流的区别" tabindex="-1"><a class="header-anchor" href="#字节流与字符流的区别" aria-hidden="true">#</a> 字节流与字符流的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>对于文本文件(.txt，.java，.c，.c++)，使用字符流处理;
对于非文本文件(.jpg，.mp3，.mp4，.avi，.doc，.ppt)，使用字节流处理。
</code></pre></div><h3 id="bufferedreader-流的作用" tabindex="-1"><a class="header-anchor" href="#bufferedreader-流的作用" aria-hidden="true">#</a> BufferedReader 流的作用？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>BufferedReader 属于输入字符缓冲流，缓冲流是一种装饰器类，目的是让原字节流、字符流新增缓冲的功能。缓冲流作用是把数据先写入内存缓冲区，等缓冲区满了，再把数据写到文件里。读内存比读硬盘速度快很多倍，所以这样效率就大大提高了。</p></div><h3 id="什么是序列化-什么是反序列化" tabindex="-1"><a class="header-anchor" href="#什么是序列化-什么是反序列化" aria-hidden="true">#</a> 什么是序列化，什么是反序列化？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>序列化:将对象转为流，用来存贮或者网络传输;
反序列化:将流中的数据转为对象。
</code></pre></div><h3 id="什么是-xml" tabindex="-1"><a class="header-anchor" href="#什么是-xml" aria-hidden="true">#</a> 什么是 XML？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>XML 是可扩展标记语言(eXtensible [/ɪkˈstensəbl/] Markup Language)的简称。它是一个纯文本格式的文件，相对于文本，文档的内容一般用标签包裹;XML 在项目中主要用来存放配置信息。</p></div><h2 id="多线程-⭐️" tabindex="-1"><a class="header-anchor" href="#多线程-⭐️" aria-hidden="true">#</a> 多线程 ⭐️</h2><h3 id="什么是线程、什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是线程、什么是进程" aria-hidden="true">#</a> 什么是线程、什么是进程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>进程:运行中的程序称为进程;
线程:进程中的一条执行流(进程中可以同时由多个执行流-多线程，多线程的应用程序，程序可以并行执行多个任务，相对单线程应用程序，效率要高很多)
&gt; 线程是进程的子集，一个进程可以有多个线程
&gt; 额外知识理解:
 并行:多个CPU同时执行多个任务，如:多个人同时做不同的事
 并发:一个CPU同时执行多个任务，如:多个人做同一件事
</code></pre></div><h3 id="如何创建一个线程" tabindex="-1"><a class="header-anchor" href="#如何创建一个线程" aria-hidden="true">#</a> 如何创建一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① 继承于Thread类
② 实现Runnable接口
③ 实现Callable接口
④ 使用线程池
</code></pre></div><h3 id="如何启动一个线程" tabindex="-1"><a class="header-anchor" href="#如何启动一个线程" aria-hidden="true">#</a> 如何启动一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>调用start()方法;
</code></pre></div><h3 id="start-方法与-run-方法的区别" tabindex="-1"><a class="header-anchor" href="#start-方法与-run-方法的区别" aria-hidden="true">#</a> start()方法与 run()方法的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>start()方法是启动当前线程，并调用run()方法;(只能调用一次，否则抛出&quot;IllegalThreadStateException&quot;异常)
run()方法通常需要重写，要执行的代码声明在此方法中。
</code></pre></div><h3 id="什么是线程池-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池-为什么要使用线程池" aria-hidden="true">#</a> 什么是线程池，为什么要使用线程池？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程池就是存放多个线程的容器;可以重用线程，减少创建和销毁线程带来的消耗。
</code></pre></div><h3 id="什么是线程同步" tabindex="-1"><a class="header-anchor" href="#什么是线程同步" aria-hidden="true">#</a> 什么是线程同步？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>当多个线程访问同一资源，就需要解决数据一致性的问题，这时候就需要线程同步来解决这个问题。
线程同步:一次只允许某一个线程对某一资源进行访问称为线程同步。
</code></pre></div><h3 id="java-中的线程锁" tabindex="-1"><a class="header-anchor" href="#java-中的线程锁" aria-hidden="true">#</a> java 中的线程锁？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程锁(synchronized)作为并发共享数据，保证一致性的工具。
</code></pre></div><h3 id="说一下线程的几种状态" tabindex="-1"><a class="header-anchor" href="#说一下线程的几种状态" aria-hidden="true">#</a> 说一下线程的几种状态</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>新建--就绪--运行--阻塞--死亡
</code></pre></div><figure><img src="`+v+`" alt="线程状态转换图.jpg" width="600" tabindex="0" loading="lazy"><figcaption>线程状态转换图.jpg</figcaption></figure><h3 id="线程操作常见的-api" tabindex="-1"><a class="header-anchor" href="#线程操作常见的-api" aria-hidden="true">#</a> 线程操作常见的 API</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code> start():①启动当前线程;②调用run();
 run():线程在被调度时执行的操作
 currentThread():静态方法，返回执行当前代码的线程
 getName():获取当前线程名字
 setName():设置当前线程名字
 yield():释放当前CPU的执行权
 join():在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态
 stop():已过时。当执行此方法时，强制结束当前线程
 sleep(long mills):让当前线程“睡眠”--阻塞(毫秒)
 isAlive():判断线程还存活
</code></pre></div><h3 id="sleep-与-wait-区别" tabindex="-1"><a class="header-anchor" href="#sleep-与-wait-区别" aria-hidden="true">#</a> sleep 与 wait 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① sleep()的父类是Thread类，wait()的父类是Object()类;
② wait()方法使当前线程进入等待状态，直到另一线程对该对象发出notify/notifyAll来唤醒，sleep()方法是让线程处于休眠，预设值结束自动结束休眠。
③ sleep()不释放同步锁，wait()释放同步锁。
④ wait()通常放在同步代码块里，而sleep()则不受限制。
</code></pre></div><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2>`,124);function Z(Y,$){const o=i("CodeTabs");return u(),r("div",null,[f,a("details",x,[y,c(o,{id:"301",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("反编译")]),tab0:s(({value:t,isActive:e})=>[w]),tab1:s(({value:t,isActive:e})=>[j]),_:1},8,["data"]),S,c(o,{id:"312",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("反编译")]),tab0:s(({value:t,isActive:e})=>[_]),tab1:s(({value:t,isActive:e})=>[J]),_:1},8,["data"]),C,A,c(o,{id:"328",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("反编译")]),tab0:s(({value:t,isActive:e})=>[q]),tab1:s(({value:t,isActive:e})=>[z]),_:1},8,["data"]),I,D,c(o,{id:"344",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("反编译")]),tab0:s(({value:t,isActive:e})=>[B]),tab1:s(({value:t,isActive:e})=>[E]),_:1},8,["data"]),N]),O,c(o,{id:"609",data:[{id:"代码"},{id:"输出结果"}]},{title0:s(({value:t,isActive:e})=>[n("代码")]),title1:s(({value:t,isActive:e})=>[n("输出结果")]),tab0:s(({value:t,isActive:e})=>[L]),tab1:s(({value:t,isActive:e})=>[P]),_:1}),M,a("details",T,[V,c(o,{id:"697",data:[{id:"App.java"},{id:"Person.java"},{id:"输出"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("Person.java")]),title2:s(({value:t,isActive:e})=>[n("输出")]),tab0:s(({value:t,isActive:e})=>[F]),tab1:s(({value:t,isActive:e})=>[R]),tab2:s(({value:t,isActive:e})=>[H]),_:1},8,["data"])]),K,a("details",U,[X,c(o,{id:"773",data:[{id:"向上转型"},{id:"向下转型"}]},{title0:s(({value:t,isActive:e})=>[n("向上转型")]),title1:s(({value:t,isActive:e})=>[n("向下转型")]),tab0:s(({value:t,isActive:e})=>[G]),tab1:s(({value:t,isActive:e})=>[Q]),_:1})]),W])}const na=l(b,[["render",Z],["__file","java-foundation.html.vue"]]);export{na as default};
