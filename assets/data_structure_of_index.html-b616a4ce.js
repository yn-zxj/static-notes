import{_ as a,o as e,c as n,a as i}from"./app-bb61c5dd.js";const r="/assets/index_none-94d4d891.png",t="/assets/get_by_index-0a20e83d.png",o="/assets/row_format_diagram-3949dcd7.png",s="/assets/row_format_diagram_two-f46d6781.png",d="/assets/page_demo-dd4499ba.png",c="/assets/catalog_entry-d78ed322.png",p="/assets/pic_1-2e14ec99.png",g="/assets/pic_2-f33248c0.png",h="/assets/pic_3-a783d2c1.png",l="/assets/pic_4-8eb4c73e.png",_="/assets/pic_5-38001def.png",m="/assets/pic_6-aec67adc.png",f="/assets/myisam_index-0b7b8940.png",u="/assets/secondary_index-eaac326c.png",b="/assets/2023-06-29-23-31-06-72168675.png",k="/assets/2023-06-29-23-31-19-343441f5.png",x="/assets/2023-06-29-23-31-25-14344b7e.png",y="/assets/2023-06-29-23-31-36-7624c7d1.png",B="/assets/2023-06-29-23-31-46-a22f28f0.png",w="/assets/2023-06-29-23-32-02-08a2037f.png",z="/assets/2023-06-29-23-32-12-bbf92667.png",I="/assets/2023-06-29-23-32-19-8c4c36aa.png",M="/assets/2023-06-29-23-32-29-211a4184.png",A="/assets/2023-06-29-23-32-40-5c1240cd.png",S="/assets/2023-06-29-23-32-50-3ce346ee.png",T="/assets/time_complexity_of_algorithm-3adb5972.png",D={},q=i('<h2 id="_1-为什么使用索引" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用索引" aria-hidden="true">#</a> 1.为什么使用索引</h2><figure><img src="'+r+'" alt="无索引数据读取.png" tabindex="0" loading="lazy"><figcaption>无索引数据读取.png</figcaption></figure><p>假如给数据使用<code>二叉树</code>这样的数据结构进行存储，如下图所示：</p><figure><img src="'+t+`" alt="有索引数据读取.png" width="600" tabindex="0" loading="lazy"><figcaption>有索引数据读取.png</figcaption></figure><h2 id="_2-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_2-索引的优缺点" aria-hidden="true">#</a> 2.索引的优缺点</h2><h3 id="_2-1-索引概述" tabindex="-1"><a class="header-anchor" href="#_2-1-索引概述" aria-hidden="true">#</a> 2.1 索引概述</h3><p>MySQL 官方对索引的定义为：<mark>索引(Index)是帮助 MySQL 高效获取数据的数据结构。</mark></p><h3 id="_2-2-优点" tabindex="-1"><a class="header-anchor" href="#_2-2-优点" aria-hidden="true">#</a> 2.2 优点</h3><p>① 类似图书馆建书目索引，<mark>提高数据检索的效率，降低数据库的 IO 成本</mark>，这也是创建索引最主要的原因；<br> ② 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性；<br> ③ 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度；<br> ④ 在使用分组和排序子句进行数据查询时，可以显著减少查询分组和排序的时间，降低了 CPU 的消耗。</p><h3 id="_2-3-缺点" tabindex="-1"><a class="header-anchor" href="#_2-3-缺点" aria-hidden="true">#</a> 2.3 缺点</h3><p>① 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加；<br> ② 索引需要占用磁盘空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸；<br> ③ 虽然索引大大提高了查询速度，但同时却会降低更新表的速度。当对表的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据维护的速度。</p><p><strong><u>因此，选择使用索引时，需要综合考虑索引的优缺点</u></strong>。</p><h2 id="_3-innodb-中索引的推演" tabindex="-1"><a class="header-anchor" href="#_3-innodb-中索引的推演" aria-hidden="true">#</a> 3.InnoDB 中索引的推演</h2><h3 id="_3-1-索引之前的查找" tabindex="-1"><a class="header-anchor" href="#_3-1-索引之前的查找" aria-hidden="true">#</a> 3.1 索引之前的查找</h3><p>先看一个精准匹配的例子：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token punctuation">[</span> 列名列表 <span class="token punctuation">]</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> xxx<span class="token punctuation">;</span>
</code></pre></div><h4 id="_1-在一个页中的查找" tabindex="-1"><a class="header-anchor" href="#_1-在一个页中的查找" aria-hidden="true">#</a> 1) 在一个页中的查找</h4><h4 id="_2-在很多页中的查找" tabindex="-1"><a class="header-anchor" href="#_2-在很多页中的查找" aria-hidden="true">#</a> 2) 在很多页中的查找</h4><p>  在没有索引的情况下，不论是根据主键列或者其它列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<mark>从第一个页</mark>沿着<mark>双向链表</mark>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<mark>超级耗时</mark>的。这是<code>索引</code>应运而生。</p><h3 id="_3-2-设计索引" tabindex="-1"><a class="header-anchor" href="#_3-2-设计索引" aria-hidden="true">#</a> 3.2 设计索引</h3><p>建一个表：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> index_demo<span class="token punctuation">(</span>
  c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>
  c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
  c3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token punctuation">)</span> ROW_FORMAT <span class="token operator">=</span> Compact<span class="token punctuation">;</span>
</code></pre></div><p>这个新建的<code>index_demo</code>表中有两个<code>INT</code>类型的列，一个<code>CHAR(1)</code>类型的列，而且规定了<code>c1</code>列作为主键，此外这个表使用<code>Compact</code>行格式来实际存储记录。下面是简化的<code>index_demo</code>表的行格式示意图：</p><figure><img src="`+o+'" alt="行格式示意图.png" width="500" tabindex="0" loading="lazy"><figcaption>行格式示意图.png</figcaption></figure><p>只在示意图里展示记录的这几个部分：</p><p>① <code>record_type</code>: 记录头信息的一项属性，表示记录的类型，<code>0</code>表示<mark>普通</mark>记录，<code>2</code>表示<mark>最小</mark>记录，<code>3</code>表示<mark>最大</mark>记录，<code>1</code>暂时还没用过；</p><p>② <code>next_record</code>: 记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁；</p><p>③ <code>各列的值</code>: 这里只记录在 index_demo 表中的三个列，即：c1、c2、c3；</p><p>④ <code>其它信息</code>: 除了上述三种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果是下面这样:</p><figure><img src="'+s+'" alt="行格式示意图-竖.png" width="500" tabindex="0" loading="lazy"><figcaption>行格式示意图-竖.png</figcaption></figure><p>把一些记录放到页里的示意图就是下面这样：</p><figure><img src="'+d+'" alt="页存放记录示意图.png" width="600" tabindex="0" loading="lazy"><figcaption>页存放记录示意图.png</figcaption></figure><h4 id="_1-一个简单的索引设计方案" tabindex="-1"><a class="header-anchor" href="#_1-一个简单的索引设计方案" aria-hidden="true">#</a> 1) 一个简单的索引设计方案</h4><p>  我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们搜索条件匹配那些页中的记录，所以不得不一次遍历所有的数据页。所以如果我们想要快速的定位到需要查找的记录在哪些数据页中该怎么办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下面这些事：</p><p>① 下一个数据页中的用户记录的主键值必须大于上一个页中的用户记录的主键值</p><p>② 给所有页建立一个目录项</p><div class="hint-container tip"><p class="hint-container-title">为上面几个页做好的目录如下</p><figure><img src="'+c+'" alt="目录项.png" width="700" tabindex="0" loading="lazy"><figcaption>目录项.png</figcaption></figure><p>  以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的做好主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储(比如：数组)，就可以实现根据主键值快速查找某条记录的功能。比如：查找主键值为<code>20</code>的记录，具体查找步骤分为两步：<br>  ① 先从目录项中根据<mark>二分法</mark>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中(因为<code>12 &lt; 20 &lt; 209</code>)，它对应的页是<code>页9</code>；<br>  ② 再根据前面说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p><p>至此，针对数据页做的简易目录就完成了。这个目录有一个别名，称为<code>索引</code>。</p></div><h4 id="_2-innodb-中的索引方案" tabindex="-1"><a class="header-anchor" href="#_2-innodb-中的索引方案" aria-hidden="true">#</a> 2) InnoDB 中的索引方案</h4><p>(1) <strong>迭代一次</strong>：目录记录的页</p><p>我们把前面使用到的目录项放到数据页中的样子如下：</p><figure><img src="'+p+'" alt="图一.png" width="700" tabindex="0" loading="lazy"><figcaption>图一.png</figcaption></figure><p>从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调目录项记录和普通的用户记录的差异：</p><p><strong>不同点</strong>：<br>  ① 目录项记录的<code>record_type = 1</code>，而普通用户记录的<code>record_type = 0</code>；<br>  ② 目录项记录只有<mark>主键值和页的编号</mark>两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列；<br>  ③ (了解)记录头信息里还有一个叫<code>min_rec_mask</code>的属性，<mark>只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1</mark>，其他的记录的 min_rec_mask 的值都是 0。</p><p><strong>相同点</strong>：两者用的都是一样的数据页，都会为主键生成 Page Directory(页目录)，从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p><u>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分为下面步骤</u>：<br>  ① 先到存储目录项记录的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 &lt; 20 &lt; 209，所以定位到对应的记录在页 9；<br>  ② 再到存储用户记录的页 9 中根据二分法快速定位到主键值为 20 的用户记录。</p><hr><p>(2) <strong>迭代两次</strong>：多个目录项记录的页</p><figure><img src="'+g+'" alt="图二.png" width="700" tabindex="0" loading="lazy"><figcaption>图二.png</figcaption></figure><p>从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储改用户记录而新生成了<code>页31</code></li><li>因为原先存储目录项记录的<code>页30</code>的容量已满(假设一个页只能存储四条目录项记录)，所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要 3 个步骤，以查找主键值为 20 的记录为例：</p><p>① 确定<mark>目录项记录页</mark></p><blockquote><p>现在存储目录项记录的页有两个，即页 30 和页 32，又因为页 30 表示的目录项的主键值的范围是[1, 320)，页 32 表示的目录项的主键值不小于 320，所以主键值 20 的记录对应的目录项记录在页 30 中。</p></blockquote><p>② 通过目录项记录页<mark>确定用户记录真实所在的页</mark></p><p>③ 在真实存储用户记录的页中定位到具体的记录</p><hr><p>(3) <strong>迭代三次</strong>：目录项记录页的目录页(给目录建目录)</p><figure><img src="'+h+'" alt="图三.png" width="700" tabindex="0" loading="lazy"><figcaption>图三.png</figcaption></figure><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页 30 和页 32，如果用户记录在主键值[1, 320)之间，则到页 30 查找具体记录；如果大于 320 则去页 32 找记录。</p><p>可以用下边这个图来描述它，这个数据结构就叫<mark>B+树</mark>。</p><figure><img src="'+l+'" alt="图四.png" width="700" tabindex="0" loading="lazy"><figcaption>图四.png</figcaption></figure><p>(4) <strong>B+Tree</strong></p><p>  一个 B+树的节点其实可以分为好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后往上依次加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放<code>3</code>条记录，存放目录项记录的页最多存放<code>4</code>条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100</code>条用户记录，所有存放目录项记录的内节点代表的数据页可以存放<code>1000</code>条目录项记录，那么：</p><ul><li>如果 B+树只有一层，也就是只有 1 个用于存放用户记录的节点，最多能存放<code>100</code>条记录</li><li>如果 B+树有两层，最多存放<code>100 * 1000 = 10,0000</code>条记录</li><li>如果 B+树有三层，最多存放<code>100 * 1000 * 1000 = 1,0000,0000</code>条记录</li><li>如果 B+树有四层，最多存放<code>100 * 1000 * 1000 * 1000 = 1000,0000,0000</code>条记录</li></ul><p>  假设的四层 B+树能存放的记录数十分庞大！实际不可能存如此之多，所以一般情况下，我们<mark>用到的 B+树都不会超过 4 层</mark>，那我们通过主键值去查找某条记录最多只需要做 4 个页面的查找(查找三个目录页和一个数据页)，又因为在每个页面内有所谓的 Page Directory(页目录)，所以在页面内也可以通过<mark>二分法</mark>实现快速定位记录。</p><h3 id="_3-3-常见索引概念" tabindex="-1"><a class="header-anchor" href="#_3-3-常见索引概念" aria-hidden="true">#</a> 3.3 常见索引概念</h3><p>索引按照物理实现方式，可以分为：聚簇(聚集)索引和非聚簇(聚集)索引。也把非聚簇索引称为二级索引或者辅助索引。</p><h4 id="_1-聚簇索引" tabindex="-1"><a class="header-anchor" href="#_1-聚簇索引" aria-hidden="true">#</a> (1) 聚簇索引</h4><p><strong>特点</strong>：<br> ① 使用记录主键值的大小进行记录和页的排序，包括三个方面的含义：<br>  -- 页内的记录是按照主键的大小顺序排成一个<mark>单向链表</mark><br>  -- 各个存放<mark>用户记录的页</mark>也是根据页中用户记录的主键大小顺序排成一个<mark>双向链表</mark><br>  -- 存放<mark>目录项记录的页</mark>分为不同的层次，在同一层次中的页面也是根据页目录项记录的主键大小顺序排成一个<mark>双向链表</mark></p><p>② B+树的<mark>叶子节点</mark>存储的就是完整的用户记录<br>  -- 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)</p><hr><p><strong>优点</strong>：<br> ① <mark>数据访问更快</mark>，因为聚簇索引将索引和数据保存在同一个 B+树中，因此从聚簇索引中获取数据比非聚簇索引更快<br> ② 聚簇索引对于主键的<mark>排序查找</mark>和<mark>范围查找</mark>速度非常快<br> ③ 按照聚簇索引排序顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<mark>节省了大量的 IO 操作</mark></p><hr><p><strong>缺点</strong>：<br> ① <mark>插入速度严重依赖于插入顺序</mark>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因为，对于 InnoDB 表，我们一般都会定义一个<strong>自增的 ID 列最为主键</strong><br> ② <mark>更新主键的代价很高</mark>，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义<strong>主键为不可更新</strong><br> ③ <mark>二级索引访问需要两次索引查找</mark>，第一次找到主键，第二次根据主键值找到行数据</p><h4 id="_2-非聚簇索引-辅助索引、二级索引" tabindex="-1"><a class="header-anchor" href="#_2-非聚簇索引-辅助索引、二级索引" aria-hidden="true">#</a> (2) 非聚簇索引(辅助索引、二级索引)</h4><figure><img src="'+_+'" alt="图五.png" width="700" tabindex="0" loading="lazy"><figcaption>图五.png</figcaption></figure><p><strong>概念</strong>：我们根据这个以 c2 列大小排序的 B+树只能确定我们要查找的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为<mark>回表</mark>。也就是根据 c2 列的值查询一条完整的用户记录需要使用到<mark>2</mark>颗 B+树。</p><p><strong>问题</strong>：为什么我们还需要一次回表操作呢？直接把完整的用户记录放叶子节点不行吗？</p><figure><img src="'+m+'" alt="图六.png" width="700" tabindex="0" loading="lazy"><figcaption>图六.png</figcaption></figure><h5 id="_3-联合索引" tabindex="-1"><a class="header-anchor" href="#_3-联合索引" aria-hidden="true">#</a> (3) 联合索引</h5><p>  我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：<br>  ① 先把各个记录和页按照 c2 列进行排序<br>  ② 在 c2 列记录相同的情况下，采用 c3 列进行排序</p><p>  注意一点，以 c2 和 c3 列大小为排序规则建立的 B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：<br>  ① 建立联合索引只会建立如上图一样的一颗 B+树<br>  ② 为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立两颗 B+树</p><h3 id="_3-4-innodb-的-b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#_3-4-innodb-的-b-树索引的注意事项" aria-hidden="true">#</a> 3.4 InnoDB 的 B+树索引的注意事项</h3><p>① <strong>根页面位置万年不动</strong><br> ② <strong>内节点中目录项记录的唯一性</strong><br> ③ <strong>一个页面最少存储两条记录</strong></p><h2 id="_4-myisam-中的索引方案" tabindex="-1"><a class="header-anchor" href="#_4-myisam-中的索引方案" aria-hidden="true">#</a> 4.MyISAM 中的索引方案</h2><p><strong>B 树索引适用存储引擎如表所示</strong>：</p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>  即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。InnoDB 和 MyISAM 默认的索引是 B-Tree 索引，而 Memory 默认的索引是 Hash 索引。</p><p>  MyISAM 引擎使用<mark>B+Tree</mark>作为索引结构，叶子节点的 data 域存放的是<mark>数据记录的地址</mark>。</p><h3 id="_4-1-myisam-索引的原理" tabindex="-1"><a class="header-anchor" href="#_4-1-myisam-索引的原理" aria-hidden="true">#</a> 4.1 MyISAM 索引的原理</h3><p>下面是 MyISAM 索引的原理图：</p><figure><img src="'+f+'" alt="MyISAM索引原理图.png" width="700" tabindex="0" loading="lazy"><figcaption>MyISAM索引原理图.png</figcaption></figure><p>如果我们在 col2 上建立一个二级索引，则索引的结构如下图所示：</p><figure><img src="'+u+'" alt="二级索引.png" width="700" tabindex="0" loading="lazy"><figcaption>二级索引.png</figcaption></figure><h3 id="_4-2-myisam-和-innodb-对比" tabindex="-1"><a class="header-anchor" href="#_4-2-myisam-和-innodb-对比" aria-hidden="true">#</a> 4.2 MyISAM 和 InnoDB 对比</h3><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_5-索引的代价" tabindex="-1"><a class="header-anchor" href="#_5-索引的代价" aria-hidden="true">#</a> 5.索引的代价</h2><h2 id="_6-mysql-数据结构选择的合理性" tabindex="-1"><a class="header-anchor" href="#_6-mysql-数据结构选择的合理性" aria-hidden="true">#</a> 6.MySQL 数据结构选择的合理性</h2><h3 id="_6-1-全表遍历" tabindex="-1"><a class="header-anchor" href="#_6-1-全表遍历" aria-hidden="true">#</a> 6.1 全表遍历</h3><h3 id="_6-2-hash-结构" tabindex="-1"><a class="header-anchor" href="#_6-2-hash-结构" aria-hidden="true">#</a> 6.2 Hash 结构</h3><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-3-二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_6-3-二叉搜索树" aria-hidden="true">#</a> 6.3 二叉搜索树</h3><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-4-avl-树" tabindex="-1"><a class="header-anchor" href="#_6-4-avl-树" aria-hidden="true">#</a> 6.4 AVL 树</h3><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-5-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-5-b-tree" aria-hidden="true">#</a> 6.5 B-Tree</h3><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-6-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-6-b-tree" aria-hidden="true">#</a> 6.6 B+Tree</h3><h3 id="_6-7-r-树" tabindex="-1"><a class="header-anchor" href="#_6-7-r-树" aria-hidden="true">#</a> 6.7 R 树</h3><h3 id="附录-算法的时间复杂度" tabindex="-1"><a class="header-anchor" href="#附录-算法的时间复杂度" aria-hidden="true">#</a> 附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><figure><img src="'+T+'" alt="算法的时间复杂度.png" tabindex="0" loading="lazy"><figcaption>算法的时间复杂度.png</figcaption></figure>',119),v=[q];function R(E,C){return e(),n("div",null,v)}const H=a(D,[["render",R],["__file","data_structure_of_index.html.vue"]]);export{H as default};
