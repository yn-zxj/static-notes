import{_ as i,j as p,o as r,c as d,g as l,w as t,a as o,i as n,f as a}from"./app-cb8d9fe0.js";const u="/assets/base-type-fa548d7e.jpg",h="/assets/t-01-a2fd61f9.png",k="/assets/throwable-59a159de.jpg",g={},v=o(`<h2 id="java-基础知识" tabindex="-1"><a class="header-anchor" href="#java-基础知识" aria-hidden="true">#</a> Java 基础知识</h2><h3 id="说一下-java-的三种注释" tabindex="-1"><a class="header-anchor" href="#说一下-java-的三种注释" aria-hidden="true">#</a> 说一下 JAVA 的三种注释</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>// 单行注释
/*...*/ 多行注释
/...*/ 文档注释
</code></pre></div><h3 id="面向对象的特征-了解" tabindex="-1"><a class="header-anchor" href="#面向对象的特征-了解" aria-hidden="true">#</a> 面向对象的特征(了解)</h3><p><strong>面向对象的特征</strong>：<u class="under-dot">封装、继承、多态、抽象</u></p><blockquote><p><strong>封装</strong>：把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的，增加安全性。</p><hr><p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p><hr><p><strong>多态</strong>：指允许不同的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><hr><p><strong>抽象</strong>：表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用此关键字修饰类时，此类就不能被实例化，这这里可以看出，抽象类(接口)就是为了继承而存在的。</p></blockquote><h3 id="java-的数据类型" tabindex="-1"><a class="header-anchor" href="#java-的数据类型" aria-hidden="true">#</a> Java 的数据类型</h3><div class="hint-container tip"><p class="hint-container-title">数据类型</p><p>  Java 数据类型包括两大类：基本数据类型和引用数据类型；其中八个基本数据类型包括整型(byte、short、int、long)、浮点型(float、double)、字符型(char)、布尔型(boolean)；除此之外的都为引用数据类型，比如类、接口、数组。</p></div><figure><img src="`+u+`" alt="基本数据类型.jpg" width="600" tabindex="0" loading="lazy"><figcaption>基本数据类型.jpg</figcaption></figure><table><thead><tr><th>数据类型</th><th>字节数</th><th>位数</th><th>默认值</th><th>包装类型</th><th>使用说明[取值范围]</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>0</td><td>Byte</td><td>-128~127</td></tr><tr><td>short</td><td>2</td><td>16</td><td>0</td><td>Short</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int</td><td>4</td><td>32</td><td>0</td><td>Integer</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>long</td><td>8</td><td>64</td><td>0L 或 0l</td><td>Long</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>float</td><td>4</td><td>32</td><td>0.0F 或 0.0f</td><td>Float</td><td>1.4E-45~3.4E38</td></tr><tr><td>double</td><td>8</td><td>64</td><td>0.0d</td><td>Double</td><td>4.9E-324~1.8E308</td></tr><tr><td>char</td><td>2</td><td>16</td><td>空</td><td>Character</td><td>使用 Unicode 编码(2 个字节)，可存汉字</td></tr><tr><td>boolean</td><td>-</td><td>-</td><td>false</td><td>Boolean</td><td>只有 true 和 false 两个取值</td></tr></tbody></table><h3 id="整型的默认数据类型是什么-浮点型的数据类型是什么" tabindex="-1"><a class="header-anchor" href="#整型的默认数据类型是什么-浮点型的数据类型是什么" aria-hidden="true">#</a> 整型的默认数据类型是什么，浮点型的数据类型是什么?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>整型默认数据类型:int
浮点型默认数据类型:double
</code></pre></div><h3 id="jdk、jre、jvm-的区别-必会" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-的区别-必会" aria-hidden="true">#</a> JDK、JRE、JVM 的区别(必会)</h3><blockquote><p><strong>JDK</strong>：JDK(Java Development Kit)即 Java 开发工具包，是整个 Java 的核心，其包括了 Java 运行环境(JRE)、Java 工具和 Java 基础类库。</p><hr><p><strong>JRE</strong>：JRE(Java Runtime Environment)即 Java 运行环境，它是运行 Java 程序所必须得环境的集合，包含 Java 虚拟机和 Java 程序的一些核心类库。</p><hr><p><strong>JVM</strong>：JVM(Java Virtual Machine)即 Java 虚拟机，是整个 Java 实现跨平台的最核心部分，能够运行以 Java 语言写的软件程序。</p></blockquote><h3 id="重载-overload-与重写-override-的区别" tabindex="-1"><a class="header-anchor" href="#重载-overload-与重写-override-的区别" aria-hidden="true">#</a> 重载(overload)与重写(override)的区别</h3><blockquote><p><strong>重载</strong>：同一个类中，方法名相同，方法的参数的<u class="under-wave">类型、顺序、数量</u>不同的一组方法<br><strong>重写</strong>：子类对父类中的同名方法进行覆盖</p></blockquote><h3 id="java-中-与equals的区别-必会" tabindex="-1"><a class="header-anchor" href="#java-中-与equals的区别-必会" aria-hidden="true">#</a> Java 中<code>==</code>与<code>equals</code>的区别(必会)</h3><blockquote><p><code>==</code>：<br>   基本类型：比较的就是值是否相同<br>   引用类型：比较的就是地址是否相同</p><p><code>equals</code>：<br>   此方法是 Object 类中定义方法，只能实现两个引用类型的变量进行比较，默认比较的是两个对象是否相同(即地址值)，在 String 类，对此方法进行了重写，实现的是比较两个字符串的值是否相同；</p></blockquote><h3 id="string、stringbuffer-与-stringbuilder-的区别-必会" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer-与-stringbuilder-的区别-必会" aria-hidden="true">#</a> String、StringBuffer 与 StringBuilder 的区别(必会)</h3><blockquote><p><strong>String</strong>：字符串常量<br><strong>StringBuffer</strong>：字符串变量(线程安全)<br><strong>StringBuilder</strong>：字符串变量(非线程安全)</p></blockquote><p>  String 构建一个不可变的字符序列，StringBuffer 和 StringBuilder 都是构建一个可变的字符序列。在对字符串进行追加操作时 StringBuffer 比 String 效率高。</p><p>  此外 StringBuffer 是线程安全的，而 StringBuilder 是线程非安全的，在对字符串进行修改操作时，StringBuilder 效率优于 StringBuffer。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  String 中的 String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，String 对象是不可变的，也就可以理解为常量，线程安全。</p><p>  AbstractStringBuilder 是 StringBuffer 与 StringBuilder 的公共父类，定义了一些字符串的基本操作，如：expandCapacity、append、insert、indexOf 等公共方法。</p><p>  StringBuffer 对方法 jailed 同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>  StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></div><p><strong>小结</strong>：<br> ① 如果要操作少量的数据用 String；<br> ② 多线程操作字符串缓冲区下操作大量数据用 StringBuffer；<br> ③ 单线程操作字符串缓冲区孝操作大量数据用 StringBuilder。</p><h3 id="说一下字符串操作常见的-api-10-个左右即可" tabindex="-1"><a class="header-anchor" href="#说一下字符串操作常见的-api-10-个左右即可" aria-hidden="true">#</a> 说一下字符串操作常见的 API ？(10 个左右即可)</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code>、<code>concat(String str)</code></td><td>字符串连接</td></tr><tr><td><code>==</code>、<code>equals(Object anObject)</code>、<code>equalsIgnoreCase(String another String)</code></td><td>字符串比对</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定位置字符值</td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取指定字符串第一次出现的下标值</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>字符串替换</td></tr><tr><td><code>startsWith(String prefix)</code>、<code>endsWith(String prefix)</code></td><td>判断是否以指定字符串开始|结束</td></tr><tr><td><code>toLowerCase()</code>、<code>toUpperCase()</code></td><td>所有字符转换为小写|大写</td></tr><tr><td><code>substring(index)</code></td><td>字符串截取</td></tr><tr><td><code>trim()</code></td><td>去除左右空格</td></tr><tr><td><code>String.valueOf(int i)</code></td><td>将整型转为字符串</td></tr><tr><td><code>contains(String str)</code></td><td>判断字符串是否包含某子字符串</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>split(String regex)</code></td><td>指定分隔符返回分割后的字符数组</td></tr><tr><td><code>toCharArray()</code></td><td>将字符串转为字符数组</td></tr><tr><td><code>getBytes()</code>、<code>getBytes(String charsetName)</code></td><td>返回字符串的 byte 类型数组(可指定字符集)</td></tr></tbody></table><h3 id="自增-如下代码的运行结果" tabindex="-1"><a class="header-anchor" href="#自增-如下代码的运行结果" aria-hidden="true">#</a> 自增(如下代码的运行结果)</h3>`,27),b=a("div",{class:"language-java line-numbers-mode","data-ext":"java"},[a("pre",{java:"",class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Test"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
        i `),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" j "),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" k "),a("span",{class:"token operator"},"="),n(" i "),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token operator"},"++"),n("i "),a("span",{class:"token operator"},"*"),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"i="'),n(),a("span",{class:"token operator"},"+"),n(" i"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"j="'),n(),a("span",{class:"token operator"},"+"),n(" j"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"k="'),n(),a("span",{class:"token operator"},"+"),n(" k"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])]),a("div",{class:"highlight-lines"},[a("br"),a("br"),a("br"),a("div",{class:"highlight-line"}," "),a("br"),a("br"),a("br"),a("br"),a("br"),a("br"),a("br")]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),x=a("div",{class:"language-text line-numbers-mode","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`i=4
j=1
k=11
`)]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),m=o('<div class="hint-container tip"><p class="hint-container-title">解析</p><p><strong>行 4</strong>：先将 1 压入操作数栈，然后局部变量表中的 i 自增变为 2，最后操作树栈中的 1 赋值给 i，2 被覆盖；</p><figure><img src="'+h+`" alt="处理过程.png" tabindex="0" loading="lazy"><figcaption>处理过程.png</figcaption></figure><p><strong>总结</strong>：<br> ① 先赋值再自增、自减(i = i++ 、i = i--)，先自增、自减再赋值(i = ++i 、i = --i)<br> ② = 右边的从左到右加载值依次压入操作数栈<br> ③ 实际先算哪个，看运算符优先级<br> ④ 自增、自减操作都是<mark>直接修改变量的值，不经过操作数栈</mark><br> ⑤ 最后的赋值之前，临时结果也是存储在操作数栈中</p></div><h3 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h3><div class="hint-container tip"><p class="hint-container-title">什么是 Singleton ?</p><p><strong>Singleton</strong> : 在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。单例设计模式，即某个类在整个系统中<mark>只能有一个实例对象</mark>可被获取和使用的代码模式。例如：代表 JVM 运行环境的 Runtime 类</p><p><strong>要点</strong>：</p><p>① 某个类只能有一个实例【构造器私有化】<br> ② 它必须自行创建这个实例【含有一个该类的静态变量来保存这个唯一的实例)】<br> ③ 它必须自行向整个系统提供这个实例【对外提供获取该实例对象的方式：(1)直接暴露 (2)用静态变量的 get 方法获取】</p></div><h4 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 直接实例化(简洁直观)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 枚举式(最简洁)</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块(适合复杂实例化)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在类初始化时直接创建实例对象，不管是否需要这个对象，不存在线程安全问题</p></blockquote><h4 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 静态内部类形式(适用于多线程)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Inner</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟创建对象<br> 线程不安全(适用于单线程)、线程安全(适用于多线程)</p></blockquote><h3 id="接口和抽象类的区别是什么-必会" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的区别是什么-必会" aria-hidden="true">#</a> 接口和抽象类的区别是什么?(必会)</h3><p>① <strong>实现</strong>：抽象类的子类使用<code>extends</code>来继承；接口必须使用<code>implements</code>来实现接口。<br> ② <strong>构造函数</strong>：抽象类可以有构造函数；接口不能有。<br> ③ <strong>main 方法</strong>：抽象类可以有 main 方法，并且我们可以允许它；接口不能有 main 方法。<br> ④ <strong>实现数量</strong>：类可以实现很多个接口；但是只能继承一个抽象类。<br> ⑤ <strong>访问修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h3 id="反射-了解" tabindex="-1"><a class="header-anchor" href="#反射-了解" aria-hidden="true">#</a> 反射(了解)</h3><p>  在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p><strong>获取 Class 对象的 3 种方法</strong>：<br> ① 调用某个对象的 getClass()方法</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clzz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>② 调用某个类的 class 属性来获取该类对应的 Class 对象</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>③ 使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 最常用</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类的全路径&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="jdk-1-8-新特性" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-新特性" aria-hidden="true">#</a> JDK 1.8 新特性</h3><p>① <strong>Lambda 表达式</strong></p><p>② <strong>方法引用</strong></p><p>③ <strong>函数式接口</strong></p><p>④ <strong>接口允许定义默认方法和静态方法</strong></p><p>⑤ <strong>Stream API</strong></p><p>⑥ <strong>日期/时间类改进</strong></p><p>⑦ <strong>Optional 类</strong></p><p>⑧ <strong>Java 8 Base64 实现</strong></p><h3 id="final-关键字作用" tabindex="-1"><a class="header-anchor" href="#final-关键字作用" aria-hidden="true">#</a> final 关键字作用?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① final修饰变量，表示该变量为常量，只能赋值一次;
② final修饰方法，表示该方法不能被重写;
③ final修饰类，表示该类不能被继承。
</code></pre></div><h3 id="如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" tabindex="-1"><a class="header-anchor" href="#如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" aria-hidden="true">#</a> 如何将一个整型转为字符串，反之，将一个字符串类型的数据转为整型</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>整型→字符串:String.valueOf(int parameter)
字符串→整型:Interger.parseInt(String parameter)
</code></pre></div><h3 id="说一下-break-与-continue-作用" tabindex="-1"><a class="header-anchor" href="#说一下-break-与-continue-作用" aria-hidden="true">#</a> 说一下 break 与 continue 作用</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>break</code>语句有两个作用：一是跳出当前循环体，执行循环之外的语句；二是跳出 switch 语句，而 continue 语句表示中止本次循环，继续执行下一次循环。</p></div><h3 id="说一下值传递与引用传递" tabindex="-1"><a class="header-anchor" href="#说一下值传递与引用传递" aria-hidden="true">#</a> 说一下值传递与引用传递</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  Java 数据类型包括基本数据类型和引用数据类型，其中基本数据类型使用值传递，实质是传递数值的副本，当调用使用值传递交换数据时，原数据不会发生改变；而引用数据类型使用引用传递，传递的实质是引用的地址，当调用引用传递交换数据时，因为地址指向变了，所以原数据发生改变。</p></div><h3 id="如何获取数组元素的数量" tabindex="-1"><a class="header-anchor" href="#如何获取数组元素的数量" aria-hidden="true">#</a> 如何获取数组元素的数量</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>数组-属性:length
字符串-方法:length()
</code></pre></div><h3 id="写出数组排序-冒泡法排序" tabindex="-1"><a class="header-anchor" href="#写出数组排序-冒泡法排序" aria-hidden="true">#</a> 写出数组排序(冒泡法排序)</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  冒泡排序就是依次比较相邻的两个数，以升序为例，就是将小数放前面，大数放后面；假设需要排序的序列个数为 n，则需要经过 n-1 轮，最终完成排序。在第一轮中，比较的次数是 n-1 次，之后每轮次数减一。</p></div><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment">// 临时变量</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 需要比较n-1轮</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 每轮需要比较的次数逐轮减少1次</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 相邻元素比较，符合条件交换</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="string-能被继承吗" tabindex="-1"><a class="header-anchor" href="#string-能被继承吗" aria-hidden="true">#</a> String 能被继承吗?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>String被final关键字修饰属于最终类，不能被继承。
</code></pre></div><h3 id="说一下你知道的-java-中常见的包" tabindex="-1"><a class="header-anchor" href="#说一下你知道的-java-中常见的包" aria-hidden="true">#</a> 说一下你知道的 java 中常见的包</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang:系统基础类库。比如:String、Math、System、Thread等等;
java.util:Java工具类，包含对集合的操作、日期时间设置等等各种使用工具类;
java.io:io流文件的读写操作;
java.net:为实现网络应用程序而提供的类;
java.awt/javax.swing:用于窗体开发的类;
java.sql:数据库操作类库。
</code></pre></div><h3 id="说一下-java-中类的四种封装" tabindex="-1"><a class="header-anchor" href="#说一下-java-中类的四种封装" aria-hidden="true">#</a> 说一下 java 中类的四种封装?</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>封装就是将抽象得到的属性和行为结合起来，形成一个有机的整体，也就是类。类里面的一些属性和方法(尤其是属性)需要隐藏起来，不希望直接对外公开，但同时提供外部访问的方法来访问这些需要隐藏的属性和方法。</p></div><table><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:center;">类内部</th><th style="text-align:center;">同一个包中</th><th style="text-align:center;">子类</th><th style="text-align:center;">任何地方</th></tr></thead><tbody><tr><td style="text-align:left;">private</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">default</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">public</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td></tr></tbody></table><h3 id="面向对象的三大特点是什么" tabindex="-1"><a class="header-anchor" href="#面向对象的三大特点是什么" aria-hidden="true">#</a> 面向对象的三大特点是什么?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>封装、继承、多态
</code></pre></div><h3 id="java-中如何实现继承-java-中能实现多重继承吗" tabindex="-1"><a class="header-anchor" href="#java-中如何实现继承-java-中能实现多重继承吗" aria-hidden="true">#</a> java 中如何实现继承?java 中能实现多重继承吗?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code> 继承概念:继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
 如何实现继承:使用extends关键字;一个子类只有一个直接父类。
</code></pre></div><h3 id="说一下类与对象的区别" tabindex="-1"><a class="header-anchor" href="#说一下类与对象的区别" aria-hidden="true">#</a> 说一下类与对象的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类是具有相同属性和行为的一个群体，而对象则是这个群体中的一个个体;我们在使用时，先设计类，在创建对象，也就是说，类是创建对象的模板。</p></div><h3 id="类与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#类与抽象类的区别" aria-hidden="true">#</a> 类与抽象类的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类和抽象类的本质是一样的，都是类;但是抽象类一般是以基类的身份出现的，服务于子类的，可以包含抽象方法，普通类不可以，换句话说，抽象类可以不含抽象方法，但含抽象方法的类一定是抽象类。抽象类不可以被实例化，而普通类则可以。</p></div><h3 id="final-、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final-、finally、finalize-的区别" aria-hidden="true">#</a> final 、finally、finalize 的区别?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>final三个作用:修饰变量、方法、类;
finally是java的一种异常处理机制，通常放在try、catch后面，正常情况下此结构体使代码[总会执行]，(虚拟机终止，语句块终止、打断其实不会执行)而不管异常是否发生。
finalize是java.lang.Object类中的一个方法，用于垃圾回收机制中资源的释放。
</code></pre></div><h3 id="什么是多态" tabindex="-1"><a class="header-anchor" href="#什么是多态" aria-hidden="true">#</a> 什么是多态?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>解释一:多态是父类行为的多面性。---子类重写造成的
解释二:多态是同一个行为具有多个不同表现形式或形态的能力
</code></pre></div><h3 id="java-中的多态三个条件" tabindex="-1"><a class="header-anchor" href="#java-中的多态三个条件" aria-hidden="true">#</a> java 中的多态三个条件?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① 要有继承;
② 要有重写;
③ 必须通过父类的对象调用。
</code></pre></div><h3 id="请解释一下-this-与-super-关键字" tabindex="-1"><a class="header-anchor" href="#请解释一下-this-与-super-关键字" aria-hidden="true">#</a> 请解释一下 this 与 super 关键字?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>this: ① 本类的对象；② 本类的构造函数。
super: ① 父类的对象；② 父类的构造函数。
</code></pre></div><h3 id="什么是接口" tabindex="-1"><a class="header-anchor" href="#什么是接口" aria-hidden="true">#</a> 什么是接口?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>接口是一系列方法的声明，是一些抽象方法的集合，是对类的行为定制的一套标准、一套规范、一套约束;
</code></pre></div><h3 id="接口中能定义的主要成员有哪些" tabindex="-1"><a class="header-anchor" href="#接口中能定义的主要成员有哪些" aria-hidden="true">#</a> 接口中能定义的主要成员有哪些?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>属性和方法;
</code></pre></div><h3 id="抽象类与接口的区别" tabindex="-1"><a class="header-anchor" href="#抽象类与接口的区别" aria-hidden="true">#</a> 抽象类与接口的区别?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>相同点:不能实例化;
不同点:
    ①定义抽象类用abstract关键字，定义接口用interface;
    ②抽象类的本质为类，接口的本质是给类的行为定制规范;
    ③一个类只能有一个父类，但可以实现多个接口;
    ④抽象类中除了有抽象方法外，还可以有普通类中有的所有类成员，但接口中只能有抽象方法与属性(jdk8做了扩展，可以有默认方法与静态方法)
    ⑤访问权限：抽象类(protected -- jdk1.8之前，default/public -- jdk1.8)
    接口(public -- jdk1.8之前，public/default -- jdk1.8)
</code></pre></div><h3 id="解释一下向上转型与向下转型" tabindex="-1"><a class="header-anchor" href="#解释一下向上转型与向下转型" aria-hidden="true">#</a> 解释一下向上转型与向下转型</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>向上转型: 通过子类对象 (小范围) 实例化父类对象 (大范围) ， 这种属于自动转换
向下转型: 通过父类对象 (大范围) 实例化子类对象 (小范围) ， 这种属于强制转换
</code></pre></div><h3 id="说一下-java-中的异常分类" tabindex="-1"><a class="header-anchor" href="#说一下-java-中的异常分类" aria-hidden="true">#</a> 说一下 JAVA 中的异常分类</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>异常包括:Error和Exception
Exception:RuntimeException(运行时异常)和CheckedException(检查时异常)
</code></pre></div><figure><img src="`+k+`" alt="异常分类.jpg" width="550" tabindex="0" loading="lazy"><figcaption>异常分类.jpg</figcaption></figure><h3 id="java-中异常父类-根父类-是哪一个" tabindex="-1"><a class="header-anchor" href="#java-中异常父类-根父类-是哪一个" aria-hidden="true">#</a> JAVA 中异常父类(根父类)是哪一个?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang.Throwable
</code></pre></div><h3 id="说出常见的几个运行时异常-5-个以上" tabindex="-1"><a class="header-anchor" href="#说出常见的几个运行时异常-5-个以上" aria-hidden="true">#</a> 说出常见的几个运行时异常?(5 个以上)</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>运行时异常(RuntimeException):
    NullPointerException(空指针异常)
    ClassCastException(类型转换异常)
    IndexOutOfBoundsException(角标越界异常)
    ArithmeticException(数学运算异常)  /əˈrɪθmətɪk/
    IllegalArgumentException(不合法参数异常)
    SystemException(系统异常)
    NumberFormatException(数字格式化异常)

检查时异常(CheckedExcption):
 IOException(IO异常)
 ClassNotFoundException(类没找到异常)
 FileNotFoundException(文件找不到异常)
 SQLException(SQL异常)
</code></pre></div><h3 id="throw-与-throws-区别" tabindex="-1"><a class="header-anchor" href="#throw-与-throws-区别" aria-hidden="true">#</a> throw 与 throws 区别?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>throw关键字表示手动抛异常
throws关键字表示声明异常(在定义方法，同时给方法声明一个异常)
</code></pre></div><h3 id="异常处理的基本结构" tabindex="-1"><a class="header-anchor" href="#异常处理的基本结构" aria-hidden="true">#</a> 异常处理的基本结构?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① try / catch
② try / catch / finally
③ try / finally
</code></pre></div><h3 id="栈与队列的区别" tabindex="-1"><a class="header-anchor" href="#栈与队列的区别" aria-hidden="true">#</a> 栈与队列的区别?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>队列:先进先出(FIFO)，它只允许在前端进行删除操作，在后端进行插入操作。
栈:先进后出，它只能在一端进行插入和删除操作。
</code></pre></div><h3 id="顺序存储结构与链式存储结构的优缺点" tabindex="-1"><a class="header-anchor" href="#顺序存储结构与链式存储结构的优缺点" aria-hidden="true">#</a> 顺序存储结构与链式存储结构的优缺点</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>顺序存储结构:
 优:一是节省存储空间;二是访问速度快;
 缺:进行插入、删除元素时效率低。

链式存储结构:
 优:进行插入、删除元素时效率高;
 缺:一是对空间的占用比较大;二是访问速度慢。
</code></pre></div><h3 id="数据查找-遍历、二分查找-说一下二分查找的条件" tabindex="-1"><a class="header-anchor" href="#数据查找-遍历、二分查找-说一下二分查找的条件" aria-hidden="true">#</a> 数据查找:遍历、二分查找，说一下二分查找的条件</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>必须是有序数组
</code></pre></div><h2 id="集合-⭐️" tabindex="-1"><a class="header-anchor" href="#集合-⭐️" aria-hidden="true">#</a> 集合 ⭐️</h2><h2 id="多线程-⭐️" tabindex="-1"><a class="header-anchor" href="#多线程-⭐️" aria-hidden="true">#</a> 多线程 ⭐️</h2><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2>`,93);function f(y,j){const c=p("CodeTabs");return r(),d("div",null,[v,l(c,{id:"445",data:[{id:"代码"},{id:"输出结果"}]},{title0:t(({value:s,isActive:e})=>[n("代码")]),title1:t(({value:s,isActive:e})=>[n("输出结果")]),tab0:t(({value:s,isActive:e})=>[b]),tab1:t(({value:s,isActive:e})=>[x]),_:1}),m])}const w=i(g,[["render",f],["__file","java-foundation.html.vue"]]);export{w as default};
