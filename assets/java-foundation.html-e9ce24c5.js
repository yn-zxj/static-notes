import{_ as l,j as i,o as r,c as d,g as p,w as s,f as a,a as o,i as n}from"./app-466994ff.js";const u="/assets/base-type-fa548d7e.jpg",k="/assets/t-01-a2fd61f9.png",h="/assets/throwable-59a159de.jpg",g="/assets/thread-c419ee70.jpg",v={},b=o(`<h2 id="java-基础知识" tabindex="-1"><a class="header-anchor" href="#java-基础知识" aria-hidden="true">#</a> Java 基础知识</h2><h3 id="jdk、jre、jvm-的区别-必会" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-的区别-必会" aria-hidden="true">#</a> JDK、JRE、JVM 的区别(必会)</h3><blockquote><p><strong>JDK</strong>：JDK(Java Development Kit)即 Java 开发工具包，是整个 Java 的核心，其包括了 Java 运行环境(JRE)、Java 工具和 Java 基础类库。</p><hr><p><strong>JRE</strong>：JRE(Java Runtime Environment)即 Java 运行环境，它是运行 Java 程序所必须得环境的集合，包含 Java 虚拟机和 Java 程序的一些核心类库。</p><hr><p><strong>JVM</strong>：JVM(Java Virtual Machine)即 Java 虚拟机，是整个 Java 实现跨平台的最核心部分，能够运行以 Java 语言写的软件程序。</p></blockquote><h3 id="说一下-java-的三种注释" tabindex="-1"><a class="header-anchor" href="#说一下-java-的三种注释" aria-hidden="true">#</a> 说一下 JAVA 的三种注释</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>// 单行注释
/*...*/ 多行注释
/...*/ 文档注释
</code></pre></div><h3 id="java-的数据类型" tabindex="-1"><a class="header-anchor" href="#java-的数据类型" aria-hidden="true">#</a> Java 的数据类型</h3><div class="hint-container tip"><p class="hint-container-title">数据类型</p><p>  Java 数据类型包括两大类：基本数据类型和引用数据类型；其中八个基本数据类型包括整型(byte、short、int、long)、浮点型(float、double)、字符型(char)、布尔型(boolean)；除此之外的都为引用数据类型，比如类、接口、数组。</p></div><figure><img src="`+u+'" alt="基本数据类型.jpg" width="600" tabindex="0" loading="lazy"><figcaption>基本数据类型.jpg</figcaption></figure><table><thead><tr><th>数据类型</th><th>字节数</th><th>位数</th><th>默认值</th><th>包装类型</th><th>使用说明[取值范围]</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>0</td><td>Byte</td><td>-128~127</td></tr><tr><td>short</td><td>2</td><td>16</td><td>0</td><td>Short</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int</td><td>4</td><td>32</td><td>0</td><td>Integer</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>long</td><td>8</td><td>64</td><td>0L 或 0l</td><td>Long</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>float</td><td>4</td><td>32</td><td>0.0F 或 0.0f</td><td>Float</td><td>1.4E-45~3.4E38</td></tr><tr><td>double</td><td>8</td><td>64</td><td>0.0d</td><td>Double</td><td>4.9E-324~1.8E308</td></tr><tr><td>char</td><td>2</td><td>16</td><td>空</td><td>Character</td><td>使用 Unicode 编码(2 个字节)，可存汉字</td></tr><tr><td>boolean</td><td>-</td><td>-</td><td>false</td><td>Boolean</td><td>只有 true 和 false 两个取值</td></tr></tbody></table><h3 id="整型的默认数据类型是什么-浮点型的数据类型是什么" tabindex="-1"><a class="header-anchor" href="#整型的默认数据类型是什么-浮点型的数据类型是什么" aria-hidden="true">#</a> 整型的默认数据类型是什么，浮点型的数据类型是什么？</h3><blockquote><p>整型默认数据类型：int<br> 浮点型默认数据类型：double</p></blockquote><h3 id="int-与-integer-关系" tabindex="-1"><a class="header-anchor" href="#int-与-integer-关系" aria-hidden="true">#</a> int 与 Integer 关系？</h3><blockquote><p>Integer 是 int 的包装类，int 则是 Java 的一种基本数据类型</p></blockquote><h3 id="什么是包装类" tabindex="-1"><a class="header-anchor" href="#什么是包装类" aria-hidden="true">#</a> 什么是包装类？</h3><blockquote><p>  Java 是一个面向对象的编程语言，但是 Java 中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于 java.lang 包。</p></blockquote><h3 id="重载-overload-与重写-override-的区别" tabindex="-1"><a class="header-anchor" href="#重载-overload-与重写-override-的区别" aria-hidden="true">#</a> 重载(overload)与重写(override)的区别</h3><blockquote><p><strong>重载</strong>：同一个类中，方法名相同，方法的参数的<u class="under-wave">类型、顺序、数量</u>不同的一组方法<br><strong>重写</strong>：子类对父类中的同名方法进行覆盖</p></blockquote><h3 id="java-中-与equals的区别-必会" tabindex="-1"><a class="header-anchor" href="#java-中-与equals的区别-必会" aria-hidden="true">#</a> Java 中<code>==</code>与<code>equals</code>的区别(必会)</h3><blockquote><p><code>==</code>：<br>   基本类型：比较的就是值是否相同<br>   引用类型：比较的就是地址是否相同</p><p><code>equals</code>：<br>   此方法是 Object 类中定义方法，只能实现两个引用类型的变量进行比较，默认比较的是两个对象是否相同，在 String 类，对此方法进行了重写，实现的是比较两个字符串的值是否相同；</p></blockquote><h3 id="string、stringbuffer-与-stringbuilder-的区别-必会" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer-与-stringbuilder-的区别-必会" aria-hidden="true">#</a> String、StringBuffer 与 StringBuilder 的区别(必会)</h3><blockquote><p><strong>String</strong>：字符串常量<br><strong>StringBuffer</strong>：字符串变量(线程安全)<br><strong>StringBuilder</strong>：字符串变量(非线程安全)</p></blockquote><p>  String 构建一个不可变的字符序列，StringBuffer 和 StringBuilder 都是构建一个可变的字符序列。在对字符串进行追加操作时 StringBuffer 比 String 效率高。</p><p>  此外 StringBuffer 是线程安全的，而 StringBuilder 是线程非安全的，在对字符串进行修改操作时，StringBuilder 效率优于 StringBuffer。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  String 中的 String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，String 对象是不可变的，也就可以理解为常量，线程安全。</p><p>  AbstractStringBuilder 是 StringBuffer 与 StringBuilder 的公共父类，定义了一些字符串的基本操作，如：expandCapacity、append、insert、indexOf 等公共方法。</p><p>  StringBuffer 对方法 jailed 同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>  StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></div><p><strong>小结</strong>：<br> ① 如果要操作少量的数据用 String；<br> ② 多线程操作字符串缓冲区下操作大量数据用 StringBuffer；<br> ③ 单线程操作字符串缓冲区孝操作大量数据用 StringBuilder。</p><h3 id="说一下字符串操作常见的-api-10-个左右即可" tabindex="-1"><a class="header-anchor" href="#说一下字符串操作常见的-api-10-个左右即可" aria-hidden="true">#</a> 说一下字符串操作常见的 API ？(10 个左右即可)</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code>、<code>concat(String str)</code></td><td>字符串连接</td></tr><tr><td><code>==</code>、<code>equals(Object anObject)</code>、<code>equalsIgnoreCase(String another String)</code></td><td>字符串比对</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定位置字符值</td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取指定字符串第一次出现的下标值</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>字符串替换</td></tr><tr><td><code>startsWith(String prefix)</code>、<code>endsWith(String prefix)</code></td><td>判断是否以指定字符串开始|结束</td></tr><tr><td><code>toLowerCase()</code>、<code>toUpperCase()</code></td><td>所有字符转换为小写|大写</td></tr><tr><td><code>substring(index)</code></td><td>字符串截取</td></tr><tr><td><code>trim()</code></td><td>去除左右空格</td></tr><tr><td><code>String.valueOf(int i)</code></td><td>将整型转为字符串</td></tr><tr><td><code>contains(String str)</code></td><td>判断字符串是否包含某子字符串</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>split(String regex)</code></td><td>指定分隔符返回分割后的字符数组</td></tr><tr><td><code>toCharArray()</code></td><td>将字符串转为字符数组</td></tr><tr><td><code>getBytes()</code>、<code>getBytes(String charsetName)</code></td><td>返回字符串的 byte 类型数组(可指定字符集)</td></tr></tbody></table><h3 id="自增-如下代码的运行结果" tabindex="-1"><a class="header-anchor" href="#自增-如下代码的运行结果" aria-hidden="true">#</a> 自增(如下代码的运行结果)</h3>',28),m=a("div",{class:"language-java line-numbers-mode","data-ext":"java"},[a("pre",{java:"",class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Test"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" i "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token number"},"1"),a("span",{class:"token punctuation"},";"),n(`
        i `),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" j "),a("span",{class:"token operator"},"="),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"int"),n(" k "),a("span",{class:"token operator"},"="),n(" i "),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token operator"},"++"),n("i "),a("span",{class:"token operator"},"*"),n(" i"),a("span",{class:"token operator"},"++"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"i="'),n(),a("span",{class:"token operator"},"+"),n(" i"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"j="'),n(),a("span",{class:"token operator"},"+"),n(" j"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"k="'),n(),a("span",{class:"token operator"},"+"),n(" k"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])]),a("div",{class:"highlight-lines"},[a("br"),a("br"),a("br"),a("div",{class:"highlight-line"}," "),a("br"),a("br"),a("br"),a("br"),a("br"),a("br"),a("br")]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),x=a("div",{class:"language-text line-numbers-mode","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`i=4
j=1
k=11
`)]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),f=o('<div class="hint-container tip"><p class="hint-container-title">解析</p><p><strong>行 4</strong>：先将 1 压入操作数栈，然后局部变量表中的 i 自增变为 2，最后操作树栈中的 1 赋值给 i，2 被覆盖；</p><figure><img src="'+k+`" alt="处理过程.png" tabindex="0" loading="lazy"><figcaption>处理过程.png</figcaption></figure><p><strong>总结</strong>：<br> ① 先赋值再自增、自减(i = i++ 、i = i--)，先自增、自减再赋值(i = ++i 、i = --i)<br> ② = 右边的从左到右加载值依次压入操作数栈<br> ③ 实际先算哪个，看运算符优先级<br> ④ 自增、自减操作都是<mark>直接修改变量的值，不经过操作数栈</mark><br> ⑤ 最后的赋值之前，临时结果也是存储在操作数栈中</p></div><h3 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h3><div class="hint-container tip"><p class="hint-container-title">什么是 Singleton ？</p><p><strong>Singleton</strong> : 在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。单例设计模式，即某个类在整个系统中<mark>只能有一个实例对象</mark>可被获取和使用的代码模式。例如：代表 JVM 运行环境的 Runtime 类</p><p><strong>要点</strong>：</p><p>① 某个类只能有一个实例【构造器私有化】<br> ② 它必须自行创建这个实例【含有一个该类的静态变量来保存这个唯一的实例)】<br> ③ 它必须自行向整个系统提供这个实例【对外提供获取该实例对象的方式：(1)直接暴露 (2)用静态变量的 get 方法获取】</p></div><h4 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 直接实例化(简洁直观)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 枚举式(最简洁)</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块(适合复杂实例化)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在类初始化时直接创建实例对象，不管是否需要这个对象，不存在线程安全问题</p></blockquote><h4 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 静态内部类形式(适用于多线程)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Inner</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟创建对象<br> 线程不安全(适用于单线程)、线程安全(适用于多线程)</p></blockquote><h3 id="反射-了解" tabindex="-1"><a class="header-anchor" href="#反射-了解" aria-hidden="true">#</a> 反射(了解)</h3><p>  在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>  反射的好处是可以提升程序的灵活性和扩展性，比较容易在运行期间干很多事情。但是带来的问题更多，主要有：<br>    ① 代码可读性及可维护性<br>    ② 反射代码执行的性能低<br>    ③ 反射破坏了封装性<br>   所以，在业务代码中应该尽量避免使用反射，但是也要读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p><p><strong>获取 Class 对象的 3 种方法</strong>：<br> ① 调用某个对象的 getClass()方法</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clzz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>② 调用某个类的 class 属性来获取该类对应的 Class 对象</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre></div><p>③ 使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 最常用</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类的全路径&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><hr><p><strong>扩展</strong>：为什么反射慢？<br> ① 由于反射涉及动态解析类型，因此不能执行某些 Java 虚拟机优化，如 JIT 优化<br> ② 在使用反射时，参数需要包装成 Object[]类型，但是真正方法执行的时候，有需要再拆包成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致 GC，GC 会导致应变变慢<br> ③ 反射调用方法时会从方法数组中遍历查找，并且会检查可见性，这些动作都是耗时的<br> ④ 不仅方法的可见性要做检查，参数也需要做很多额外的检查</p><h3 id="通过反射如何创建对象" tabindex="-1"><a class="header-anchor" href="#通过反射如何创建对象" aria-hidden="true">#</a> 通过反射如何创建对象？</h3><blockquote><p>① 通过 Class 类的 newInstance()方法<br> ② 通过 Constructor 的 newInstance(Object[] args)方法</p></blockquote><p><strong>代码示例</strong>：</p>`,23),y={class:"hint-container details"},j=a("summary",null,"通过反射如何创建对象(代码示例)",-1),w=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"package"),n(),a("span",{class:"token namespace"},[n("cn"),a("span",{class:"token punctuation"},"."),n("bt66")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"Constructor")]),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"Field")]),a("span",{class:"token punctuation"},";"),n(`
`),a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token import"},[a("span",{class:"token namespace"},[n("java"),a("span",{class:"token punctuation"},"."),n("lang"),a("span",{class:"token punctuation"},"."),n("reflect"),a("span",{class:"token punctuation"},".")]),a("span",{class:"token class-name"},"InvocationTargetException")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token doc-comment comment"},[n(`/**
 * `),a("span",{class:"token keyword"},"@author"),n(` zhangxiaojun
 */`)]),n(`
`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"App"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"static"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"main"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),a("span",{class:"token punctuation"},"["),a("span",{class:"token punctuation"},"]"),n(" args"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token keyword"},"throws"),n(),a("span",{class:"token class-name"},"ClassNotFoundException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"NoSuchMethodException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"InstantiationException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"IllegalAccessException"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token class-name"},"InvocationTargetException"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token comment"},"// 调用某个对象的 getClass() 方法"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" person "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_1 "),a("span",{class:"token operator"},"="),n(" person"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"getClass"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_1"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 调用某个类的 class 属性来获取该类对应的 Class 对象"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_2 "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"."),a("span",{class:"token keyword"},"class"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_2 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_2"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 使用 Class 类中的 forName() 静态方法"),n(`
        `),a("span",{class:"token class-name"},"Class"),n(" clazz_3 "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token class-name"},"Class"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"forName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"cn.bt66.Person"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_3 = "'),n(),a("span",{class:"token operator"},"+"),n(" clazz_3"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 比较"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 == clazz_2 : "'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token punctuation"},"("),n("clazz_1 "),a("span",{class:"token operator"},"=="),n(" clazz_2"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"clazz_1 == clazz_3 : "'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token punctuation"},"("),n("clazz_1 "),a("span",{class:"token operator"},"=="),n(" clazz_3"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 通过 Class 类的 newInstance()方法"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" p "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},")"),n(" clazz_1"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"newInstance"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        p`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"10"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        p`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Zhang"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"String"),n(" pString "),a("span",{class:"token operator"},"="),n(" p"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"pString = "'),n(),a("span",{class:"token operator"},"+"),n(" pString"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

        `),a("span",{class:"token comment"},"// 通过 Constructor 的 newInstance(Object[] args)方法"),n(`
        `),a("span",{class:"token class-name"},"Constructor"),n(" con "),a("span",{class:"token operator"},"="),n(" clazz_1"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"getConstructor"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"Person"),n(" o "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},")"),n(" con"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"newInstance"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        o`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token number"},"20"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        o`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Li"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"String"),n(" oString "),a("span",{class:"token operator"},"="),n(" o"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"oString = "'),n(),a("span",{class:"token operator"},"+"),n(" oString"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),S=a("div",{class:"language-java","data-ext":"java"},[a("pre",{class:"language-java"},[a("code",null,[a("span",{class:"token keyword"},"package"),n(),a("span",{class:"token namespace"},[n("cn"),a("span",{class:"token punctuation"},"."),n("bt66")]),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token doc-comment comment"},[n(`/**
 * `),a("span",{class:"token keyword"},"@author"),n(` zhangxiaojun
 */`)]),n(`
`),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"class"),n(),a("span",{class:"token class-name"},"Person"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},";"),n(`

    `),a("span",{class:"token doc-comment comment"},`/**
     * 无参构造函数
     * 注意：当没有有参构造函数时，会隐式声明
     */`),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"private"),n(),a("span",{class:"token class-name"},"Person"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age "),a("span",{class:"token operator"},"="),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"String"),n(),a("span",{class:"token function"},"getName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"setName"),a("span",{class:"token punctuation"},"("),a("span",{class:"token class-name"},"String"),n(" name"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"="),n(" name"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"int"),n(),a("span",{class:"token function"},"getAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"setAge"),a("span",{class:"token punctuation"},"("),a("span",{class:"token keyword"},"int"),n(" age"),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age "),a("span",{class:"token operator"},"="),n(" age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token keyword"},"void"),n(),a("span",{class:"token function"},"eat"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token class-name"},"System"),a("span",{class:"token punctuation"},"."),n("out"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"println"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"Eating！"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`

    `),a("span",{class:"token annotation punctuation"},"@Override"),n(`
    `),a("span",{class:"token keyword"},"public"),n(),a("span",{class:"token class-name"},"String"),n(),a("span",{class:"token function"},"toString"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),n(),a("span",{class:"token punctuation"},"{"),n(`
        `),a("span",{class:"token keyword"},"return"),n(),a("span",{class:"token string"},'"Name:"'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("name "),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token string"},'","'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token string"},'"Age:"'),n(),a("span",{class:"token operator"},"+"),n(),a("span",{class:"token keyword"},"this"),a("span",{class:"token punctuation"},"."),n("age"),a("span",{class:"token punctuation"},";"),n(`
    `),a("span",{class:"token punctuation"},"}"),n(`
`),a("span",{class:"token punctuation"},"}"),n(`
`)])])],-1),_=a("div",{class:"language-text","data-ext":"text"},[a("pre",{class:"language-text"},[a("code",null,`clazz_1 = class cn.bt66.Person
clazz_2 = class cn.bt66.Person
clazz_3 = class cn.bt66.Person
clazz_1 == clazz_2 : true
clazz_1 == clazz_3 : true
pString = Name:Zhang,Age:10
oString = Name:Li,Age:20
`)])],-1),z=o(`<hr><p><strong>反射更多介绍</strong>：</p><div class="project-panel-custom"><a class="project project0" href="/backend/java/java-reflect.html" style="width:50%;" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-structure"></span><div class="name">反射</div><div class="desc">Java-反射</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> structure
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 反射
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> Java<span class="token punctuation">-</span>反射
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/java/java<span class="token punctuation">-</span>reflect.html
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="面向对象的特征-了解" tabindex="-1"><a class="header-anchor" href="#面向对象的特征-了解" aria-hidden="true">#</a> 面向对象的特征(了解)</h3><p><strong>面向对象的特征</strong>：<u class="under-dot">封装、继承、多态、抽象</u></p><blockquote><p><strong>封装</strong>：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，但提供对外访问的接口。由于隐藏了实现细节，同时又可以对属性赋值进行校验，所以增加了安全性；另外封装的各种方法，可以任意调用，不需要关心实现细节，提高了代码复用性。</p><hr><p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p><hr><p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力（<mark>多态是父类行为的多面性。---子类重写造成的</mark>）</p><hr><p><strong>抽象</strong>：表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用此关键字修饰类时，此类就不能被实例化，这这里可以看出，抽象类(接口)就是为了继承而存在的。</p></blockquote><h3 id="final-关键字作用" tabindex="-1"><a class="header-anchor" href="#final-关键字作用" aria-hidden="true">#</a> final 关键字作用？</h3><blockquote><p>① final 修饰变量，表示该变量为常量，只能赋值一次;<br> ② final 修饰方法，表示该方法不能被重写;<br> ③ final 修饰类，表示该类不能被继承。</p></blockquote><h3 id="说一下-java-中类的四种封装" tabindex="-1"><a class="header-anchor" href="#说一下-java-中类的四种封装" aria-hidden="true">#</a> 说一下 java 中类的四种封装？</h3><table><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:center;">类内部</th><th style="text-align:center;">同一个包中</th><th style="text-align:center;">子类</th><th style="text-align:center;">任何地方</th></tr></thead><tbody><tr><td style="text-align:left;">private</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">default</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">public</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td></tr></tbody></table><h3 id="java-中的多态三个条件" tabindex="-1"><a class="header-anchor" href="#java-中的多态三个条件" aria-hidden="true">#</a> Java 中的多态三个条件？</h3><blockquote><p>① 要有继承；<br> ② 要有重写；<br> ③ 必须通过父类的对象调用。</p></blockquote><h3 id="java-中如何实现继承-java-中能实现多重继承吗" tabindex="-1"><a class="header-anchor" href="#java-中如何实现继承-java-中能实现多重继承吗" aria-hidden="true">#</a> java 中如何实现继承？java 中能实现多重继承吗？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code> 继承概念:继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
 如何实现继承:使用extends关键字;一个子类只有一个直接父类。
</code></pre></div><h3 id="string-能被继承吗" tabindex="-1"><a class="header-anchor" href="#string-能被继承吗" aria-hidden="true">#</a> String 能被继承吗？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>String被final关键字修饰属于最终类，不能被继承。
</code></pre></div><h3 id="解释一下向上转型与向下转型" tabindex="-1"><a class="header-anchor" href="#解释一下向上转型与向下转型" aria-hidden="true">#</a> 解释一下向上转型与向下转型</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>向上转型: 通过子类对象 (小范围) 实例化父类对象 (大范围) ， 这种属于自动转换
向下转型: 通过父类对象 (大范围) 实例化子类对象 (小范围) ， 这种属于强制转换
</code></pre></div><h3 id="请解释一下-this-与-super-关键字" tabindex="-1"><a class="header-anchor" href="#请解释一下-this-与-super-关键字" aria-hidden="true">#</a> 请解释一下 this 与 super 关键字？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>this: ① 本类的对象；② 本类的构造函数。
super: ① 父类的对象；② 父类的构造函数。
</code></pre></div><h3 id="说一下类与对象的区别" tabindex="-1"><a class="header-anchor" href="#说一下类与对象的区别" aria-hidden="true">#</a> 说一下类与对象的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类是具有相同属性和行为的一个群体，而对象则是这个群体中的一个个体;我们在使用时，先设计类，在创建对象，也就是说，类是创建对象的模板。</p></div><h3 id="类与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#类与抽象类的区别" aria-hidden="true">#</a> 类与抽象类的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类和抽象类的本质是一样的，都是类;但是抽象类一般是以基类的身份出现的，服务于子类的，可以包含抽象方法，普通类不可以，换句话说，抽象类可以不含抽象方法，但含抽象方法的类一定是抽象类。抽象类不可以被实例化，而普通类则可以。</p></div><h3 id="什么是接口" tabindex="-1"><a class="header-anchor" href="#什么是接口" aria-hidden="true">#</a> 什么是接口？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>接口是一系列方法的声明，是一些抽象方法的集合，是对类的行为定制的一套标准、一套规范、一套约束;
</code></pre></div><h3 id="接口中能定义的主要成员有哪些" tabindex="-1"><a class="header-anchor" href="#接口中能定义的主要成员有哪些" aria-hidden="true">#</a> 接口中能定义的主要成员有哪些？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>属性和方法;
</code></pre></div><h3 id="接口和抽象类的区别是什么-必会" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的区别是什么-必会" aria-hidden="true">#</a> 接口和抽象类的区别是什么？(必会)</h3><p>① <strong>实现</strong>：抽象类的子类使用<code>extends</code>来继承；接口必须使用<code>implements</code>来实现接口。<br> ② <strong>构造函数</strong>：抽象类可以有构造函数；接口不能有。<br> ③ <strong>main 方法</strong>：抽象类可以有 main 方法，并且我们可以允许它；接口不能有 main 方法。<br> ④ <strong>实现数量</strong>：类可以实现很多个接口；但是只能继承一个抽象类。<br> ⑤ <strong>访问修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h3 id="抽象类与接口的区别" tabindex="-1"><a class="header-anchor" href="#抽象类与接口的区别" aria-hidden="true">#</a> 抽象类与接口的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>相同点:不能实例化;
不同点:
    ①定义抽象类用abstract关键字，定义接口用interface;
    ②抽象类的本质为类，接口的本质是给类的行为定制规范;
    ③一个类只能有一个父类，但可以实现多个接口;
    ④抽象类中除了有抽象方法外，还可以有普通类中有的所有类成员，但接口中只能有抽象方法与属性(jdk8做了扩展，可以有默认方法与静态方法)
    ⑤访问权限：抽象类(protected -- jdk1.8之前，default/public -- jdk1.8)
    接口(public -- jdk1.8之前，public/default -- jdk1.8)
</code></pre></div><h3 id="如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" tabindex="-1"><a class="header-anchor" href="#如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" aria-hidden="true">#</a> 如何将一个整型转为字符串，反之，将一个字符串类型的数据转为整型</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>整型→字符串:String.valueOf(int parameter)
字符串→整型:Interger.parseInt(String parameter)
</code></pre></div><h3 id="说一下-break-与-continue-作用" tabindex="-1"><a class="header-anchor" href="#说一下-break-与-continue-作用" aria-hidden="true">#</a> 说一下 break 与 continue 作用</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>break</code>语句有两个作用：一是跳出当前循环体，执行循环之外的语句；二是跳出 switch 语句，而 continue 语句表示中止本次循环，继续执行下一次循环。</p></div><h3 id="说一下值传递与引用传递" tabindex="-1"><a class="header-anchor" href="#说一下值传递与引用传递" aria-hidden="true">#</a> 说一下值传递与引用传递</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  Java 数据类型包括基本数据类型和引用数据类型，其中基本数据类型使用值传递，实质是传递数值的副本，当调用使用值传递交换数据时，原数据不会发生改变；而引用数据类型使用引用传递，传递的实质是引用的地址，当调用引用传递交换数据时，因为地址指向变了，所以原数据发生改变。</p></div><h3 id="如何获取数组元素的数量" tabindex="-1"><a class="header-anchor" href="#如何获取数组元素的数量" aria-hidden="true">#</a> 如何获取数组元素的数量</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>数组-属性:length
字符串-方法:length()
</code></pre></div><h3 id="写出数组排序-冒泡法排序" tabindex="-1"><a class="header-anchor" href="#写出数组排序-冒泡法排序" aria-hidden="true">#</a> 写出数组排序(冒泡法排序)</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  冒泡排序就是依次比较相邻的两个数，以升序为例，就是将小数放前面，大数放后面；假设需要排序的序列个数为 n，则需要经过 n-1 轮，最终完成排序。在第一轮中，比较的次数是 n-1 次，之后每轮次数减一。</p></div><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment">// 临时变量</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 需要比较n-1轮</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 每轮需要比较的次数逐轮减少1次</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 相邻元素比较，符合条件交换</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="说一下你知道的-java-中常见的包" tabindex="-1"><a class="header-anchor" href="#说一下你知道的-java-中常见的包" aria-hidden="true">#</a> 说一下你知道的 java 中常见的包</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang:系统基础类库。比如:String、Math、System、Thread等等;
java.util:Java工具类，包含对集合的操作、日期时间设置等等各种使用工具类;
java.io:io流文件的读写操作;
java.net:为实现网络应用程序而提供的类;
java.awt/javax.swing:用于窗体开发的类;
java.sql:数据库操作类库。
</code></pre></div><h3 id="final-、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final-、finally、finalize-的区别" aria-hidden="true">#</a> final 、finally、finalize 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>final三个作用:修饰变量、方法、类;
finally是java的一种异常处理机制，通常放在try、catch后面，正常情况下此结构体使代码[总会执行]，(虚拟机终止，语句块终止、打断其实不会执行)而不管异常是否发生。
finalize是java.lang.Object类中的一个方法，用于垃圾回收机制中资源的释放。
</code></pre></div><h3 id="说一下-java-中的异常分类" tabindex="-1"><a class="header-anchor" href="#说一下-java-中的异常分类" aria-hidden="true">#</a> 说一下 JAVA 中的异常分类</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>异常包括:Error和Exception
Exception:RuntimeException(运行时异常)和CheckedException(检查时异常)
</code></pre></div><figure><img src="`+h+`" alt="异常分类.jpg" width="550" tabindex="0" loading="lazy"><figcaption>异常分类.jpg</figcaption></figure><h3 id="java-中异常父类-根父类-是哪一个" tabindex="-1"><a class="header-anchor" href="#java-中异常父类-根父类-是哪一个" aria-hidden="true">#</a> JAVA 中异常父类(根父类)是哪一个？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang.Throwable
</code></pre></div><h3 id="说出常见的几个运行时异常-5-个以上" tabindex="-1"><a class="header-anchor" href="#说出常见的几个运行时异常-5-个以上" aria-hidden="true">#</a> 说出常见的几个运行时异常？(5 个以上)</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>运行时异常(RuntimeException):
    NullPointerException(空指针异常)
    ClassCastException(类型转换异常)
    IndexOutOfBoundsException(角标越界异常)
    ArithmeticException(数学运算异常)  /əˈrɪθmətɪk/
    IllegalArgumentException(不合法参数异常)
    SystemException(系统异常)
    NumberFormatException(数字格式化异常)

检查时异常(CheckedExcption):
 IOException(IO异常)
 ClassNotFoundException(类没找到异常)
 FileNotFoundException(文件找不到异常)
 SQLException(SQL异常)
</code></pre></div><h3 id="throw-与-throws-区别" tabindex="-1"><a class="header-anchor" href="#throw-与-throws-区别" aria-hidden="true">#</a> throw 与 throws 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>throw关键字表示手动抛异常
throws关键字表示声明异常(在定义方法，同时给方法声明一个异常)
</code></pre></div><h3 id="异常处理的基本结构" tabindex="-1"><a class="header-anchor" href="#异常处理的基本结构" aria-hidden="true">#</a> 异常处理的基本结构？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① try / catch
② try / catch / finally
③ try / finally
</code></pre></div><h3 id="jdk-1-8-新特性" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-新特性" aria-hidden="true">#</a> JDK 1.8 新特性</h3><p>① <strong>Lambda 表达式</strong><br>   允许把函数作为一个方法的参数。</p><p>② <strong>方法引用</strong><br>   方法引用允许直接引用已有 Java 类或对象的方法或构造方法。</p><p>③ <strong>函数式接口</strong><br>   有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为 Lambda 表达式。通常函数式接口上会添加<code>@FunctionalInterface</code>注解。</p><p>④ <strong>接口允许定义默认方法和静态方法</strong><br>   从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法。</p><p>⑤ <strong>Stream API</strong><br>   新添加的 Stream API（java.util.stream）把真正的函数式编程风格引入到 Java 中。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。</p><p>⑥ <strong>日期/时间类改进</strong><br>   之前的 JDK 自带的日期处理类非常不方便，我们处理的时候经常是使用的第三方工具包，比如 commons-lang 包等。不过 JDK8 出现之后这个改观了很多，比如日期时间的创建、比较、调整、 格式化、时间间隔等。这些类都在 java.time 包下，LocalDate/LocalTime/LocalDateTime。</p><p>⑦ <strong>Optional 类</strong><br>   Optional 类是一个可以为 null 的容器对象。如果值存在则 isPresent()方法会返 回 true，调用 get()方法会返回该对象。</p><p>⑧ <strong>Java 8 Base64 实现</strong><br>   Java 8 内置了 Base64 编码的编码器和解码器。</p><h2 id="集合-⭐️" tabindex="-1"><a class="header-anchor" href="#集合-⭐️" aria-hidden="true">#</a> 集合 ⭐️</h2><h3 id="栈与队列的区别" tabindex="-1"><a class="header-anchor" href="#栈与队列的区别" aria-hidden="true">#</a> 栈与队列的区别？</h3><blockquote><p>队列：先进先出(FIFO)，它只允许在前端进行删除操作，在后端进行插入操作。<br> 栈：先进后出，它只能在一端进行插入和删除操作。</p></blockquote><h3 id="顺序存储结构与链式存储结构的优缺点" tabindex="-1"><a class="header-anchor" href="#顺序存储结构与链式存储结构的优缺点" aria-hidden="true">#</a> 顺序存储结构与链式存储结构的优缺点</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>顺序存储结构:
 优:一是节省存储空间;二是访问速度快;
 缺:进行插入、删除元素时效率低。

链式存储结构:
 优:进行插入、删除元素时效率高;
 缺:一是对空间的占用比较大;二是访问速度慢。
</code></pre></div><h3 id="数据查找-遍历、二分查找-说一下二分查找的条件" tabindex="-1"><a class="header-anchor" href="#数据查找-遍历、二分查找-说一下二分查找的条件" aria-hidden="true">#</a> 数据查找：遍历、二分查找，说一下二分查找的条件</h3><p>必须是有序数组</p><h3 id="java-中常见的三种集合是哪三种" tabindex="-1"><a class="header-anchor" href="#java-中常见的三种集合是哪三种" aria-hidden="true">#</a> java 中常见的三种集合是哪三种？</h3><p><code>List、Set、Map</code></p><h3 id="list-与-set-的区别" tabindex="-1"><a class="header-anchor" href="#list-与-set-的区别" aria-hidden="true">#</a> List 与 Set 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>List集合元素按进入先后有序保存，可重复;
Set集合仅接收一次，无序，不可重复;
</code></pre></div><h3 id="arraylist-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-linkedlist-的区别" aria-hidden="true">#</a> ArrayList 与 LinkedList 的区别</h3><p>  ArrayList 是基于数组来实现的，比较节省存储空间，在查询时访问元素速度快效率高，但在进行修改操作时性能差；<br>   LinkedList 是基于双向链表来实现的，在进行修改操作时性能好，效率高，但对空间的占用大，在查询时访问速度慢。</p><h3 id="arraylist-与-vector-区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-vector-区别" aria-hidden="true">#</a> ArrayList 与 Vector 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>两者都是List集合，但ArrayList是线程非安全的，Vector是线程安全的。
</code></pre></div><h3 id="hashmap-与-hashtable-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-区别" aria-hidden="true">#</a> HashMap 与 Hashtable 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>HashMap集合中的key可以为null，值也可以是null，(只能由一个key为null)，它是线程非安全的;
Hashtable集合中的key-value都不能为空，它是线程安全的。
</code></pre></div><h3 id="hashmap-与-treemap-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-treemap-区别" aria-hidden="true">#</a> HashMap 与 TreeMap 区别？</h3><p>TreeMap 相对 HashMap，多了一个排序的功能</p><h3 id="集合迭代器的接口" tabindex="-1"><a class="header-anchor" href="#集合迭代器的接口" aria-hidden="true">#</a> 集合迭代器的接口？</h3><p><code>iterator</code></p><h3 id="遍历-list-有哪些不同的方式" tabindex="-1"><a class="header-anchor" href="#遍历-list-有哪些不同的方式" aria-hidden="true">#</a> 遍历 List 有哪些不同的方式？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>for循环、增强for循环、iterator迭代器
</code></pre></div><h3 id="hashset-和-treeset-的区别" tabindex="-1"><a class="header-anchor" href="#hashset-和-treeset-的区别" aria-hidden="true">#</a> HashSet 和 TreeSet 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>TreeSet相对于HashSet，多了一个排序的功能;
</code></pre></div><h3 id="collection-与-collections-的区别" tabindex="-1"><a class="header-anchor" href="#collection-与-collections-的区别" aria-hidden="true">#</a> Collection 与 Collections 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>Collection是集合的父接口，Collections是集合工具类。
</code></pre></div><h3 id="什么是-properties-类" tabindex="-1"><a class="header-anchor" href="#什么是-properties-类" aria-hidden="true">#</a> 什么是 Properties 类？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>该类主要用于读取 Java 的配置文件，不同的编程语言有自己所支持的配置文件，配置文件中很多变量是经常改变的，为了方便用户的配置，能让用户够脱离程序本身去修改相关的变量设置。就像在 Java 中，其配置文件常为*.properties 文件，是以键值对的形式进行参数配置的。</p></div><h3 id="java-中有几种类型的流" tabindex="-1"><a class="header-anchor" href="#java-中有几种类型的流" aria-hidden="true">#</a> JAVA 中有几种类型的流？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>①数据单位:字节流、字符流
②流向:输入流、输出流
③角色:节点流、处理流
</code></pre></div><h3 id="字节流与字符流的区别" tabindex="-1"><a class="header-anchor" href="#字节流与字符流的区别" aria-hidden="true">#</a> 字节流与字符流的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>对于文本文件(.txt，.java，.c，.c++)，使用字符流处理;
对于非文本文件(.jpg，.mp3，.mp4，.avi，.doc，.ppt)，使用字节流处理。
</code></pre></div><h3 id="bufferedreader-流的作用" tabindex="-1"><a class="header-anchor" href="#bufferedreader-流的作用" aria-hidden="true">#</a> BufferedReader 流的作用？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>BufferedReader 属于输入字符缓冲流，缓冲流是一种装饰器类，目的是让原字节流、字符流新增缓冲的功能。缓冲流作用是把数据先写入内存缓冲区，等缓冲区满了，再把数据写到文件里。读内存比读硬盘速度快很多倍，所以这样效率就大大提高了。</p></div><h3 id="什么是序列化-什么是反序列化" tabindex="-1"><a class="header-anchor" href="#什么是序列化-什么是反序列化" aria-hidden="true">#</a> 什么是序列化，什么是反序列化？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>序列化:将对象转为流，用来存贮或者网络传输;
反序列化:将流中的数据转为对象。
</code></pre></div><h3 id="什么是-xml" tabindex="-1"><a class="header-anchor" href="#什么是-xml" aria-hidden="true">#</a> 什么是 XML？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>XML 是可扩展标记语言(eXtensible [/ɪkˈstensəbl/] Markup Language)的简称。它是一个纯文本格式的文件，相对于文本，文档的内容一般用标签包裹;XML 在项目中主要用来存放配置信息。</p></div><h2 id="多线程-⭐️" tabindex="-1"><a class="header-anchor" href="#多线程-⭐️" aria-hidden="true">#</a> 多线程 ⭐️</h2><h3 id="什么是线程、什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是线程、什么是进程" aria-hidden="true">#</a> 什么是线程、什么是进程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>进程:运行中的程序称为进程;
线程:进程中的一条执行流(进程中可以同时由多个执行流-多线程，多线程的应用程序，程序可以并行执行多个任务，相对单线程应用程序，效率要高很多)
&gt; 线程是进程的子集，一个进程可以有多个线程
&gt; 额外知识理解:
 并行:多个CPU同时执行多个任务，如:多个人同时做不同的事
 并发:一个CPU同时执行多个任务，如:多个人做同一件事
</code></pre></div><h3 id="如何创建一个线程" tabindex="-1"><a class="header-anchor" href="#如何创建一个线程" aria-hidden="true">#</a> 如何创建一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① 继承于Thread类
② 实现Runnable接口
③ 实现Callable接口
④ 使用线程池
</code></pre></div><h3 id="如何启动一个线程" tabindex="-1"><a class="header-anchor" href="#如何启动一个线程" aria-hidden="true">#</a> 如何启动一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>调用start()方法;
</code></pre></div><h3 id="start-方法与-run-方法的区别" tabindex="-1"><a class="header-anchor" href="#start-方法与-run-方法的区别" aria-hidden="true">#</a> start()方法与 run()方法的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>start()方法是启动当前线程，并调用run()方法;(只能调用一次，否则抛出&quot;IllegalThreadStateException&quot;异常)
run()方法通常需要重写，要执行的代码声明在此方法中。
</code></pre></div><h3 id="什么是线程池-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池-为什么要使用线程池" aria-hidden="true">#</a> 什么是线程池，为什么要使用线程池？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程池就是存放多个线程的容器;可以重用线程，减少创建和销毁线程带来的消耗。
</code></pre></div><h3 id="什么是线程同步" tabindex="-1"><a class="header-anchor" href="#什么是线程同步" aria-hidden="true">#</a> 什么是线程同步？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>当多个线程访问同一资源，就需要解决数据一致性的问题，这时候就需要线程同步来解决这个问题。
线程同步:一次只允许某一个线程对某一资源进行访问称为线程同步。
</code></pre></div><h3 id="java-中的线程锁" tabindex="-1"><a class="header-anchor" href="#java-中的线程锁" aria-hidden="true">#</a> java 中的线程锁？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程锁(synchronized)作为并发共享数据，保证一致性的工具。
</code></pre></div><h3 id="说一下线程的几种状态" tabindex="-1"><a class="header-anchor" href="#说一下线程的几种状态" aria-hidden="true">#</a> 说一下线程的几种状态</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>新建--就绪--运行--阻塞--死亡
</code></pre></div><figure><img src="`+g+`" alt="线程状态转换图.jpg" width="600" tabindex="0" loading="lazy"><figcaption>线程状态转换图.jpg</figcaption></figure><h3 id="线程操作常见的-api" tabindex="-1"><a class="header-anchor" href="#线程操作常见的-api" aria-hidden="true">#</a> 线程操作常见的 API</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code> start():①启动当前线程;②调用run();
 run():线程在被调度时执行的操作
 currentThread():静态方法，返回执行当前代码的线程
 getName():获取当前线程名字
 setName():设置当前线程名字
 yield():释放当前CPU的执行权
 join():在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态
 stop():已过时。当执行此方法时，强制结束当前线程
 sleep(long mills):让当前线程“睡眠”--阻塞(毫秒)
 isAlive():判断线程还存活
</code></pre></div><h3 id="sleep-与-wait-区别" tabindex="-1"><a class="header-anchor" href="#sleep-与-wait-区别" aria-hidden="true">#</a> sleep 与 wait 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① sleep()的父类是Thread类，wait()的父类是Object()类;
② wait()方法使当前线程进入等待状态，直到另一线程对该对象发出notify/notifyAll来唤醒，sleep()方法是让线程处于休眠，预设值结束自动结束休眠。
③ sleep()不释放同步锁，wait()释放同步锁。
④ wait()通常放在同步代码块里，而sleep()则不受限制。
</code></pre></div><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2>`,131);function C(J,A){const c=i("CodeTabs");return r(),d("div",null,[b,p(c,{id:"442",data:[{id:"代码"},{id:"输出结果"}]},{title0:s(({value:t,isActive:e})=>[n("代码")]),title1:s(({value:t,isActive:e})=>[n("输出结果")]),tab0:s(({value:t,isActive:e})=>[m]),tab1:s(({value:t,isActive:e})=>[x]),_:1}),f,a("details",y,[j,p(c,{id:"530",data:[{id:"App.java"},{id:"Person.java"},{id:"输出"}]},{title0:s(({value:t,isActive:e})=>[n("App.java")]),title1:s(({value:t,isActive:e})=>[n("Person.java")]),title2:s(({value:t,isActive:e})=>[n("输出")]),tab0:s(({value:t,isActive:e})=>[w]),tab1:s(({value:t,isActive:e})=>[S]),tab2:s(({value:t,isActive:e})=>[_]),_:1},8,["data"])]),z])}const q=l(v,[["render",C],["__file","java-foundation.html.vue"]]);export{q as default};
