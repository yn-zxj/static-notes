import{_ as l,j as i,o as u,c as r,f as n,g as p,w as s,a as c,i as a}from"./app-2c174ce4.js";const k="/assets/base-type-fa548d7e.jpg",d="/assets/wrapper_class-15ce3d56.png",g="/assets/string_concat-b38c238e.png",m="/assets/string_pool-6111e3ee.png",v="/assets/t-01-a2fd61f9.png",h="/assets/extends-b3423045.png",b="/assets/super-aa4a4050.png",y="/assets/diamond_problem-bbb6df86.png",f="/assets/throwable-59a159de.jpg",x="/assets/thread-c419ee70.jpg",w={},j=c(`<h2 id="java-基础知识" tabindex="-1"><a class="header-anchor" href="#java-基础知识" aria-hidden="true">#</a> Java 基础知识</h2><h3 id="java-和-c-主要区别有哪些-各有哪些优缺点" tabindex="-1"><a class="header-anchor" href="#java-和-c-主要区别有哪些-各有哪些优缺点" aria-hidden="true">#</a> Java 和 C++主要区别有哪些？各有哪些优缺点？</h3><p><u class="under-wave">Java 和 C++分别代表了两种类型的语言：</u><br> ① <strong>C++是编译型语言</strong><br>   首先将源代码编译生成机器语言，再由机器运行机器码。执行速度快、效率高；依赖编译器、跨平台性差些。</p><p>② <strong>Java 是解释型语言</strong><br>   源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。执行速度慢、效率低；依赖解释器、跨平台性好。</p><blockquote><p>也有说 Java 是半编译、半解释型语言。Java 编译器(javac)现将源程序编译成 Java 字节码(.class)，JVM 负责解释执行字节码文件。</p></blockquote><hr><p><u class="under-wave">二者的主要区别：</u><br>  ① C++ 是<mark>平台相关</mark>的，Java 是<mark>平台无关</mark>的；<br>  ② C++ 对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，同一个类型在不同操作系统可能长度不一样。Java 在所有平台上对所有的基本数据类型都有标准的范围限制和字节长度。<br>  ③ C++ 除了一些比较少见的情况之外和 C 语言兼容。Java 没有对任何之前的语言向前兼容，但是在语法上受 C/C++ 的影响很大。<br>  ④ C++ 允许直接调用本地的系统库。Java 要通过 JNI 或者 JNA 调用。<br>  ⑤ C++ 允许<u class="under-dot">过程式程序设计和面向对象程序设计</u>。Java 必须使用面向对象的程序设计方式。<br>  ⑥ C++ 支持指针、引用、传值调用。Java 只有值传递。<br>  ⑦ C++ 需要显式的内存管理，但有第三方的框架可以提供垃圾搜集的支持，支持析构函数。Java 是自动垃圾收集的，也没有析构函数的概念。<br>  ⑧ C++ 支持多重继承，包括虚拟继承。Java 只允许单继承，需要多继承的情况要使用接口。</p><hr><details class="hint-container details"><summary>知识扩展：Java 与 C 的参数方法有什么区别？</summary><p>① C 语言是通过指针的引用传递<br> ② Java 会拷贝当前栈中的值传递过去</p><p>⭐️ 编程语言中需要进行方法间的参数传递，这个传递的策略叫做<mark>求值策略</mark>。<br> ⭐️ 在程序设计中，求值策略有很多种，比较常见的就是<u class="under-dash">值传递和引用传递</u>，还有一种值传递的特例——共享对象传递。<br> ⭐️ 值传递和引用传递的最大区别是传递过程中有没有复制出一个副本来，<u class="under-wave">如果是传递副本，那就是值传递，否则就是引用传递。</u><br> ⭐️ Java 对象的传递，是通过复制的方式把引用关系传递了，因为有复制的过程，所以是值传递，只不过对于 Java 对象的传递，传递的内容是对象的引用。</p></details><h3 id="jdk、jre、jvm-的区别-必会" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-的区别-必会" aria-hidden="true">#</a> JDK、JRE、JVM 的区别(必会)</h3><blockquote><p><strong>JDK</strong>：JDK(Java Development Kit)即 Java 开发工具包，是整个 Java 的核心，其包括了 Java 运行环境(JRE)、Java 工具和 Java 基础类库。</p><hr><p><strong>JRE</strong>：JRE(Java Runtime Environment)即 Java 运行环境，它是运行 Java 程序所必须得环境的集合，包含 Java 虚拟机和 Java 程序的一些核心类库。</p><hr><p><strong>JVM</strong>：JVM(Java Virtual Machine)即 Java 虚拟机，是整个 Java 实现跨平台的最核心部分，能够运行以 Java 语言写的软件程序。</p></blockquote><h3 id="说一下-java-的三种注释" tabindex="-1"><a class="header-anchor" href="#说一下-java-的三种注释" aria-hidden="true">#</a> 说一下 JAVA 的三种注释</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>// 单行注释
/*...*/ 多行注释
/...*/ 文档注释
</code></pre></div><h3 id="java-的数据类型" tabindex="-1"><a class="header-anchor" href="#java-的数据类型" aria-hidden="true">#</a> Java 的数据类型</h3><div class="hint-container tip"><p class="hint-container-title">数据类型</p><p>  Java 数据类型包括两大类：基本数据类型和引用数据类型；其中八个基本数据类型包括整型(byte、short、int、long)、浮点型(float、double)、字符型(char)、布尔型(boolean)；除此之外的都为引用数据类型，比如类、接口、数组。</p></div><figure><img src="`+k+`" alt="基本数据类型.jpg" width="600" tabindex="0" loading="lazy"><figcaption>基本数据类型.jpg</figcaption></figure><table><thead><tr><th>数据类型</th><th>字节数</th><th>位数</th><th>默认值</th><th>包装类型</th><th>使用说明[取值范围]</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>0</td><td>Byte</td><td>-128~127</td></tr><tr><td>short</td><td>2</td><td>16</td><td>0</td><td>Short</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int</td><td>4</td><td>32</td><td>0</td><td>Integer</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>long</td><td>8</td><td>64</td><td>0L 或 0l</td><td>Long</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>float</td><td>4</td><td>32</td><td>0.0F 或 0.0f</td><td>Float</td><td>1.4E-45~3.4E38</td></tr><tr><td>double</td><td>8</td><td>64</td><td>0.0d</td><td>Double</td><td>4.9E-324~1.8E308</td></tr><tr><td>char</td><td>2</td><td>16</td><td>空</td><td>Character</td><td>使用 Unicode 编码(2 个字节)，可存汉字</td></tr><tr><td>boolean</td><td>-</td><td>-</td><td>false</td><td>Boolean</td><td>只有 true 和 false 两个取值</td></tr></tbody></table><h3 id="整型的默认数据类型是什么-浮点型的数据类型是什么" tabindex="-1"><a class="header-anchor" href="#整型的默认数据类型是什么-浮点型的数据类型是什么" aria-hidden="true">#</a> 整型的默认数据类型是什么，浮点型的数据类型是什么？</h3><blockquote><p>整型默认数据类型：int<br> 浮点型默认数据类型：double</p></blockquote><h3 id="为什么不能用浮点型表示金额" tabindex="-1"><a class="header-anchor" href="#为什么不能用浮点型表示金额" aria-hidden="true">#</a> 为什么不能用浮点型表示金额？</h3><blockquote><p>  因为<u class="under-wave">不是所有的小数都能用二进制表示</u>，所以为了解决这个问题，IEEE 提出了一种使用近似值表示小数的方式，并且引入了精度的概念，这就是浮点数。<u class="under-wave">浮点数只是近似值，并不是精确值，所以不能用来表示金额，否则会有精度丢失。</u><br>   为了解决精度问题，可以使用<code>BigDecimal</code>。</p></blockquote><hr><p><strong>数据库涉及金额时，同样需要注意</strong>：</p><div class="project-panel-custom"><a class="project project0 project-card" href="/backend/database/base/data_type.html#浮点类型" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-info"></span><div class="name">MySQL数据类型-浮点类型</div><div class="desc">精度误差说明</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> info
  <span class="token key atrule">name</span><span class="token punctuation">:</span> MySQL数据类型<span class="token punctuation">-</span>浮点类型
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> 精度误差说明
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/database/base/data_type.html<span class="token comment">#浮点类型</span>
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="java-中有了基本类型为什么还需要包装类" tabindex="-1"><a class="header-anchor" href="#java-中有了基本类型为什么还需要包装类" aria-hidden="true">#</a> Java 中有了基本类型为什么还需要包装类？</h3><p>  Java 是一个面向对象的编程语言，但是 Java 中的八种基本数据类型却是不面向对象的 <mark>(比如：集合类中，无法将 int、double 等类型放进去，因为集合的容器要求是 Object 类型。)</mark>，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于 java.lang 包。</p><figure><img src="`+d+'" alt="包装类.png" width="700" tabindex="0" loading="lazy"><figcaption>包装类.png</figcaption></figure>',28),S={class:"hint-container details"},_=c(`<summary>知识扩展</summary><p>① <strong>基本类型和包装类型的区别</strong><br> （1）默认值不同，基本类型的默认值为<code>0</code>、<code>false</code>或<code>\\u0000</code>等，包装类默认为<code>null</code><br> （2）初始化方式不同，一个需要 new，一个不需要<br> （3）存储方式不同，基本类型保存在栈上，包装类对象保存在堆上（通常情况下，在没有 JIT 优化栈上分配时）</p><p>② <strong>如何理解拆装箱</strong><br>   包装类是对基本类型的包装，所以，<u class="under-wave">把基本数据类型转换成包装类的过程就是装箱</u>；反之，<u class="under-wave">把包装类转换成基本数据类型的过程就是拆箱</u>。在 Java SE5 中，为了减少开发人员的工作，Java 提供了自动拆箱与自动装箱功能。</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// Java SE5 之前</span>
<span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Java SE5 之后</span>
<span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 自动装箱</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">;</span>      <span class="token comment">// 自动拆箱</span>
</code></pre></div><p>利用工具<code>JD-GUI</code>查看<code>class</code>字节码文件：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过分析上面的代码，可以看出<u class="under-wave">自动装箱都是通过<mark>包装类</mark>的<code>valueOf()</code>方法实现；自动拆箱都是通过<mark>包装类对象</mark>的<code>xxxValue()</code>来实现。</u></p><p>③ <strong>哪些地方涉及自动拆装箱</strong></p><p> 场景一：将基本数据类型放入集合类(自动装箱)</p>`,9),A=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"List"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},">")]),a(" list "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"ArrayList"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token punctuation"},">")]),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"for"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(" i "),n("span",{class:"token operator"},"<"),a(),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},";"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
    list`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"add"),n("span",{class:"token punctuation"},"("),a("i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),q=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"List"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},">")]),a(" list "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"ArrayList"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token punctuation"},">")]),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"for"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(" i "),n("span",{class:"token operator"},"<"),a(),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},";"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),a(`
    list`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"add"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),a("i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),J=n("p",null," 场景二：包装类型和基本类型的大小比较",-1),C=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Integer"),a(" a "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),a("a "),n("span",{class:"token operator"},"=="),a(),n("span",{class:"token number"},"1"),a(),n("span",{class:"token operator"},"?"),a(),n("span",{class:"token string"},'"等于"'),a(),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},'"不等于"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token class-name"},"Boolean"),a(" bool "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token boolean"},"false"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),a("bool "),n("span",{class:"token operator"},"?"),a(),n("span",{class:"token string"},'"真"'),a(),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},'"假"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),I=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Integer"),a(" a "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),a("a"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"intValue"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"=="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"?"),a(),n("span",{class:"token string"},'"等于"'),a(),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},'"不等于"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token class-name"},"Boolean"),a(" bool "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Boolean"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token boolean"},"false"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),a("bool"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"booleanValue"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"?"),a(),n("span",{class:"token string"},'"真"'),a(),n("span",{class:"token operator"},":"),a(),n("span",{class:"token string"},'"假"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),L=n("blockquote",null,[n("p",null,"⭐️ 包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。")],-1),z=n("p",null," 场景三：包装类型的运算",-1),B=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Integer"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"Integer"),a(" j "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"20"),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),a("i "),n("span",{class:"token operator"},"+"),a(" j"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),E=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Integer"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"Integer"),a(" j "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"20"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),a("i"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"intValue"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},"+"),a(" j"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"intValue"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),D=n("blockquote",null,[n("p",null,"⭐️ 两个包装类型之间的运算，会被自动拆箱成基本类型进行。")],-1),T=n("p",null," 场景四：三目运算符的使用",-1),O=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"boolean"),a(" flag "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token boolean"},"true"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"Integer"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"int"),a(" j "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"int"),a(" k "),n("span",{class:"token operator"},"="),a(" flag "),n("span",{class:"token operator"},"?"),a(" i "),n("span",{class:"token operator"},":"),a(" j"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"k = "'),a(),n("span",{class:"token operator"},"+"),a(" k"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),M=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"boolean"),a(" flag "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token boolean"},"true"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"Integer"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"int"),a(" j "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"int"),a(" k "),n("span",{class:"token operator"},"="),a(" flag "),n("span",{class:"token operator"},"?"),a(" i"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"intValue"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token operator"},":"),a(" j"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"k = "'),a(),n("span",{class:"token operator"},"+"),a(" k"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),P=c(`<blockquote><p>⭐️ 三目运算符的语法规范：当第二、第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。假如此处的<code>i</code>为<code>null</code>，自动拆箱就会出现 NPE 异常(空指针)。</p></blockquote><p> 场景五：函数参数与返回值</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 自动拆箱：num.intValue()</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum1</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 自动装箱：Integer.valueOf(num)</span>
<span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>④ <strong>自动拆装箱与缓存</strong></p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(100);</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(100);</span>
<span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(200);</span>
<span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// Integer.valueOf(200);</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印false</span>
</code></pre></div><blockquote><p>⭐️ 在 Java 中，<code>==</code>比较的是对象的引用，而<code>equals</code>比较的是值。所以，在这个例子中，不同的对象有不同的引用，那么应该都返回 false。但是结果与我们预想的不一致，这里和 Integer 中的缓存机制有关。在 Java5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用 <mark>（适用于整数-128 ~ 127，且只适用于自动装箱）</mark>。当需要进行自动装箱时，如果数字在-128 ~ 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。<br> ⭐️ 在 Java5 中引入这个功能时，这个范围是固定的，后面在 Java6 中，可以通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>或者在 VM 初始化期间使用<code>java.lang.Integer.IntegerCache.high</code>设置最大值。</p></blockquote>`,6),F=c('<h3 id="如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" tabindex="-1"><a class="header-anchor" href="#如何将一个整型转为字符串-反之-将一个字符串类型的数据转为整型" aria-hidden="true">#</a> 如何将一个整型转为字符串，反之，将一个字符串类型的数据转为整型</h3><blockquote><p>整型 → 字符串：String.valueOf(int parameter)<br> 字符串 → 整型：Interger.parseInt(String parameter)</p></blockquote><h3 id="重载-overload-与重写-override-的区别" tabindex="-1"><a class="header-anchor" href="#重载-overload-与重写-override-的区别" aria-hidden="true">#</a> 重载(overload)与重写(override)的区别</h3><blockquote><p><strong>重载</strong>：同一个类中，方法名相同，方法的参数的<u class="under-wave">类型、顺序、数量</u>不同的一组方法 <mark>(返回值不同，但是方法名和参数列表都相同的两个方法，不是重载。)</mark><br><strong>重写</strong>：子类对父类中的同名方法进行覆盖</p></blockquote><h3 id="java-中-与equals的区别-必会" tabindex="-1"><a class="header-anchor" href="#java-中-与equals的区别-必会" aria-hidden="true">#</a> Java 中<code>==</code>与<code>equals</code>的区别(必会)</h3><blockquote><p><code>==</code>：<br>   基本类型：比较的就是值是否相同<br>   引用类型：比较的就是内存中的存放地址(堆内存地址)是否相同</p><p><code>equals</code>：<br>   此方法是 Object 类中定义方法，只能实现两个引用类型的变量进行比较，默认比较的是两个对象的内存地址值；在 String 类，对此方法进行了重写，实现的是比较两个字符串的值是否相同；</p></blockquote><h3 id="为什么不能用-bigdecimal-的-equals-方法做等值比较" tabindex="-1"><a class="header-anchor" href="#为什么不能用-bigdecimal-的-equals-方法做等值比较" aria-hidden="true">#</a> 为什么不能用 BigDecimal 的 equals 方法做等值比较？</h3><blockquote><p>因为 BigDecimal 的 equals 方法和 compareTo 并不一样，equals 方法会比较两个部分的内容，分别是值(value)和标度(scale)，比如 0.1 和 0.10 这两个数字，它们的值虽然一样，但是由于精度不一样，所以使用 equals 会返回 false。</p></blockquote><hr><p><strong>知识扩展(阿里巴巴 Java 开发手册)</strong>：</p><p><span style="color:red;">【强制】</span>如上所示 BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。<br><span style="font-size:12px;">说明：equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</span></p><hr><h3 id="bigdecimal-double-和-bigdecimal-string-有什么区别" tabindex="-1"><a class="header-anchor" href="#bigdecimal-double-和-bigdecimal-string-有什么区别" aria-hidden="true">#</a> BigDecimal(double)和 BigDecimal(String)有什么区别？</h3><blockquote><p>因为 double 是不精确的，所以使用一个不精确的数字来创建 BigDecimal，得到的数字也是不精确的。如 0.1 这个数，double 只能表示它的近似值。而对于 BigDecimal(String)，创建出来的值就是精确的。</p></blockquote><hr><p><strong>知识扩展(阿里巴巴 Java 开发手册)</strong>：</p><p><span style="color:red;">【强制】</span>禁止使用构造方法 BigDecimal(double)的方式把 double 转化为 BigDecimal 对象。<br><span style="font-size:12px;">说明：BigDecimal(double)存在精度损失风险，在精度计算或值比较的场景中可能会导致业务逻辑异常。</span><br><span style="font-size:12px;">如：BigDecimal g = new BigDecimal(0.1F)；实际的存储值为：0.10000000149</span><br><span style="font-size:12px;">正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 类的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</span><br><span class="under-wave" style="font-size:12px;">BigDecimal recommand1 = new BigDecimal(&quot;0.1&quot;);</span><br><span class="under-wave" style="font-size:12px;">BigDecimal recommand2 = BigDecimal.valueOf (0.1);</span></p><hr><h3 id="为什么对-java-中的负数取绝对值结果不一定是正数" tabindex="-1"><a class="header-anchor" href="#为什么对-java-中的负数取绝对值结果不一定是正数" aria-hidden="true">#</a> 为什么对 Java 中的负数取绝对值结果不一定是正数？</h3><blockquote><p>  <u class="under-wave">使用<code>Math.abs</code>对一个 Interger 取绝对值的时候，可能出现负数情况</u>。int 的取值范围是 -2<sup>31</sup> ~ 2<sup>31</sup>-1，即-2147483648 ~ 2147483647。假设对-2147483648 取绝对值，正数就大于了 int 的最大取值范围，这时候就会发生越界。2147483647 用二进制的补码表示是：<code>01111111 11111111 11111111 11111111</code>，这个数 + 1 得到<code>10000000 00000000 00000000 00000000</code>，这个二进制称为-2147483648 的补码。针对这种情况可以把 int 类型转成 long 类型，就不会出现越界了。</p></blockquote><h3 id="string、stringbuffer-与-stringbuilder-的区别-必会" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer-与-stringbuilder-的区别-必会" aria-hidden="true">#</a> String、StringBuffer 与 StringBuilder 的区别(必会)</h3><blockquote><p><strong>String</strong>：字符串常量<br><strong>StringBuffer</strong>：字符串变量(线程安全)<br><strong>StringBuilder</strong>：字符串变量(非线程安全)</p></blockquote><p>  String 构建一个不可变的字符序列，StringBuffer 和 StringBuilder 都是构建一个可变的字符序列。在对字符串进行追加操作时 StringBuffer 比 String 效率高。</p><p>  此外 StringBuffer 是线程安全的，而 StringBuilder 是线程非安全的，在对字符串进行修改操作时，StringBuilder 效率优于 StringBuffer。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  String 在 String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，String 对象是不可变的，也就可以理解为常量，线程安全。</p><p>  AbstractStringBuilder 是 StringBuffer 与 StringBuilder 的公共父类，定义了一些字符串的基本操作，如：expandCapacity、append、insert、indexOf 等公共方法。</p><p>  StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>  StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></div><p><strong>小结</strong>：<br> ① 如果要操作少量的数据用 String；<br> ② 多线程操作字符串缓冲区下操作大量数据用 StringBuffer；<br> ③ 单线程操作字符串缓冲区下操作大量数据用 StringBuilder。</p><hr>',27),N={class:"hint-container details"},V=c(`<summary>知识扩展</summary><p>① <strong>String 为什么不可变，我的代码中经常改变 String 的值</strong></p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">&quot;ef&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+g+'" alt="字符串拼接.png" width="500" tabindex="0" loading="lazy"><figcaption>字符串拼接.png</figcaption></figure><p>  虽然字符串内容看上去从&quot;abcd&quot;变成了&quot;abcdef&quot;，但是实际上，我们得到的已经是一个新的字符串了(<mark>在堆中重新创建了一个&quot;abcdef&quot;字符串，和&quot;abcd&quot;并不是同一个对象</mark>)。<br>   所以，一旦一个 string 对象在内存(堆)中被创建出来，它就无法被修改。而且，String 类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。</p><p>② <strong>String 的&quot;+&quot;是如何实现的</strong><br>   使用<code>+</code>拼接字符串，其实只是 Java 提供的一个语法糖，内部原理到底是如何实现的。</p>',6),K=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"String"),a(" hello "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"Hello"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"String"),a(" java "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"Java"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"String"),a(" out "),n("span",{class:"token operator"},"="),a(" hello "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},'","'),a(),n("span",{class:"token operator"},"+"),a(" java"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),U=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"String"),a(" hello "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"Hello"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"String"),a(" java "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"Java"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"StringBuilder"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("hello"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'","'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("java"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),H=n("blockquote",null,[n("p",null,"字符串常量在拼接过程中，是将 String 转成了 StringBuilder 后，使用其 append 方法进行处理的。")],-1),G=n("p",null,[a("③ "),n("strong",null,"不要在 for 循环中使用+拼接字符串")],-1),R=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"long"),a(" t1 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"currentTimeMillis"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"String"),a(" str "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"java"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"for"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),a(" i "),n("span",{class:"token operator"},"<"),a(),n("span",{class:"token number"},"50000"),n("span",{class:"token punctuation"},";"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token class-name"},"String"),a(" s "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),a("i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    str `),n("span",{class:"token operator"},"+="),a(" s"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token keyword"},"long"),a(" t2 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"currentTimeMillis"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Time:"'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token punctuation"},"("),a("t2 "),n("span",{class:"token operator"},"-"),a(" t1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),X=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"long"),a(" t1 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"currentTimeMillis"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"String"),a(" str "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token string"},'"java"'),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"for"),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),a(" i "),n("span",{class:"token operator"},"&"),a("lt"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token number"},"50000"),n("span",{class:"token punctuation"},";"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),a(`
`),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token class-name"},"String"),a(" s "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),a("i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    str `),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"StringBuilder"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("str"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("s"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"long"),a(" t2 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"currentTimeMillis"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"StringBuilder"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Time:"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("t2 "),n("span",{class:"token operator"},"-"),a(" t1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),Q=n("p",null,[a("  在 for 循环中，每次都是 new 了一个 StringBuilder，然后再把 String 转成 StringBuilder，再进行 append。"),n("br"),a("   而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。")],-1),W=n("hr",null,null,-1),Z=n("p",null,[n("strong",null,"阿里巴巴 Java 开发手册"),a("：")],-1),Y=n("p",null,[a("【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。"),n("br"),n("span",{style:{"font-size":"12px"}},"说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。")],-1),$=n("div",{style:{"font-size":"12px"}},"反例：",-1),nn=n("pre",{style:{"font-size":"12px",padding:"0"}},`String str = "start";
for (int i = 0; i < 100; i++) {
    str = str + "hello";
}
`,-1),an=c(`<hr><h3 id="string-为什么设计成不可变的" tabindex="-1"><a class="header-anchor" href="#string-为什么设计成不可变的" aria-hidden="true">#</a> String 为什么设计成不可变的？</h3><p>① <strong>缓存</strong><br>   字符串是使用最广泛的数据结构。大量的字符串的创建是非常耗费资源的，所以 Java 提供了对字符串的缓存功能，可以大大的节省堆空间。<br>   JVM 中专门开辟了一部分空间来存储 Java 字符串，那就是<mark>字符串池</mark>。<br>   通过字符串池，两个内容相同的字符串变量，可以从池中指向同一个字符串对象，从而节省了关键的内存资源。</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> s<span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+m+`" alt="字符串对象.png" width="500" tabindex="0" loading="lazy"><figcaption>字符串对象.png</figcaption></figure><blockquote><p>  对于这个例子，s 和 s2 都表示&quot;abcd&quot;，所以它们会指向字符串池中的同一个字符串对象。之所以可以这么做，主要是因为字符串的不变性。如果字符串是可变的，我们一旦修改了 s 的内容，那必然导致 s2 的内容也被动的改变了，这显然不是我们想看到的。</p></blockquote><p>② <strong>安全性</strong><br>   字符串在 Java 应用程序中广泛用于存储敏感信息，如用户名、密码、连接 url、网络连接等。JVM 类加载器在加载类的时也广泛地使用它。<br>   因此，保护 String 类对于提升整个应用程序的安全性至关重要。<br>   当我们在程序中传递一个字符串的时候，如果这个字符串的内容是不可变的(<u class="under-dash">这里所说的不可变是指字符串对象本身的内容不可变，而不是引用指向的对象</u>)，那么我们就可以相信这个字符串中的内容。<br>   但是，如果是可变的，那么这个字符串内容就可能随时都被修改。那么这个字符串内容就完全不可信了。这样整个系统就没有安全性可言了。<br> 举例：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 上面提到了字符串常量池的概念，下面的变量a、b都指向同一个123</span>
<span class="token comment">// 假如String可变的，改变a的值，那么b也一起变了</span>
<span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token string">&quot;456&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>③ <strong>线程安全</strong><br>   不可变会自动使字符串成为线程安全的，因为当从多个线程访问它们时，它们不会被更改。<br>   一般来说，不可变对象可以在同时运行的多个线程之间共享。它们也是线程安全的，因为如果线程更改了值，那么将在字符串池中创建一个新的字符串，而不是修改相同的值。因此，字符串对于多线程来说是安全的。</p><p>④ <strong>hashcode 缓存</strong><br>   由于字符串对象被广泛地用作数据结构，它们也被广泛地用于哈希实现，如 HashMap、HashTable、HashSet 等。在对这些散列实现进行操作时，经常调用 hashCode()方法。<br>   不可变性保证了字符串的值不会改变。因此，hashCode()方法在 String 类中被重写，以方便缓存，这样在第一次 hashCode()调用期间计算和缓存散列，并从那时起返回相同的值。</p><p>在 String 类中，有以下代码：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment">//this is used to cache hash code.</span>
</code></pre></div><p>⑤ <strong>性能</strong><br>   前面提到了的字符串池、hashcode 缓存等，都是提升性能的体现。<br>   因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对 hashcode 进行缓存，更加高效。<br>   由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。</p><h3 id="string-能被继承吗" tabindex="-1"><a class="header-anchor" href="#string-能被继承吗" aria-hidden="true">#</a> String 能被继承吗？</h3><blockquote><p>String 被 final 关键字修饰属于最终类，不能被继承。<br> ⭐️ 底层源码：<code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {...}</code></p></blockquote><h3 id="string-a-ab-string-b-a-b-a-b-吗" tabindex="-1"><a class="header-anchor" href="#string-a-ab-string-b-a-b-a-b-吗" aria-hidden="true">#</a> String a = &quot;ab&quot;; String b = &quot;a&quot; + &quot;b&quot;; a == b 吗？</h3><blockquote><p>⭐️ 在 Java 中，对于字符串使用<code>==</code>比较的是字符串对象的引用地址是否相同。<br> ⭐️ 因为 a 和 b 都是由字面量组成的字符串，它们的引用地址在编译时就已经确定了，并且在编译之后，会把字面量直接组合在一起。因此，<code>a == b</code>的结果是<code>true</code>，因为它们指向的是同一个字符串对象。<br> 编译后代码：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;(a==b) = &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></blockquote><h3 id="string-str-new-string-hello-创建了几个对象" tabindex="-1"><a class="header-anchor" href="#string-str-new-string-hello-创建了几个对象" aria-hidden="true">#</a> String str=new String(&quot;Hello&quot;)创建了几个对象？</h3><p>创建的对象数应该是一个或者两个。<br> 情况一：如果 String 的字符串常量池中有了 Hello 这个对象，那么就只创建一个对象。</p><blockquote><p>因为字符串常量池中有 Hello，字符串就会用已有的 Hello 对象，所以不会在创建 Hello 对象了，只会创建一个 new String 对象。</p></blockquote><p>情况二：如果 String 的字符串常量池中没有 Hello 这个对象，那么就会创建两个对象。</p><blockquote><p>只要是 new 了就一定会创建一个新的对象，而字符串常量池中没有 Hello，所以会在字符串常量池中创建一个 Hello 对象。</p></blockquote><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于</span>
<span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><hr><p><strong>知识扩展</strong>：<br> 创建了几个对象？</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 2个，一个是str对象a，一个是str1对象ab</span>

<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str1 <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 3个，一个是str对象a，一个是b对象，一个是str1对象ab</span>
</code></pre></div><hr><h3 id="string-有长度限制吗-是多少" tabindex="-1"><a class="header-anchor" href="#string-有长度限制吗-是多少" aria-hidden="true">#</a> String 有长度限制吗？是多少？</h3><blockquote><p>  有限制，并且编译期和运行期不一样。<br>   编译期需要用<code>CONSTANT_Utf8_info</code>结构用于表示字符串常量的值，而这个结构是有长度限制，它的限制是 65535。<u class="under-dot">(理论上 65535，实际 65534)</u><br>   运行期，String 的 length 参数是 int 类型的，那么也就是说，String 定义的时候，最大支持的长度就是 int 的最大范围值。根据 Integer 类的定义，<code>java.lang.Integer#MAX_VALUE</code> 的最大值是 2<sup>31</sup> - 1 (大概 4G);</p></blockquote><h3 id="说一下字符串操作常见的-api-10-个左右即可" tabindex="-1"><a class="header-anchor" href="#说一下字符串操作常见的-api-10-个左右即可" aria-hidden="true">#</a> 说一下字符串操作常见的 API ？(10 个左右即可)</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code>、<code>concat(String str)</code></td><td>字符串连接</td></tr><tr><td><code>==</code>、<code>equals(Object anObject)</code>、<code>equalsIgnoreCase(String another String)</code></td><td>字符串比对</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定位置字符值</td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取指定字符串第一次出现的下标值</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>字符串替换</td></tr><tr><td><code>startsWith(String prefix)</code>、<code>endsWith(String prefix)</code></td><td>判断是否以指定字符串开始|结束</td></tr><tr><td><code>toLowerCase()</code>、<code>toUpperCase()</code></td><td>所有字符转换为小写|大写</td></tr><tr><td><code>substring(index)</code></td><td>字符串截取</td></tr><tr><td><code>trim()</code></td><td>去除左右空格</td></tr><tr><td><code>String.valueOf(int i)</code></td><td>将整型转为字符串</td></tr><tr><td><code>contains(String str)</code></td><td>判断字符串是否包含某子字符串</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>split(String regex)</code></td><td>指定分隔符返回分割后的字符数组</td></tr><tr><td><code>toCharArray()</code></td><td>将字符串转为字符数组</td></tr><tr><td><code>getBytes()</code>、<code>getBytes(String charsetName)</code></td><td>返回字符串的 byte 类型数组(可指定字符集)</td></tr></tbody></table><h3 id="自增-如下代码的运行结果" tabindex="-1"><a class="header-anchor" href="#自增-如下代码的运行结果" aria-hidden="true">#</a> 自增(如下代码的运行结果)</h3>`,32),sn=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{java:"",class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Test"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(`
        i `),n("span",{class:"token operator"},"="),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" j "),n("span",{class:"token operator"},"="),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" k "),n("span",{class:"token operator"},"="),a(" i "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token operator"},"++"),a("i "),n("span",{class:"token operator"},"*"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"i="'),a(),n("span",{class:"token operator"},"+"),a(" i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"j="'),a(),n("span",{class:"token operator"},"+"),a(" j"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"k="'),a(),n("span",{class:"token operator"},"+"),a(" k"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("div",{class:"highlight-lines"},[n("br"),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br")]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),tn=n("div",{class:"language-text line-numbers-mode","data-ext":"text"},[n("pre",{class:"language-text"},[n("code",null,`i=4
j=1
k=11
`)]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),en=c('<div class="hint-container tip"><p class="hint-container-title">解析</p><p><strong>行 4</strong>：先将 1 压入操作数栈，然后局部变量表中的 i 自增变为 2，最后操作树栈中的 1 赋值给 i，2 被覆盖；</p><figure><img src="'+v+`" alt="处理过程.png" tabindex="0" loading="lazy"><figcaption>处理过程.png</figcaption></figure><p><strong>总结</strong>：<br> ① 先赋值再自增、自减(i = i++ 、i = i--)，先自增、自减再赋值(i = ++i 、i = --i)<br> ② = 右边的从左到右加载值依次压入操作数栈<br> ③ 实际先算哪个，看运算符优先级<br> ④ 自增、自减操作都是<mark>直接修改变量的值，不经过操作数栈</mark><br> ⑤ 最后的赋值之前，临时结果也是存储在操作数栈中</p></div><h3 id="rpc-接口返回中-使用基本类型还是包装类" tabindex="-1"><a class="header-anchor" href="#rpc-接口返回中-使用基本类型还是包装类" aria-hidden="true">#</a> RPC 接口返回中，使用基本类型还是包装类？</h3><blockquote><p>⭐️ 使用<mark>包装类</mark>，不要使用基本类型，比如某个字段表示费率的<code>Float rate</code>，在接口中返回时，如果出现接口异常的情况，那么可能会返回默认值，float 的默认值为 0.0，而 Float 的默认值是 null。<br> ⭐️ 在接口中，为了避免发生歧义，建议使用对象，因为它的默认值是 null，当看到 null 的时候，可以知道是出错了，但是看到 0.0，就无法分辨是出错返回的，还是真的返回 0.0，虽然也可以用其它字段，比如错误码这些来判断，但还是尽量减少歧义的可能。</p></blockquote><p><strong>知识扩展</strong>：在接口定义的时候，如何定义一个字段表示是否成功？</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> success
<span class="token class-name">Boolean</span> success
<span class="token keyword">boolean</span> isSuccess
<span class="token class-name">Boolean</span> isSuccess
</code></pre></div><blockquote><p>建议使用第一种。作为接口返回对象的参数，这个字段不应该有不确定的 null 值，而 Boolean 类型的默认值为 null，boolean 的默认值为 false，所以建议使用 boolean 来定义参数。关于参数名称的命令，阿里巴巴开发手册有明确规定和解释。</p></blockquote><p><span style="color:red;">【强制】</span>POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。<br><span style="font-size:12px;">反例：定义为基本数据类型<code>Boolean isDeleted;</code>的属性，它的方法也是<code>isDeleted()</code>，RPC 框架在反向解析的时候，&quot;以为&quot;对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</span></p><hr><h3 id="常见的字符编码有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#常见的字符编码有哪些-有什么区别" aria-hidden="true">#</a> 常见的字符编码有哪些？有什么区别？</h3><blockquote><p>⭐️ 计算机只认识 0 和 1 两种字符，但是人类的文字是多种多样的，如何把人类的文字转换成计算机认识的 0 和 1 呢，这个过程需要通过<strong>字符编码</strong>。<br> ⭐️ 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系做了统一的规定，这被称为 ASCII 码，一直沿用至今。<br> ⭐️ 由于 ASCII 只有 128 个字符，虽然对于英文字符都可以表示了，但是世界上很多其它的文字无法表示，于是后面出现了 Unicode 字符集(常见的 Unicode Transformation Format 有 UTF-7、UTF-7.5、UTF-8、UTF-16 以及 UTF-32)，除此之外还有一些常用的中文编码如 GBK、GB2312、GB18030 等。</p></blockquote><p><strong>知识扩展</strong>：<br> ① <strong>Unicode 和 UTF-8 有啥关系？</strong><br>   首先 Unicode 和 UTF-8 都是字符编码方案。它们的目的都是为了统一字符的表示方式，以便在不同的计算机系统和软件中进行字符的交换和处理。</p><p>  Unicode 是一个字符集，它为每个字符分配了唯一的编号(码点)，包括了世界上几乎所有的字符，但是却没有规定如何存储。假如 Unicode 统一规定，每个符号就要用三个或四个字节表示(因为字符太多，只能用这么多字节才能表示完全)。一旦这么规定，那么每个英文字母前都必然有二到三个字节是 0，因为所有英文字母在 ASCII 中都有，都可以用一个字节表示，剩余字节位置就要补充 0。如果这样，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。</p><p>  为了解决这个问题就出现了一些中间格式的字符集，它们被称为通用转换格式，即 UTF（Unicode Transformation Format）。</p><p>  UTF-8 是一种针对 Unicode 的<mark>可变长度字符编码</mark>方案。它使用一到四个字节来表示一个 Unicode 字符，根据字符的不同范围，采用不同长度的编码。UTF-8 是一种通用的字符编码方案，它能够表示 Unicode 字符集中的任意字符，并且兼容 ASCII 编码。</p><p>  此外 UTF-16 使用二或四个字节为每个字符编码，UTF-32 使用四个字节为每个字符编码。它们都是 Unicode 的一种实现方式。</p><p>② <strong>有了 UTF-8，为什么要出现 GBK？</strong><br>   GBK（Guo Biao Kang）是中国的一种字符集编码方式，它是国家标准局于 1995 年发布的一种汉字编码标准。采用双字节编码，能够表示简体和繁体中文字符以及日韩等扩展字符，总计收录了 21886 个汉字。使用 GBK <u class="under-dot">主要还是处于节省存储空间考虑</u>，例如一个中国的网站，更多的是使用中文和一些英文字符，很少会出现其它语言字符。</p><div class="hint-container tip"><p class="hint-container-title">常用的中文编码有 GBK，GB2312，GB18030 等，最常用的是 GBK。</p><p>GB2312（1980 年）：16 位字符集，收录有 6763 个简体汉字，682 个符号，共 7445 个字符；<br>  优点：适用于简体中文环境，属于中国国家标准，通行于大陆，新加坡等地也使用此编码；<br>  缺点：不兼容繁体中文，其汉字集合过少。</p><p>GBK（1995 年）：16 位字符集，收录有 21003 个汉字，883 个符号，共 21886 个字符；<br>  优点：适用于简繁中文共存的环境，为简体 Windows 所使用，向下完全兼容 gb2312，向上支持 ISO-10646 国际标准 ；所有字符都可以一对一映射到 unicode2.0 上；<br>  缺点：不属于官方标准，和 big5 之间需要转换；很多搜索引擎都不能很好地支持 GBK 汉字。</p><p>GB18030（2000 年）：32 位字符集；收录了 27484 个汉字，同时收录了藏文、蒙文、维吾尔文等主要的少数民族文字。<br>  优点：可以收录所有你能想到的文字和符号，属于中国最新的国家标准；<br>  缺点：目前支持它的软件较少。</p></div><p>③ <strong>为什么会出现乱码？</strong><br>   文件里面的内容归根结底都是由 0 和 1 组成的，至于它们的组合如何转成可以理解的字符串，则需要通过规定好的字符编码标准来进行转换。如果我们把通过 UTF-8 编码的一串中文字符串传给别人，假如他通过 GBK 进行解码，就会出现<code>锟届瀿锟斤拷雮傡锟斤拷直锟斤拷锟</code>，这就是乱码。</p><hr><h3 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h3><div class="hint-container tip"><p class="hint-container-title">什么是 Singleton ？</p><p><strong>Singleton</strong> : 在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。单例设计模式，即某个类在整个系统中<mark>只能有一个实例对象</mark>可被获取和使用的代码模式。例如：代表 JVM 运行环境的 Runtime 类</p><p><strong>要点</strong>：</p><p>① 某个类只能有一个实例【构造器私有化】<br> ② 它必须自行创建这个实例【含有一个该类的静态变量来保存这个唯一的实例)】<br> ③ 它必须自行向整个系统提供这个实例【对外提供获取该实例对象的方式：(1)直接暴露 (2)用静态变量的 get 方法获取】</p></div><h4 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 直接实例化(简洁直观)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 枚举式(最简洁)</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块(适合复杂实例化)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在类初始化时直接创建实例对象，不管是否需要这个对象，不存在线程安全问题</p></blockquote><h4 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 静态内部类形式(适用于多线程)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Inner</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟创建对象<br> 线程不安全(适用于单线程)、线程安全(适用于多线程)</p></blockquote><h3 id="说几个常见的语法糖" tabindex="-1"><a class="header-anchor" href="#说几个常见的语法糖" aria-hidden="true">#</a> 说几个常见的语法糖？</h3><p>  语法糖(Syntactic sugar)，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</p><p>  虽然 Java 中有很多语法糖，但是 Java 虚拟机并不支持这些语法糖，所以<u class="under-wave">这些语法糖在编译阶段就会被还原成简单的基础语法结构</u>，这样才能被虚拟机识别，这个过程就是解语法糖。</p><p>  如果看过 Java 虚拟机的源码，就会发现在编译过程中有一个重要的步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现。</p><p>  常见的语法糖有 switch 支持枚举及字符串、泛型、条件编译、断言、可变参数、自动装箱/拆箱、枚举、内部类、增强 for 循环、try-with-resources 语句、lambda 表达式等。</p><p><strong>知识扩展：</strong></p><div class="project-panel-custom"><a class="project project0 project-card" href="/backend/java/syntactic-sugar.html" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-any"></span><div class="name">语法糖</div><div class="desc">Java-语法糖</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> any
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 语法糖
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> Java<span class="token punctuation">-</span>语法糖
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/java/syntactic<span class="token punctuation">-</span>sugar.html
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="lambda-表达式是如何实现的" tabindex="-1"><a class="header-anchor" href="#lambda-表达式是如何实现的" aria-hidden="true">#</a> Lambda 表达式是如何实现的？</h3><div class="project-panel-custom"><a class="project project0 project-card" href="/backend/java/lambda.html#lambda-表达式是如何实现的" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-object"></span><div class="name">Lambda 表达式</div><div class="desc">Lambda 表达式是如何实现的？</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> object
  <span class="token key atrule">name</span><span class="token punctuation">:</span> Lambda 表达式
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> Lambda 表达式是如何实现的？
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/java/lambda.html<span class="token comment">#lambda-表达式是如何实现的</span>
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="什么是泛型-有什么好处" tabindex="-1"><a class="header-anchor" href="#什么是泛型-有什么好处" aria-hidden="true">#</a> 什么是泛型？有什么好处？</h3><p>  Java 泛型(generics)是 JDK5 中引入的一个新特性，允许在定义类和接口的时候使用类型参数(type parameter)。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在 JDK 5 中的新集合类框架中。</p><p><strong>泛型的好处</strong>：</p><p> ① 方便：可以提高代码的复用性。以 List 接口为例，我们可以将 String、Integer 等类型放入 List 中，如不用泛型，存放 String 类型要写一个 List 接口，存放 Integer 要写另外一个 List 接口，泛型可以很好的解决这个问题<br>  ② 安全：在泛型出现之前，通过 Object 实现的类型转换需要在运行时检查，如果类型转换出错，程序直接 GG，可能会带来毁灭性打击。而泛型的作用就是在编译时做类型检查，这无疑增加程序的安全性</p><details class="hint-container details"><summary>知识扩展</summary><p>① <strong>泛型是如何实现的</strong><br>   Java 中的泛型通过类型擦除的方式来实现，是通过语法糖的形式。在<code>.java</code> → <code>.class</code> 转换的阶段，如：将 List&lt;String&gt;擦出调整为 List。换句话说，Java 的泛型是在编译器，JVM 是不会感知到泛型的。</p><p>② <strong>类型擦除的缺点有哪些</strong><br> （1）泛型不可以重载<br> （2）泛型异常类不可以多次 catch<br> （3）泛型类中的静态变量也只有一份，不会有多份</p><p>③ <strong>List&lt;?&gt;、List&lt;Object&gt;、List 之间的区别</strong><br> （1）List&lt;?&gt;是一个未知类型的 List，而 List&lt;Object&gt;其实是任意类型的 List。可以把 List&lt;String&gt;、List&lt;Integer&gt;赋值给 List&lt;?&gt;，却不能把 List&lt;String&gt;赋值给 List&lt;Object&gt;<br> （2）可以把任何带参数的类型传递给原始类型 List，但却不能把 List&lt;String&gt;赋值给 List&lt;Object&gt;，因为会产生编译错误(不支持协变)</p><p>④ <strong>在泛型为 Integer 的 ArrayList 中存放一个 String 类型的对象</strong></p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">&quot;Java反射机制实例&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>⑤ <strong>对数组协变和泛型非协变的理解</strong><br>   所谓协变，可以简单理解为因为 Object 是 String 的父类，所以 Object[]同样是 String[]的父类，这种情况 Java 是允许的；但是对于泛型类说，List&lt;Object&gt;和 List&lt;String&gt;半毛钱关系都没有。<br> 为什么要这么设计，如果泛型允许协变，考虑个例子：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许协变，可以装进来</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行时异常</span>
</code></pre></div><p>但是为什么泛型不允许协变，而数组允许呢：<br> （1）因为数组设计之初没有泛型，为了兼容考虑，如：<code>Array.equlas(Object[], Object[])</code>方法，是时代无奈的产物<br> （2）数组也属于对象，它记录了引用实际的类型，在放入数组的时候，如果类型不一样就会报错，而不是等到拿出来的时候才发现问题，相对来说安全一点</p></details><h3 id="什么是类型擦除" tabindex="-1"><a class="header-anchor" href="#什么是类型擦除" aria-hidden="true">#</a> 什么是类型擦除？</h3><p>类型擦除是 Java 在处理泛型的一种方式，如 Java 的编译器在编译一下代码时：</p>`,44),on=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Map"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"Object"),n("span",{class:"token punctuation"},">")]),a(" map "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"HashMap"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
map`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"put"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"name"'),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token string"},'"LiHua"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
map`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"put"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"age"'),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token number"},"20"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"map = "'),a(),n("span",{class:"token operator"},"+"),a(" map"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),pn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token comment"},"// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov."),a(`
`),n("span",{class:"token class-name"},"Map"),a(" map "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"HashMap"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
map`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"put"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"name"'),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token string"},'"LiHua"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
map`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"put"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"age"'),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"Integer"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"valueOf"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"20"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"StringBuilder"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"map = "'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"append"),n("span",{class:"token punctuation"},"("),a("map"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`)])])],-1),cn=c(`<h3 id="泛型中-k-t-v-e-object-等分别代表什么含义" tabindex="-1"><a class="header-anchor" href="#泛型中-k-t-v-e-object-等分别代表什么含义" aria-hidden="true">#</a> 泛型中 K T V E ？ Object 等分别代表什么含义</h3><table><thead><tr><th>泛型</th><th>说明</th></tr></thead><tbody><tr><td><code>K</code></td><td>Key (键)</td></tr><tr><td><code>T</code></td><td>Type (Java 类)</td></tr><tr><td><code>V</code></td><td>Value (值)</td></tr><tr><td><code>E</code></td><td>Element (集合元素)</td></tr><tr><td><code>N</code></td><td>Number (数组类型)</td></tr><tr><td><code>?</code></td><td>不确定的 Java 类型 (无限制通配符类型)</td></tr></tbody></table><p>  Object 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型 T、E 等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p><details class="hint-container details"><summary>泛型示例</summary><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 示例1：使用T作为泛型类型参数，表示任何类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGenericClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> myField<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyGenericClass</span><span class="token punctuation">(</span><span class="token class-name">T</span> myField<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>myField <span class="token operator">=</span> myField<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getMyField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> myField<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例2：使用K、V作为泛型类型参数，表示键值对中的键和值的类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entries<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        entries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">V</span> value<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> key<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例3：使用E作为泛型类型参数，表示集合中的元素类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> elements<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例4：使用Object作为泛型类型参数，表示可以接受任何类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyGenericClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> myField<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyGenericClass</span><span class="token punctuation">(</span><span class="token class-name">Object</span> myField<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>myField <span class="token operator">=</span> myField<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getMyField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> myField<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></details><h3 id="泛型中上下界限定符-extends-和-super-有什么区别" tabindex="-1"><a class="header-anchor" href="#泛型中上下界限定符-extends-和-super-有什么区别" aria-hidden="true">#</a> 泛型中上下界限定符 extends 和 super 有什么区别？</h3><p><code>&lt;? extends T&gt;</code> 表示类型的上界，表示参数化类型的可能是 T 或是 T 的子类<br><code>&lt;? super T&gt;</code> 表示类型下界（Java Core 中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至 Object</p><table><thead><tr><th style="text-align:center;"><code>&lt;? extends T&gt;</code></th><th style="text-align:center;"><code>&lt;? super T&gt;</code></th></tr></thead><tbody><tr><td style="text-align:center;"><img src="`+h+'" alt="上界限定符.png" width="200" loading="lazy"></td><td style="text-align:center;"><img src="'+b+'" alt="下界限定符.png" width="200" loading="lazy"></td></tr><tr><td style="text-align:center;">如果是<code>&lt;? extends C&gt;</code>，那么只有 D 和 E 允许被传入，否则会编译报错</td><td style="text-align:center;">如果是<code>&lt;? super D&gt;</code>，那么只有 C 和 A 允许被传入，否则会编译报错</td></tr></tbody></table><h3 id="什么是-spi-和-api-有啥区别" tabindex="-1"><a class="header-anchor" href="#什么是-spi-和-api-有啥区别" aria-hidden="true">#</a> 什么是 SPI，和 API 有啥区别？</h3><p>  Java 中区分 API 和 SPI，通俗的讲：API 和 SPI 都是相对的概念，它们的差别只在语义上，API 直接被应用开发人员使用，SPI 被框架扩展人员使用。</p><p><code>API(Application Programming Interface)</code>：大多数情况下，都是实现方来制定接口并完成对接口的不同实现，调用方仅仅依赖却无权选择不同实现。</p><p><code>SPI(Service Provider Interface)</code>：如果是调用方来制定接口，实现方来针对接口来实现不同的实现。调用方来选择自己需要的实现方。</p>',11),ln={class:"hint-container details"},un=n("summary",null,"如何定义一个 SPI？",-1),rn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("test"),n("span",{class:"token punctuation"},"."),a("spi")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token import"},[n("span",{class:"token namespace"},[a("java"),n("span",{class:"token punctuation"},"."),a("util"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token class-name"},"ServiceLoader")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"App"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"ServiceLoader"),n("span",{class:"token generics"},[n("span",{class:"token punctuation"},"<"),n("span",{class:"token class-name"},"AnimalService"),n("span",{class:"token punctuation"},">")]),a(" serviceLoader "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"ServiceLoader"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"load"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"AnimalService"),n("span",{class:"token punctuation"},"."),n("span",{class:"token keyword"},"class"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 遍历实现类并调用方法"),a(`
        `),n("span",{class:"token keyword"},"for"),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"AnimalService"),a(" service "),n("span",{class:"token operator"},":"),a(" serviceLoader"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
            service`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"doSomething"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token punctuation"},"}"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),kn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("test"),n("span",{class:"token punctuation"},"."),a("spi")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"interface"),a(),n("span",{class:"token class-name"},"AnimalService"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"doSomething"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),dn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("test"),n("span",{class:"token punctuation"},"."),a("spi")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"CatServiceImpl"),a(),n("span",{class:"token keyword"},"implements"),a(),n("span",{class:"token class-name"},"AnimalService"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token annotation punctuation"},"@Override"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"doSomething"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Cat doing something..."'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),gn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("test"),n("span",{class:"token punctuation"},"."),a("spi")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"DogServiceImpl"),a(),n("span",{class:"token keyword"},"implements"),a(),n("span",{class:"token class-name"},"AnimalService"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token annotation punctuation"},"@Override"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"doSomething"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Dog doing something..."'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),mn=n("div",{class:"language-txt","data-ext":"txt"},[n("pre",{class:"language-txt"},[n("code",null,`cn.test.spi.CatServiceImpl
cn.test.spi.DogServiceImpl
`)])],-1),vn=n("div",{class:"language-txt","data-ext":"txt"},[n("pre",{class:"language-txt"},[n("code",null,`Cat doing something...
Dog doing something...
`)])],-1),hn=n("div",{class:"language-txt","data-ext":"txt"},[n("pre",{class:"language-txt"},[n("code",null,`src
└── main
    ├── java
    │   └── cn
    │       └── test
    │           └── spi
    │               ├── App.java // 程序运行入口
    │               ├── AnimalService.java  // 接口
    │               ├── CatServiceImpl.java // 接口实现类
    │               └── DogServiceImpl.java // 接口实现类
    └── resources
        └── META-INF
            └── services
                └── cn.test.spi.AnimalService
`)])],-1),bn=c(`<p><strong>SPI 的实现原理</strong>：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PREFIX</span> <span class="token operator">=</span> <span class="token string">&quot;META-INF/services/&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">// 代表被加载的类或者接口</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> service<span class="token punctuation">;</span>
    <span class="token comment">// 用于定位，加载和实例化providers的类加载器</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ClassLoader</span> loader<span class="token punctuation">;</span>
    <span class="token comment">// 创建ServiceLoader时采用的访问控制上下文</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AccessControlContext</span> acc<span class="token punctuation">;</span>
    <span class="token comment">// 缓存providers，按实例化的顺序排列</span>
    <span class="token keyword">private</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> providers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 懒查找迭代器</span>
    <span class="token keyword">private</span> <span class="token class-name">LazyIterator</span> lookupIterator<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>1️⃣ 应用程序调用<code>ServiceLoader.load</code>方法，<code>ServiceLoader.load</code>方法内先创建一个新的<code>ServiceLoader</code>，并实例化该类中的成员变量，包括：<br>   loader(ClassLoader 类型，类加载器)<br>   acc(AccessControlContext 类型，访问控制器)<br>   providers(LinkedHashMap 类型，用于缓存加载成功的类)<br>   lookupIterator(实现迭代器功能)</p><p>2️⃣ 应用程序通过迭代器接口获取对象实例<br> ① <code>ServiceLoader</code>先判断成员变量<code>providers</code>对象中(LinkedHashMap 类型)是否有缓存实例对象，如果有缓存，直接返回。</p><p>② 如果没有缓存，执行类的装载：<br> ⅰ 读取<code>META-INF/services/</code>下的配置文件，获得所有能被实例化的类的名称<br> ⅱ 通过反射方法<code>Class.forName()</code>加载类对象，并用<code>instance()</code>方法将类实例化<br> ⅲ 把实例化后的类缓存到<code>providers</code>对象中(LinkedHashMap 类型）<br> ⅳ 然后返回实例对象</p><p><strong>SPI 的应用场景</strong>：<br> 概括地说，适用于：调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略。比较常见的例子：<br>  数据库驱动加载接口实现类的加载<br>  JDBC 加载不同类型数据库的驱动<br>  日志门面接口实现类加载<br>  SLF4J 加载不同提供商的日志实现类</p>`,6),yn=c(`<h3 id="反射-了解" tabindex="-1"><a class="header-anchor" href="#反射-了解" aria-hidden="true">#</a> 反射(了解)</h3><p>  在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>  反射的好处是可以提升程序的灵活性和扩展性，比较容易在运行期间干很多事情。但是带来的问题更多，主要有：<br>    ① 代码可读性及可维护性<br>    ② 反射代码执行的性能低<br>    ③ 反射破坏了封装性<br>   所以，在业务代码中应该尽量避免使用反射，但是也要读懂中间件、框架中的反射代码。在有些场景下，要知道可以使用反射解决部分问题。</p><p><strong>获取 Class 对象的 3 种方法</strong>：<br> ① 调用某个对象的 getClass()方法</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> clzz <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>② 调用某个类的 class 属性来获取该类对应的 Class 对象</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre></div><p>③ 使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 最常用</span>
<span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类的全路径&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><hr><p><strong>扩展</strong>：为什么反射慢？<br> ① 由于反射涉及动态解析类型，因此不能执行某些 Java 虚拟机优化，如 JIT 优化<br> ② 在使用反射时，参数需要包装成 Object[]类型，但是真正方法执行的时候，有需要再拆包成真正的类型，这些动作不仅消耗时间，而且过程中也会产生很多对象，对象一多就容易导致 GC，GC 会导致应用变慢<br> ③ 反射调用方法时会从方法数组中遍历查找，并且会检查可见性，这些动作都是耗时的<br> ④ 不仅方法的可见性要做检查，参数也需要做很多额外的检查</p><h3 id="通过反射如何创建对象" tabindex="-1"><a class="header-anchor" href="#通过反射如何创建对象" aria-hidden="true">#</a> 通过反射如何创建对象？</h3><blockquote><p>① 通过 Class 类的 newInstance()方法<br> ② 通过 Constructor 的 newInstance(Object[] args)方法</p></blockquote><p><strong>代码示例</strong>：</p>`,14),fn={class:"hint-container details"},xn=n("summary",null,"通过反射如何创建对象(代码示例)",-1),wn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("bt66")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token import"},[n("span",{class:"token namespace"},[a("java"),n("span",{class:"token punctuation"},"."),a("lang"),n("span",{class:"token punctuation"},"."),a("reflect"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token class-name"},"Constructor")]),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token import"},[n("span",{class:"token namespace"},[a("java"),n("span",{class:"token punctuation"},"."),a("lang"),n("span",{class:"token punctuation"},"."),a("reflect"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token class-name"},"Field")]),n("span",{class:"token punctuation"},";"),a(`
`),n("span",{class:"token keyword"},"import"),a(),n("span",{class:"token import"},[n("span",{class:"token namespace"},[a("java"),n("span",{class:"token punctuation"},"."),a("lang"),n("span",{class:"token punctuation"},"."),a("reflect"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token class-name"},"InvocationTargetException")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token doc-comment comment"},[a(`/**
 * `),n("span",{class:"token keyword"},"@author"),a(` zhangxiaojun
 */`)]),a(`
`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"App"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token keyword"},"throws"),a(),n("span",{class:"token class-name"},"ClassNotFoundException"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"NoSuchMethodException"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"InstantiationException"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"IllegalAccessException"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token class-name"},"InvocationTargetException"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token comment"},"// 调用某个对象的 getClass() 方法"),a(`
        `),n("span",{class:"token class-name"},"Person"),a(" person "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"Class"),a(" clazz_1 "),n("span",{class:"token operator"},"="),a(" person"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"getClass"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"clazz_1 = "'),a(),n("span",{class:"token operator"},"+"),a(" clazz_1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 调用某个类的 class 属性来获取该类对应的 Class 对象"),a(`
        `),n("span",{class:"token class-name"},"Class"),a(" clazz_2 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},"."),n("span",{class:"token keyword"},"class"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"clazz_2 = "'),a(),n("span",{class:"token operator"},"+"),a(" clazz_2"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 使用 Class 类中的 forName() 静态方法"),a(`
        `),n("span",{class:"token class-name"},"Class"),a(" clazz_3 "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token class-name"},"Class"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"forName"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"cn.bt66.Person"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"clazz_3 = "'),a(),n("span",{class:"token operator"},"+"),a(" clazz_3"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 比较"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"clazz_1 == clazz_2 : "'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token punctuation"},"("),a("clazz_1 "),n("span",{class:"token operator"},"=="),a(" clazz_2"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"clazz_1 == clazz_3 : "'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token punctuation"},"("),a("clazz_1 "),n("span",{class:"token operator"},"=="),a(" clazz_3"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 通过 Class 类的 newInstance()方法"),a(`
        `),n("span",{class:"token class-name"},"Person"),a(" p "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},")"),a(" clazz_1"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"newInstance"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        p`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"setAge"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        p`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"setName"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Zhang"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"String"),a(" pString "),n("span",{class:"token operator"},"="),a(" p"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"pString = "'),a(),n("span",{class:"token operator"},"+"),a(" pString"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`

        `),n("span",{class:"token comment"},"// 通过 Constructor 的 newInstance(Object[] args)方法"),a(`
        `),n("span",{class:"token class-name"},"Constructor"),a(" con "),n("span",{class:"token operator"},"="),a(" clazz_1"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"getConstructor"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"Person"),a(" o "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},")"),a(" con"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"newInstance"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        o`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"setAge"),n("span",{class:"token punctuation"},"("),n("span",{class:"token number"},"20"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        o`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"setName"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Li"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"String"),a(" oString "),n("span",{class:"token operator"},"="),a(" o"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"oString = "'),a(),n("span",{class:"token operator"},"+"),a(" oString"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),jn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"package"),a(),n("span",{class:"token namespace"},[a("cn"),n("span",{class:"token punctuation"},"."),a("bt66")]),n("span",{class:"token punctuation"},";"),a(`

`),n("span",{class:"token doc-comment comment"},[a(`/**
 * `),n("span",{class:"token keyword"},"@author"),a(` zhangxiaojun
 */`)]),a(`
`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Person"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token class-name"},"String"),a(" name"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token keyword"},"int"),a(" age"),n("span",{class:"token punctuation"},";"),a(`

    `),n("span",{class:"token doc-comment comment"},`/**
     * 无参构造函数
     * 注意：当没有有参构造函数时，会隐式声明
     */`),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),a(" name"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("name "),n("span",{class:"token operator"},"="),a(" name"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token class-name"},"Person"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),a(" name"),n("span",{class:"token punctuation"},","),a(),n("span",{class:"token keyword"},"int"),a(" age"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("name "),n("span",{class:"token operator"},"="),a(" name"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("age "),n("span",{class:"token operator"},"="),a(" age"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token class-name"},"String"),a(),n("span",{class:"token function"},"getName"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"return"),a(" name"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"setName"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),a(" name"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("name "),n("span",{class:"token operator"},"="),a(" name"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"int"),a(),n("span",{class:"token function"},"getAge"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"return"),a(" age"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"setAge"),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),a(" age"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("age "),n("span",{class:"token operator"},"="),a(" age"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"eat"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Eating！"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token annotation punctuation"},"@Override"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token class-name"},"String"),a(),n("span",{class:"token function"},"toString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"return"),a(),n("span",{class:"token string"},'"Name:"'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("name "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},'","'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token string"},'"Age:"'),a(),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token keyword"},"this"),n("span",{class:"token punctuation"},"."),a("age"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),Sn=n("div",{class:"language-text","data-ext":"text"},[n("pre",{class:"language-text"},[n("code",null,`clazz_1 = class cn.bt66.Person
clazz_2 = class cn.bt66.Person
clazz_3 = class cn.bt66.Person
clazz_1 == clazz_2 : true
clazz_1 == clazz_3 : true
pString = Name:Zhang,Age:10
oString = Name:Li,Age:20
`)])],-1),_n=c(`<hr><p><strong>反射更多介绍</strong>：</p><div class="project-panel-custom"><a class="project project0 project-card" href="/backend/java/java-reflect.html" rel="noopener noreferrer" target="_blank"><span class="image font-icon icon iconfont better-structure"></span><div class="name">反射</div><div class="desc">Java-反射</div></a><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">-</span> <span class="token key atrule">icon</span><span class="token punctuation">:</span> structure
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 反射
  <span class="token key atrule">desc</span><span class="token punctuation">:</span> Java<span class="token punctuation">-</span>反射
  <span class="token key atrule">link</span><span class="token punctuation">:</span> /backend/java/java<span class="token punctuation">-</span>reflect.html
  <span class="token key atrule">target</span><span class="token punctuation">:</span> _blank
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h3 id="java-中创建对象有哪些种方式" tabindex="-1"><a class="header-anchor" href="#java-中创建对象有哪些种方式" aria-hidden="true">#</a> Java 中创建对象有哪些种方式？</h3><p>① 使用 new 关键字<br> ② 使用反射机制<br> ③ 使用 clone 方法<br> ④ 使用反序列化<br> ⑤ 使用方法句柄<br> ⑥ 使用 Unsafe 分配内存</p><h3 id="如何理解面向对象和面向过程" tabindex="-1"><a class="header-anchor" href="#如何理解面向对象和面向过程" aria-hidden="true">#</a> 如何理解面向对象和面向过程？</h3><blockquote><p>① 面向过程把问题分解成一个一个步骤，每个步骤用函数实现，依次调用。<br> ② 面向对象将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p></blockquote><details class="hint-container details"><summary>知识扩展：面向对象的五大基本原则？</summary><p>五大基本原则：<br>  单一职责原则(Single-Responsibility Principle)：一个类最好只做一件事<br>  开放封闭原则(Open-Closed principle)：对扩展开放、对修改封闭<br>  里氏替换原则(Liskov-Substituion Principle)：子类必须能够替换其基类<br>  依赖倒置原则(Dependency-Inversion Principle)：程序要依赖于抽象接口，而不是具体的实现<br>  接口隔离原则(Interface-Segregation Principle)：使用多个小的专门的接口，而不要使用一个大的总接口</p></details><h3 id="面向对象的特征-了解" tabindex="-1"><a class="header-anchor" href="#面向对象的特征-了解" aria-hidden="true">#</a> 面向对象的特征(了解)</h3><p><strong>面向对象的特征</strong>：<u class="under-dot">封装、继承、多态、抽象</u></p><blockquote><p><strong>封装</strong>：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，但提供对外访问的接口。由于隐藏了实现细节，同时又可以对属性赋值进行校验，所以增加了安全性；另外封装的各种方法，可以任意调用，不需要关心实现细节，提高了代码复用性。</p><hr><p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p><hr><p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力（<mark>多态是父类行为的多面性。---子类重写造成的</mark>）</p><hr><p><strong>抽象</strong>：表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用此关键字修饰类时，此类就不能被实例化，这里可以看出，抽象类(接口)就是为了继承而存在的。</p></blockquote><h3 id="java-中的多态三个条件" tabindex="-1"><a class="header-anchor" href="#java-中的多态三个条件" aria-hidden="true">#</a> Java 中的多态三个条件？</h3><blockquote><p>① 要有继承；<br> ② 要有重写；<br> ③ 必须通过父类的对象调用(即：父类的引用指向子类的对象 <code>Animal cat = new Cat();</code>)。</p></blockquote><h3 id="解释一下向上转型与向下转型" tabindex="-1"><a class="header-anchor" href="#解释一下向上转型与向下转型" aria-hidden="true">#</a> 解释一下向上转型与向下转型</h3><blockquote><p>向上转型：通过子类对象 (小范围) 实例化父类对象 (大范围)， 这种属于自动转换<br> 向下转型：通过父类对象 (大范围) 实例化子类对象 (小范围)， 这种属于强制转换</p></blockquote><p><strong>代码示例</strong>：</p>`,17),An={class:"hint-container details"},qn=n("summary",null,"展开查看",-1),Jn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Animal"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Animal makes sound"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Dog"),a(),n("span",{class:"token keyword"},"extends"),a(),n("span",{class:"token class-name"},"Animal"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Dog barks"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"playFetch"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Dog plays fetch"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Main"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"Dog"),a(" dog "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"Dog"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"Animal"),a(" animal "),n("span",{class:"token operator"},"="),a(" dog"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},"// 向上转型"),a(`
        animal`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},'// 输出 "Dog barks"'),a(`
        `),n("span",{class:"token comment"},"// animal.playFetch(); 编译错误，无法访问子类新增的方法"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),Cn=n("div",{class:"language-java","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Animal"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Animal makes sound"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Dog"),a(),n("span",{class:"token keyword"},"extends"),a(),n("span",{class:"token class-name"},"Animal"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Dog barks"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`

    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"playFetch"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"Dog plays fetch"'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Cat"),a(),n("span",{class:"token keyword"},"extends"),a(),n("span",{class:"token class-name"},"Animal"),a(),n("span",{class:"token punctuation"},"{"),a(),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Main"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token class-name"},"Animal"),a(" animal "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token keyword"},"new"),a(),n("span",{class:"token class-name"},"Dog"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"if"),a(),n("span",{class:"token punctuation"},"("),a("animal "),n("span",{class:"token keyword"},"instanceof"),a(),n("span",{class:"token class-name"},"Dog"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
            `),n("span",{class:"token class-name"},"Dog"),a(" dog "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"Dog"),n("span",{class:"token punctuation"},")"),a(" animal"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},"// 向下转型"),a(`
            dog`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},'// 输出 "Dog barks"'),a(`
            dog`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"playFetch"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},'// 输出 "Dog plays fetch"'),a(`
        `),n("span",{class:"token punctuation"},"}"),a(`

        `),n("span",{class:"token class-name"},"Cat"),a(),n("span",{class:"token class-name"},"Cat"),a(),n("span",{class:"token operator"},"="),a(),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"Cat"),n("span",{class:"token punctuation"},")"),a(" animal"),n("span",{class:"token punctuation"},";"),a(),n("span",{class:"token comment"},"// ClassCastException：Dog cannot be cast to Cat"),a(`
        `),n("span",{class:"token class-name"},"Cat"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"sound"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])])],-1),In=c('<blockquote><p>⭐️ 向上转型(Upcasting)：将一个子类的实例赋值给其父类的引用变量。这个操作是安全的，因为子类继承了父类的所有属性和方法。在向上转型中，只能访问父类中定义的属性和方法，无法访问子类新增的属性和方法。<br> ⭐️ 向下转型(Downcasting)：将一个父类的引用变量转换为其子类的引用变量。这个操作需要显式地将父类的引用转换为子类的引用，因为编译器无法确定父类引用所指向的对象是否是子类的实例。如果转换不正确，会引发 ClassCastException 异常。</p></blockquote><h3 id="final-关键字作用" tabindex="-1"><a class="header-anchor" href="#final-关键字作用" aria-hidden="true">#</a> final 关键字作用？</h3><blockquote><p>① final 修饰变量，表示该变量为常量，只能赋值一次;<br> ② final 修饰方法，表示该方法不能被重写;<br> ③ final 修饰类，表示该类不能被继承。</p></blockquote><h3 id="说一下-java-中类的四种封装" tabindex="-1"><a class="header-anchor" href="#说一下-java-中类的四种封装" aria-hidden="true">#</a> 说一下 java 中类的四种封装？</h3><table><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:center;">类内部</th><th style="text-align:center;">同一个包中</th><th style="text-align:center;">子类</th><th style="text-align:center;">任何地方</th></tr></thead><tbody><tr><td style="text-align:left;">private</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">default</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">protected</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">public</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td></tr></tbody></table><h3 id="java-中如何实现继承-java-中能实现多重继承吗" tabindex="-1"><a class="header-anchor" href="#java-中如何实现继承-java-中能实现多重继承吗" aria-hidden="true">#</a> java 中如何实现继承？java 中能实现多重继承吗？</h3><blockquote><p>📖 继承概念：继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。<br> 📖 如何实现继承：使用 extends 关键字;一个子类只有一个直接父类。</p></blockquote><h3 id="为什么-java-不支持多继承" tabindex="-1"><a class="header-anchor" href="#为什么-java-不支持多继承" aria-hidden="true">#</a> 为什么 Java 不支持多继承？</h3><blockquote><p>  因为如果要实现多继承，就会像 C++ 中一样，存在<mark>菱形继承</mark>的问题，C++ 为了解决菱形继承问题，又引入了<mark>虚继承</mark>。而经过分析，发现我们需要使用多继承的情况并不多，所以在 Java 中，不允许多继承，即一个类不允许继承多个父类。<br>   在 Java 8 之前，接口中是不能有方法的实现的，所以一个类同时实现多个接口的话，也不会出现 C++ 中歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中。但是，Java8 中支持了默认函数(default method)，即接口中可以定义一个有方法体的方法了。<br>   而又因为 Java 支持同时实现多个接口，这就相当于通过 implements 就可以从多个接口中继承到多个方法。但是 Java8 中为了避免菱形继承的问题，在实现的多个接口中如果有相同方法，就会要求该类必须重写这个方法。</p></blockquote><details class="hint-container details"><summary>知识扩展</summary><p>① <strong>菱形继承问题</strong><br>   Java 创始人詹姆斯·高斯林(James Gosling)曾经回答过：<u class="under-wave">&quot;Java 之所以不支持一个类继承多个类，主要是因为在设计之初我们听取了来自 C++和 Objective-C 等阵营的人的意见。因为多继承会产生很多歧义问题。&quot;</u><br>   这里提到的歧义，其实就是 C++ 因为支持多继承之后带来的菱形继承问题。</p><figure><img src="'+y+`" alt="菱形问题.png" width="600" tabindex="0" loading="lazy"><figcaption>菱形问题.png</figcaption></figure><p>  结合上图，假设我们有类 B 和类 C，它们都继承了相同的类 A，另外还有类 D，它通过多重继承的机制继承了类 B 和类 C。此时 D 就具有了 B 和 A 分别的<code>display()</code>方法，那么编译器无法确定应该调用哪个父类的方法，从而产生歧义。</p><p>  因为这样的继承关系的形状类似于菱形，因此被称为菱形继承问题。而 C++ 为了解决这个问题，又引入了<mark>虚继承</mark>。</p><p>  所以，在 Java 中，不允许声明多继承，即一个类不允许继承多个父类。但是 Java 允许&quot;实现多继承&quot;，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现(Java 8 之前)，这就避免了 C++ 中多继承的歧义问题。</p><p>② <strong>Java8 中的多继承</strong><br>   Java 不支持多继承，但是可以支持多实现，也就是说，同一个类可以同时实现多个接口。<br>   我们知道，在 Java8 之前，接口中是不能有方法实现的，所以一个类同时实现多个接口的话，也不会出现 C++ 中的歧义问题。因为所有方法都没有方法体，真正的实现还是在子类中的。<br>   但是，在 Java8 中支持了默认函数(default method)，即接口中可以定义一个有方法体的方法。而又因为 Java 支持同时实现多个接口，这就相当于通过 implements 就可以从多个接口继承到多个方法，这就相当于变相支持了多继承。假如被实现的类中有同名方法，实现类中就必须进行重写，否则编译报错。</p><p>下面通过代码配合注释可以更直观的理解上面的内容：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Java 8 支持默认函数，实现类可以重写，也可以不重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Mammal-Run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">,</span> <span class="token class-name">Mammal</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 被实现的类中都存在同名方法，必须重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Dog-eat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 相当于 Java 8 以前 实现类必须重写</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Dog-breath&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出</span>
<span class="token class-name">Dog</span><span class="token operator">-</span>eat
<span class="token class-name">Mammal</span><span class="token operator">-</span><span class="token class-name">Run</span>
<span class="token class-name">Dog</span><span class="token operator">-</span>breath
</code></pre></div><p>  所以可以看到，Java 并没有帮我们解决多继承的歧义问题，而是把这个问题留给开发者，通过重写方法的方式自己解决。</p></details><h3 id="请解释一下-this-与-super-关键字" tabindex="-1"><a class="header-anchor" href="#请解释一下-this-与-super-关键字" aria-hidden="true">#</a> 请解释一下 this 与 super 关键字？</h3><blockquote><p>this: ① 本类的对象；② 本类的构造函数。<br> super: ① 父类的对象；② 父类的构造函数。</p></blockquote><h3 id="说一下类与对象的区别" tabindex="-1"><a class="header-anchor" href="#说一下类与对象的区别" aria-hidden="true">#</a> 说一下类与对象的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类是具有相同属性和行为的一个群体，而对象则是这个群体中的一个个体;我们在使用时，先设计类，在创建对象，也就是说，类是创建对象的模板。</p></div><h3 id="类与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#类与抽象类的区别" aria-hidden="true">#</a> 类与抽象类的区别</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>类和抽象类的本质是一样的，都是类;但是抽象类一般是以基类的身份出现的，服务于子类的，可以包含抽象方法，普通类不可以，换句话说，抽象类可以不含抽象方法，但含抽象方法的类一定是抽象类。抽象类不可以被实例化，而普通类则可以。</p></div><h3 id="什么是接口" tabindex="-1"><a class="header-anchor" href="#什么是接口" aria-hidden="true">#</a> 什么是接口？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>接口是一系列方法的声明，是一些抽象方法的集合，是对类的行为定制的一套标准、一套规范、一套约束;
</code></pre></div><h3 id="接口中能定义的主要成员有哪些" tabindex="-1"><a class="header-anchor" href="#接口中能定义的主要成员有哪些" aria-hidden="true">#</a> 接口中能定义的主要成员有哪些？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>属性和方法;
</code></pre></div><h3 id="接口和抽象类的区别是什么-必会" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的区别是什么-必会" aria-hidden="true">#</a> 接口和抽象类的区别是什么？(必会)</h3><p>① <strong>实现</strong>：抽象类的子类使用<code>extends</code>来继承；接口必须使用<code>implements</code>来实现接口。<br> ② <strong>构造函数</strong>：抽象类可以有构造函数；接口不能有。<br> ③ <strong>main 方法</strong>：抽象类可以有 main 方法，并且我们可以允许它；接口不能有 main 方法。<br> ④ <strong>实现数量</strong>：类可以实现很多个接口；但是只能继承一个抽象类。<br> ⑤ <strong>访问修饰符</strong>：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h3 id="抽象类与接口的区别" tabindex="-1"><a class="header-anchor" href="#抽象类与接口的区别" aria-hidden="true">#</a> 抽象类与接口的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>相同点:不能实例化;
不同点:
    ①定义抽象类用abstract关键字，定义接口用interface;
    ②抽象类的本质为类，接口的本质是给类的行为定制规范;
    ③一个类只能有一个父类，但可以实现多个接口;
    ④抽象类中除了有抽象方法外，还可以有普通类中有的所有类成员，但接口中只能有抽象方法与属性(jdk8做了扩展，可以有默认方法与静态方法)
    ⑤访问权限：抽象类(protected -- jdk1.8之前，default/public -- jdk1.8)
    接口(public -- jdk1.8之前，public/default -- jdk1.8)
</code></pre></div><h3 id="说一下-break-与-continue-作用" tabindex="-1"><a class="header-anchor" href="#说一下-break-与-continue-作用" aria-hidden="true">#</a> 说一下 break 与 continue 作用</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>break</code>语句有两个作用：一是跳出当前循环体，执行循环之外的语句；二是跳出 switch 语句，而 continue 语句表示中止本次循环，继续执行下一次循环。</p></div><h3 id="说一下值传递与引用传递" tabindex="-1"><a class="header-anchor" href="#说一下值传递与引用传递" aria-hidden="true">#</a> 说一下值传递与引用传递</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  Java 数据类型包括基本数据类型和引用数据类型，其中基本数据类型使用值传递，实质是传递数值的副本，当调用使用值传递交换数据时，原数据不会发生改变；而引用数据类型使用引用传递，传递的实质是引用的地址，当调用引用传递交换数据时，因为地址指向变了，所以原数据发生改变。</p></div><h3 id="如何获取数组元素的数量" tabindex="-1"><a class="header-anchor" href="#如何获取数组元素的数量" aria-hidden="true">#</a> 如何获取数组元素的数量</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>数组-属性:length
字符串-方法:length()
</code></pre></div><h3 id="写出数组排序-冒泡法排序" tabindex="-1"><a class="header-anchor" href="#写出数组排序-冒泡法排序" aria-hidden="true">#</a> 写出数组排序(冒泡法排序)</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  冒泡排序就是依次比较相邻的两个数，以升序为例，就是将小数放前面，大数放后面；假设需要排序的序列个数为 n，则需要经过 n-1 轮，最终完成排序。在第一轮中，比较的次数是 n-1 次，之后每轮次数减一。</p></div><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token comment">// 临时变量</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 需要比较n-1轮</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 每轮需要比较的次数逐轮减少1次</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 相邻元素比较，符合条件交换</span>
                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="说一下你知道的-java-中常见的包" tabindex="-1"><a class="header-anchor" href="#说一下你知道的-java-中常见的包" aria-hidden="true">#</a> 说一下你知道的 java 中常见的包</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang:系统基础类库。比如:String、Math、System、Thread等等;
java.util:Java工具类，包含对集合的操作、日期时间设置等等各种使用工具类;
java.io:io流文件的读写操作;
java.net:为实现网络应用程序而提供的类;
java.awt/javax.swing:用于窗体开发的类;
java.sql:数据库操作类库。
</code></pre></div><h3 id="final-、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final-、finally、finalize-的区别" aria-hidden="true">#</a> final 、finally、finalize 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>final三个作用:修饰变量、方法、类;
finally是java的一种异常处理机制，通常放在try、catch后面，正常情况下此结构体使代码[总会执行]，(虚拟机终止，语句块终止、打断其实不会执行)而不管异常是否发生。
finalize是java.lang.Object类中的一个方法，用于垃圾回收机制中资源的释放。
</code></pre></div><h3 id="说一下-java-中的异常分类" tabindex="-1"><a class="header-anchor" href="#说一下-java-中的异常分类" aria-hidden="true">#</a> 说一下 JAVA 中的异常分类</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>异常包括:Error和Exception
Exception:RuntimeException(运行时异常)和CheckedException(检查时异常)
</code></pre></div><figure><img src="`+f+`" alt="异常分类.jpg" width="550" tabindex="0" loading="lazy"><figcaption>异常分类.jpg</figcaption></figure><h3 id="java-中异常父类-根父类-是哪一个" tabindex="-1"><a class="header-anchor" href="#java-中异常父类-根父类-是哪一个" aria-hidden="true">#</a> JAVA 中异常父类(根父类)是哪一个？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>java.lang.Throwable
</code></pre></div><h3 id="说出常见的几个运行时异常-5-个以上" tabindex="-1"><a class="header-anchor" href="#说出常见的几个运行时异常-5-个以上" aria-hidden="true">#</a> 说出常见的几个运行时异常？(5 个以上)</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>运行时异常(RuntimeException):
    NullPointerException(空指针异常)
    ClassCastException(类型转换异常)
    IndexOutOfBoundsException(角标越界异常)
    ArithmeticException(数学运算异常)  /əˈrɪθmətɪk/
    IllegalArgumentException(不合法参数异常)
    SystemException(系统异常)
    NumberFormatException(数字格式化异常)

检查时异常(CheckedExcption):
 IOException(IO异常)
 ClassNotFoundException(类没找到异常)
 FileNotFoundException(文件找不到异常)
 SQLException(SQL异常)
</code></pre></div><h3 id="throw-与-throws-区别" tabindex="-1"><a class="header-anchor" href="#throw-与-throws-区别" aria-hidden="true">#</a> throw 与 throws 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>throw关键字表示手动抛异常
throws关键字表示声明异常(在定义方法，同时给方法声明一个异常)
</code></pre></div><h3 id="异常处理的基本结构" tabindex="-1"><a class="header-anchor" href="#异常处理的基本结构" aria-hidden="true">#</a> 异常处理的基本结构？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① try / catch
② try / catch / finally
③ try / finally
</code></pre></div><h3 id="jdk-1-8-新特性" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-新特性" aria-hidden="true">#</a> JDK 1.8 新特性</h3><p>① <strong>Lambda 表达式</strong><br>   允许把函数作为一个方法的参数。</p><p>② <strong>方法引用</strong><br>   方法引用允许直接引用已有 Java 类或对象的方法或构造方法。</p><p>③ <strong>函数式接口</strong><br>   有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为 Lambda 表达式。通常函数式接口上会添加<code>@FunctionalInterface</code>注解。</p><p>④ <strong>接口允许定义默认方法和静态方法</strong><br>   从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法。</p><p>⑤ <strong>Stream API</strong><br>   新添加的 Stream API（java.util.stream）把真正的函数式编程风格引入到 Java 中。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。</p><p>⑥ <strong>日期/时间类改进</strong><br>   之前的 JDK 自带的日期处理类非常不方便，我们处理的时候经常是使用的第三方工具包，比如 commons-lang 包等。不过 JDK8 出现之后这个改观了很多，比如日期时间的创建、比较、调整、 格式化、时间间隔等。这些类都在 java.time 包下，LocalDate/LocalTime/LocalDateTime。</p><p>⑦ <strong>Optional 类</strong><br>   Optional 类是一个可以为 null 的容器对象。如果值存在则 isPresent()方法会返 回 true，调用 get()方法会返回该对象。</p><p>⑧ <strong>Java 8 Base64 实现</strong><br>   Java 8 内置了 Base64 编码的编码器和解码器。</p><h2 id="集合-⭐️" tabindex="-1"><a class="header-anchor" href="#集合-⭐️" aria-hidden="true">#</a> 集合 ⭐️</h2><h3 id="栈与队列的区别" tabindex="-1"><a class="header-anchor" href="#栈与队列的区别" aria-hidden="true">#</a> 栈与队列的区别？</h3><blockquote><p>队列：先进先出(FIFO)，它只允许在前端进行删除操作，在后端进行插入操作。<br> 栈：先进后出，它只能在一端进行插入和删除操作。</p></blockquote><h3 id="顺序存储结构与链式存储结构的优缺点" tabindex="-1"><a class="header-anchor" href="#顺序存储结构与链式存储结构的优缺点" aria-hidden="true">#</a> 顺序存储结构与链式存储结构的优缺点</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>顺序存储结构:
 优:一是节省存储空间;二是访问速度快;
 缺:进行插入、删除元素时效率低。

链式存储结构:
 优:进行插入、删除元素时效率高;
 缺:一是对空间的占用比较大;二是访问速度慢。
</code></pre></div><h3 id="数据查找-遍历、二分查找-说一下二分查找的条件" tabindex="-1"><a class="header-anchor" href="#数据查找-遍历、二分查找-说一下二分查找的条件" aria-hidden="true">#</a> 数据查找：遍历、二分查找，说一下二分查找的条件</h3><p>必须是有序数组</p><h3 id="java-中常见的三种集合是哪三种" tabindex="-1"><a class="header-anchor" href="#java-中常见的三种集合是哪三种" aria-hidden="true">#</a> java 中常见的三种集合是哪三种？</h3><p><code>List、Set、Map</code></p><h3 id="list-与-set-的区别" tabindex="-1"><a class="header-anchor" href="#list-与-set-的区别" aria-hidden="true">#</a> List 与 Set 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>List集合元素按进入先后有序保存，可重复;
Set集合仅接收一次，无序，不可重复;
</code></pre></div><h3 id="arraylist-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-linkedlist-的区别" aria-hidden="true">#</a> ArrayList 与 LinkedList 的区别</h3><p>  ArrayList 是基于数组来实现的，比较节省存储空间，在查询时访问元素速度快效率高，但在进行修改操作时性能差；<br>   LinkedList 是基于双向链表来实现的，在进行修改操作时性能好，效率高，但对空间的占用大，在查询时访问速度慢。</p><h3 id="arraylist-与-vector-区别" tabindex="-1"><a class="header-anchor" href="#arraylist-与-vector-区别" aria-hidden="true">#</a> ArrayList 与 Vector 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>两者都是List集合，但ArrayList是线程非安全的，Vector是线程安全的。
</code></pre></div><h3 id="hashmap-与-hashtable-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-区别" aria-hidden="true">#</a> HashMap 与 Hashtable 区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>HashMap集合中的key可以为null，值也可以是null，(只能由一个key为null)，它是线程非安全的;
Hashtable集合中的key-value都不能为空，它是线程安全的。
</code></pre></div><h3 id="hashmap-与-treemap-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-与-treemap-区别" aria-hidden="true">#</a> HashMap 与 TreeMap 区别？</h3><p>TreeMap 相对 HashMap，多了一个排序的功能</p><h3 id="集合迭代器的接口" tabindex="-1"><a class="header-anchor" href="#集合迭代器的接口" aria-hidden="true">#</a> 集合迭代器的接口？</h3><p><code>iterator</code></p><h3 id="遍历-list-有哪些不同的方式" tabindex="-1"><a class="header-anchor" href="#遍历-list-有哪些不同的方式" aria-hidden="true">#</a> 遍历 List 有哪些不同的方式？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>for循环、增强for循环、iterator迭代器
</code></pre></div><h3 id="hashset-和-treeset-的区别" tabindex="-1"><a class="header-anchor" href="#hashset-和-treeset-的区别" aria-hidden="true">#</a> HashSet 和 TreeSet 的区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>TreeSet相对于HashSet，多了一个排序的功能;
</code></pre></div><h3 id="collection-与-collections-的区别" tabindex="-1"><a class="header-anchor" href="#collection-与-collections-的区别" aria-hidden="true">#</a> Collection 与 Collections 的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>Collection是集合的父接口，Collections是集合工具类。
</code></pre></div><h3 id="什么是-properties-类" tabindex="-1"><a class="header-anchor" href="#什么是-properties-类" aria-hidden="true">#</a> 什么是 Properties 类？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>该类主要用于读取 Java 的配置文件，不同的编程语言有自己所支持的配置文件，配置文件中很多变量是经常改变的，为了方便用户的配置，能让用户够脱离程序本身去修改相关的变量设置。就像在 Java 中，其配置文件常为*.properties 文件，是以键值对的形式进行参数配置的。</p></div><h3 id="java-中有几种类型的流" tabindex="-1"><a class="header-anchor" href="#java-中有几种类型的流" aria-hidden="true">#</a> JAVA 中有几种类型的流？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>①数据单位:字节流、字符流
②流向:输入流、输出流
③角色:节点流、处理流
</code></pre></div><h3 id="字节流与字符流的区别" tabindex="-1"><a class="header-anchor" href="#字节流与字符流的区别" aria-hidden="true">#</a> 字节流与字符流的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>对于文本文件(.txt，.java，.c，.c++)，使用字符流处理;
对于非文本文件(.jpg，.mp3，.mp4，.avi，.doc，.ppt)，使用字节流处理。
</code></pre></div><h3 id="bufferedreader-流的作用" tabindex="-1"><a class="header-anchor" href="#bufferedreader-流的作用" aria-hidden="true">#</a> BufferedReader 流的作用？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>BufferedReader 属于输入字符缓冲流，缓冲流是一种装饰器类，目的是让原字节流、字符流新增缓冲的功能。缓冲流作用是把数据先写入内存缓冲区，等缓冲区满了，再把数据写到文件里。读内存比读硬盘速度快很多倍，所以这样效率就大大提高了。</p></div><h3 id="什么是序列化-什么是反序列化" tabindex="-1"><a class="header-anchor" href="#什么是序列化-什么是反序列化" aria-hidden="true">#</a> 什么是序列化，什么是反序列化？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>序列化:将对象转为流，用来存贮或者网络传输;
反序列化:将流中的数据转为对象。
</code></pre></div><h3 id="什么是-xml" tabindex="-1"><a class="header-anchor" href="#什么是-xml" aria-hidden="true">#</a> 什么是 XML？</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>XML 是可扩展标记语言(eXtensible [/ɪkˈstensəbl/] Markup Language)的简称。它是一个纯文本格式的文件，相对于文本，文档的内容一般用标签包裹;XML 在项目中主要用来存放配置信息。</p></div><h2 id="多线程-⭐️" tabindex="-1"><a class="header-anchor" href="#多线程-⭐️" aria-hidden="true">#</a> 多线程 ⭐️</h2><h3 id="什么是线程、什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是线程、什么是进程" aria-hidden="true">#</a> 什么是线程、什么是进程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>进程:运行中的程序称为进程;
线程:进程中的一条执行流(进程中可以同时由多个执行流-多线程，多线程的应用程序，程序可以并行执行多个任务，相对单线程应用程序，效率要高很多)
&gt; 线程是进程的子集，一个进程可以有多个线程
&gt; 额外知识理解:
 并行:多个CPU同时执行多个任务，如:多个人同时做不同的事
 并发:一个CPU同时执行多个任务，如:多个人做同一件事
</code></pre></div><h3 id="如何创建一个线程" tabindex="-1"><a class="header-anchor" href="#如何创建一个线程" aria-hidden="true">#</a> 如何创建一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① 继承于Thread类
② 实现Runnable接口
③ 实现Callable接口
④ 使用线程池
</code></pre></div><h3 id="如何启动一个线程" tabindex="-1"><a class="header-anchor" href="#如何启动一个线程" aria-hidden="true">#</a> 如何启动一个线程？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>调用start()方法;
</code></pre></div><h3 id="start-方法与-run-方法的区别" tabindex="-1"><a class="header-anchor" href="#start-方法与-run-方法的区别" aria-hidden="true">#</a> start()方法与 run()方法的区别？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>start()方法是启动当前线程，并调用run()方法;(只能调用一次，否则抛出&quot;IllegalThreadStateException&quot;异常)
run()方法通常需要重写，要执行的代码声明在此方法中。
</code></pre></div><h3 id="什么是线程池-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池-为什么要使用线程池" aria-hidden="true">#</a> 什么是线程池，为什么要使用线程池？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程池就是存放多个线程的容器;可以重用线程，减少创建和销毁线程带来的消耗。
</code></pre></div><h3 id="什么是线程同步" tabindex="-1"><a class="header-anchor" href="#什么是线程同步" aria-hidden="true">#</a> 什么是线程同步？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>当多个线程访问同一资源，就需要解决数据一致性的问题，这时候就需要线程同步来解决这个问题。
线程同步:一次只允许某一个线程对某一资源进行访问称为线程同步。
</code></pre></div><h3 id="java-中的线程锁" tabindex="-1"><a class="header-anchor" href="#java-中的线程锁" aria-hidden="true">#</a> java 中的线程锁？</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>线程锁(synchronized)作为并发共享数据，保证一致性的工具。
</code></pre></div><h3 id="说一下线程的几种状态" tabindex="-1"><a class="header-anchor" href="#说一下线程的几种状态" aria-hidden="true">#</a> 说一下线程的几种状态</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>新建--就绪--运行--阻塞--死亡
</code></pre></div><figure><img src="`+x+`" alt="线程状态转换图.jpg" width="600" tabindex="0" loading="lazy"><figcaption>线程状态转换图.jpg</figcaption></figure><h3 id="线程操作常见的-api" tabindex="-1"><a class="header-anchor" href="#线程操作常见的-api" aria-hidden="true">#</a> 线程操作常见的 API</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code> start():①启动当前线程;②调用run();
 run():线程在被调度时执行的操作
 currentThread():静态方法，返回执行当前代码的线程
 getName():获取当前线程名字
 setName():设置当前线程名字
 yield():释放当前CPU的执行权
 join():在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态
 stop():已过时。当执行此方法时，强制结束当前线程
 sleep(long mills):让当前线程“睡眠”--阻塞(毫秒)
 isAlive():判断线程还存活
</code></pre></div><h3 id="sleep-与-wait-区别" tabindex="-1"><a class="header-anchor" href="#sleep-与-wait-区别" aria-hidden="true">#</a> sleep 与 wait 区别</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>① sleep()的父类是Thread类，wait()的父类是Object()类;
② wait()方法使当前线程进入等待状态，直到另一线程对该对象发出notify/notifyAll来唤醒，sleep()方法是让线程处于休眠，预设值结束自动结束休眠。
③ sleep()不释放同步锁，wait()释放同步锁。
④ wait()通常放在同步代码块里，而sleep()则不受限制。
</code></pre></div><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2>`,120);function Ln(zn,Bn){const o=i("CodeTabs");return u(),r("div",null,[j,n("details",S,[_,p(o,{id:"301",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[A]),tab1:s(({value:t,isActive:e})=>[q]),_:1},8,["data"]),J,p(o,{id:"312",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[C]),tab1:s(({value:t,isActive:e})=>[I]),_:1},8,["data"]),L,z,p(o,{id:"328",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[B]),tab1:s(({value:t,isActive:e})=>[E]),_:1},8,["data"]),D,T,p(o,{id:"344",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[O]),tab1:s(({value:t,isActive:e})=>[M]),_:1},8,["data"]),P]),F,n("details",N,[V,p(o,{id:"484",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[K]),tab1:s(({value:t,isActive:e})=>[U]),_:1},8,["data"]),H,G,p(o,{id:"500",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[R]),tab1:s(({value:t,isActive:e})=>[X]),_:1},8,["data"]),Q,W,Z,Y,$,nn]),an,p(o,{id:"752",data:[{id:"代码"},{id:"输出结果"}]},{title0:s(({value:t,isActive:e})=>[a("代码")]),title1:s(({value:t,isActive:e})=>[a("输出结果")]),tab0:s(({value:t,isActive:e})=>[sn]),tab1:s(({value:t,isActive:e})=>[tn]),_:1}),en,p(o,{id:"933",data:[{id:"App.java"},{id:"反编译"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("反编译")]),tab0:s(({value:t,isActive:e})=>[on]),tab1:s(({value:t,isActive:e})=>[pn]),_:1},8,["data"]),cn,n("details",ln,[un,p(o,{id:"1061",data:[{id:"App.java"},{id:"AnimalService.java"},{id:"CatServiceImpl.java"},{id:"DogServiceImpl.java"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("AnimalService.java")]),title2:s(({value:t,isActive:e})=>[a("CatServiceImpl.java")]),title3:s(({value:t,isActive:e})=>[a("DogServiceImpl.java")]),tab0:s(({value:t,isActive:e})=>[rn]),tab1:s(({value:t,isActive:e})=>[kn]),tab2:s(({value:t,isActive:e})=>[dn]),tab3:s(({value:t,isActive:e})=>[gn]),_:1},8,["data"]),p(o,{id:"1075",data:[{id:"cn.test.spi.AnimalService"},{id:"输出"},{id:"文件目录结构"}]},{title0:s(({value:t,isActive:e})=>[a("cn.test.spi.AnimalService")]),title1:s(({value:t,isActive:e})=>[a("输出")]),title2:s(({value:t,isActive:e})=>[a("文件目录结构")]),tab0:s(({value:t,isActive:e})=>[mn]),tab1:s(({value:t,isActive:e})=>[vn]),tab2:s(({value:t,isActive:e})=>[hn]),_:1},8,["data"]),bn]),yn,n("details",fn,[xn,p(o,{id:"1140",data:[{id:"App.java"},{id:"Person.java"},{id:"输出"}]},{title0:s(({value:t,isActive:e})=>[a("App.java")]),title1:s(({value:t,isActive:e})=>[a("Person.java")]),title2:s(({value:t,isActive:e})=>[a("输出")]),tab0:s(({value:t,isActive:e})=>[wn]),tab1:s(({value:t,isActive:e})=>[jn]),tab2:s(({value:t,isActive:e})=>[Sn]),_:1},8,["data"])]),_n,n("details",An,[qn,p(o,{id:"1222",data:[{id:"向上转型"},{id:"向下转型"}]},{title0:s(({value:t,isActive:e})=>[a("向上转型")]),title1:s(({value:t,isActive:e})=>[a("向下转型")]),tab0:s(({value:t,isActive:e})=>[Jn]),tab1:s(({value:t,isActive:e})=>[Cn]),_:1})]),In])}const Dn=l(w,[["render",Ln],["__file","java-foundation.html.vue"]]);export{Dn as default};
