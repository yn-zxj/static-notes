import{_ as p,r as c,o as r,c as i,f as m,w as s,a as t,e as a,i as e}from"./app-fpN15tNc.js";const d="/assets/operation-BH7iAA1i.png",u="/assets/anonymous_mount-DXX99cbL.png",v="/assets/named_mount-Desi9NkA.png",k="/assets/path_mount-D9eg1nog.png",g="/assets/delete_volume-D1i2H9jz.png",h="/assets/share_volume_01-D8q0k_fb.png",b="/assets/share_volume_02-DYrXJKpp.png",_={},f=t(`<h2 id="什么是容器数据卷" tabindex="-1"><a class="header-anchor" href="#什么是容器数据卷"><span>什么是容器数据卷</span></a></h2><p>  如果数据都在容器中，假如容器删除数据就会丢失，这显然不是我们希望的，所以需要将数据持久化到本地。此外假如有一个配置，在多个容器中使用到了，假如某个地方需要修改，不使用数据卷就需要一个一个容器的去修改，期间可能还会涉及镜像重新构建与部署，使用数据卷就可以很好的解决这个问题。</p><p>  卷的本质是文件或者目录，存在一个或者多个容器中，有 Docker 挂载到容器，但不属于联合文件系统。卷的概念不仅解决了数据持久化的问题，还解决了容器间共享数据的问题。</p><div class="hint-container tip"><p class="hint-container-title">总结</p><p>① 数据的持久化，当容器重启后保证数据不丢失；<br> ② 如果数据存储于镜像中，主机上的其它进程不方便访问这些数据，数据卷解决了容器间数据共享问题。</p></div><p><strong>容器卷有哪些特点</strong>：<br>  ① 数据卷可在容器之间共享或重用数据<br>  ② 数据卷中的更改不会包含在镜像的更新中<br>  ③ 卷中的更改可以直接生效<br>  ④ 数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="卷的操作" tabindex="-1"><a class="header-anchor" href="#卷的操作"><span>卷的操作</span></a></h2><h3 id="挂载数据卷" tabindex="-1"><a class="header-anchor" href="#挂载数据卷"><span>挂载数据卷</span></a></h3><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> /opt/apps/memos:/var/opt/memos neosmemo/memos:stable
</code></pre></div><p>查看挂载是否成功：<br><code>docker inspect container_id</code></p>`,9),x=a("div",{class:"language-bash","data-ext":"sh","data-title":"sh"},[a("pre",{shell:"",":no-line-numbers":"",class:"language-bash"},[a("code",null,[a("span",{class:"token punctuation"},"{"),e(`
    `),a("span",{class:"token string"},'"Mounts"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token punctuation"},"["),e(`
        `),a("span",{class:"token punctuation"},"{"),e(`
            `),a("span",{class:"token string"},'"Type"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token string"},'"bind"'),e(`,
            `),a("span",{class:"token string"},'"Source"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token string"},'"/opt/apps/memos"'),e(", "),a("span",{class:"token comment"},"# 宿主机目录"),e(`
            `),a("span",{class:"token string"},'"Destination"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token string"},'"/var/opt/memos"'),e(", "),a("span",{class:"token comment"},"# 容器内的目录"),e(`
            `),a("span",{class:"token string"},'"Mode"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token string"},'"rw"'),e(`,
            `),a("span",{class:"token string"},'"RW"'),a("span",{class:"token builtin class-name"},":"),e(` true,
            `),a("span",{class:"token string"},'"Propagation"'),a("span",{class:"token builtin class-name"},":"),e(),a("span",{class:"token string"},'"rprivate"'),e(`
        `),a("span",{class:"token punctuation"},"}"),e(`
    `),a("span",{class:"token punctuation"},"]"),e(`
`),a("span",{class:"token punctuation"},"}"),e(`
`)])]),a("div",{class:"highlight-lines"},[a("br"),a("br"),a("br"),a("br"),a("div",{class:"highlight-line"}," "),a("div",{class:"highlight-line"}," "),a("br"),a("br"),a("br"),a("br"),a("br"),a("br")])],-1),y=t(`<h3 id="管理-volume" tabindex="-1"><a class="header-anchor" href="#管理-volume"><span>管理 volume</span></a></h3><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume COMMAND

Commands:
  create      创建一个 volume
  inspect     显示一个或多个 volume 的详细信息
  <span class="token function">ls</span>          列出 volume
  prune       移除本地没用到的 volume
  <span class="token function">rm</span>          移除一个或多个 volume
</code></pre></div><h4 id="创建-volume" tabindex="-1"><a class="header-anchor" href="#创建-volume"><span>创建 volume</span></a></h4><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># ① 创建volume</span>
<span class="token function">docker</span> volume create vol_test

<span class="token comment"># ② 列出volume</span>
<span class="token function">docker</span> volume <span class="token function">ls</span>

<span class="token comment"># ③ 查看volume</span>
<span class="token function">docker</span> volume inspect vol_test
</code></pre></div><figure><img src="`+d+`" alt="操作卷.png" width="700" tabindex="0" loading="lazy"><figcaption>操作卷.png</figcaption></figure><blockquote><p>  上图中使用命令<code>docker volume inspect volume_name</code>，查看了指定卷的详细信息，<code>Mountpoint</code>展示的是挂载的路径，<u class="under-dash">所有的 Docker 容器内的卷，没有指定目录的情况下都是存放在其安装的<code>docker/volume/xxx/_data</code>下，例如：<code>/var/lib/docker/volume/(volume_name)/_data</code></u>；在此路径下，如果没有指定挂载卷的名字，就会随机生成一个名字(<u class="under-wave">挂载时只写了容器内的路径，没有写容器外的路径</u>)，例如<code>7c33f...a3d3</code>、<code>7cad...f909</code>这样的也被称为<strong>匿名挂载</strong>，而我们创建的<code>vol_test</code>因为有自己的名字被称为<strong>具名挂载</strong>。</p></blockquote><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 匿名挂载</span>
<span class="token parameter variable">-v</span> 容器内路径
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> /var/opt/memos neosmemo/memos:stable

<span class="token comment"># 具名挂载</span>
<span class="token parameter variable">-v</span> 卷名:容器内路径
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> memos_data:/var/opt/memos neosmemo/memos:stable

<span class="token comment"># 指定路径挂载</span>
<span class="token parameter variable">-v</span> 宿主机路径:容器内路径
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> /opt/apps/memos:/var/opt/memos neosmemo/memos:stable

<span class="token comment"># 详细对比下方案例说明 👇🏻</span>
</code></pre></div><p><strong>案例说明</strong>：匿名挂载、具名挂载、指定路径挂载三者区别 ?</p>`,8),D=a("figure",null,[a("img",{src:u,alt:"匿名挂载.png",tabindex:"0",loading:"lazy"}),a("figcaption",null,"匿名挂载.png")],-1),z=a("figure",null,[a("img",{src:v,alt:"具名挂载.png",tabindex:"0",loading:"lazy"}),a("figcaption",null,"具名挂载.png")],-1),q=a("figure",null,[a("img",{src:k,alt:"指定路径挂载.png",tabindex:"0",loading:"lazy"}),a("figcaption",null,"指定路径挂载.png")],-1),Z=t(`<p><strong>总结</strong>：<br>  ① 具名挂载和匿名挂载，都是挂载到<code>/var/lib/docker/volume/(volume_name)/_data</code>下，具名挂载可以指定卷的名字；匿名挂载没有指定卷的名字，随机生成一个名字；<br>  ② 指定路径挂载顾名思义，因为指定了路径，所以使用<code>docker volume ls</code>，没有挂载的信息，其数据存放指向已经改变；与匿名挂载和具名挂载不同，使用命令<code>docker inspect -f &quot;{{json .Mounts}}&quot; container_id</code>，返回的<code>Type</code>类型不同；<br>  ③ 具名挂载和指定根路径挂载，注意挂载命令<code>-v /docker_data/memos_data:/var/opt/memos</code>，前面有<code>/</code>的是指定路径，否则就是具名挂载；<br>  ④ 使用具名挂载，案例如下；如果用户不执行第一条命令而直接执行第二条命令，Docker 会代替用户来创建一个名为<code>vol_simple</code>的 volume，并将其挂载到<code>/_data</code>目录下；</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create vol_simple
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> vol_simple:/var/opt/memos neosmemo/memos:stable
</code></pre></div><p> ⑤ 指定路径挂载，文件夹必须使用<strong>绝对路径</strong>，如果宿主机中不存在该路径，Docker 会自动创建；<br>  ⑥ 创建新容器时，可以使用多个<code>-v</code>标签为容器添加多个 volume，例如：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> vol_muti <span class="token punctuation">\\</span>
<span class="token parameter variable">-v</span> /host_folder_1:/container_folder_1 <span class="token punctuation">\\</span>
<span class="token parameter variable">-v</span> /host_folder_2:/container_folder_2:ro <span class="token punctuation">\\</span>
<span class="token parameter variable">-v</span> /host_file:/container_file centos
</code></pre></div><p> ⑦ volume 挂载时使用<code>z</code>和<code>Z</code>来指定该 volume 的权限，默认是<code>z</code>代表共享该 volume，<code>Z</code>该 volume 为私有卷；此外还有<code>ro</code>、<code>rw</code>；</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># ro read only   只读（只能通过宿主机来操作，容器内部无法操作）</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> vol_ro <span class="token parameter variable">-v</span> /host_folder:/container_folder:ro centos
<span class="token comment"># rw read write  可读可写</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> vol_rw <span class="token parameter variable">-v</span> /host_folder:/container_folder:rw centos
<span class="token comment"># z 共享卷</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> vol_z <span class="token parameter variable">-v</span> /host_folder:/container_folder:z centos
<span class="token comment"># Z 私有卷</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> vol_Z <span class="token parameter variable">-v</span> /host_folder:/container_folder:Z centos
</code></pre></div><hr><div class="hint-container tip"><p class="hint-container-title">指令路径挂载错误案例</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 宿主机路径前缺失 /</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> opt/apps/memos:/var/opt/memos neosmemo/memos:stable
<span class="token comment"># docker: Error response from daemon: create opt/apps/memos: &quot;opt/apps/memos&quot; includes</span>
<span class="token comment">#   invalid characters for a local volume name, only &quot;[a-zA-Z0-9][a-zA-Z0-9_.-]&quot; are</span>
<span class="token comment">#   allowed. If you intended to pass a host directory, use absolute path.</span>

<span class="token comment"># 宿主机路径后缺失 :</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> memos <span class="token parameter variable">-p</span> <span class="token number">5230</span>:5230 <span class="token punctuation">\\</span>
 <span class="token parameter variable">-v</span> /opt/apps/memos /var/opt/memos neosmemo/memos:stable
<span class="token comment"># docker: invalid reference format.</span>
</code></pre></div></div><h4 id="删除-volume" tabindex="-1"><a class="header-anchor" href="#删除-volume"><span>删除 volume</span></a></h4><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token function">rm</span> vol_test
</code></pre></div><figure><img src="`+g+`" alt="删除卷.png" width="700" tabindex="0" loading="lazy"><figcaption>删除卷.png</figcaption></figure><h3 id="使用-dockerfile-添加-volume" tabindex="-1"><a class="header-anchor" href="#使用-dockerfile-添加-volume"><span>使用 Dockerfile 添加 volume</span></a></h3><p><code>Dockerfile</code>：</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 挂载单个数据卷</span>
VOLUME /data
<span class="token comment"># 挂载多个数据卷</span>
VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/data1&quot;</span>, <span class="token string">&quot;/data2&quot;</span><span class="token punctuation">]</span>
</code></pre></div><blockquote><p>  与使用<code>docker run -v</code>不同的是，VOLUME 指令不能挂载主机中指定的文件夹。这是为了保证 Dockerfile 的可移植性，因为不能保证所有的宿主机都有对应的文件夹。</p></blockquote><h3 id="共享-volume-volume-from" tabindex="-1"><a class="header-anchor" href="#共享-volume-volume-from"><span>共享 volume (--volume-from)</span></a></h3><p>  在使用 docker run 或 docker create 创建新的容器时，可以使用<code>--volume-from</code>标签使得容器与已有容器共享 volume。</p><div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 启动容器 memos_01</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token parameter variable">--name</span> memos_01 <span class="token parameter variable">-v</span> memos_data:/var/opt/memos neosmemo/memos:stable
<span class="token comment"># 启动容器 memos_02 并使用 memos_01 的 volume</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token parameter variable">--name</span> memos_02 --volumes-from memos_01 neosmemo/memos:stable
</code></pre></div><figure><img src="`+h+'" alt="共享卷-01.png" tabindex="0" loading="lazy"><figcaption>共享卷-01.png</figcaption></figure><figure><img src="'+b+'" alt="共享卷-02.png" tabindex="0" loading="lazy"><figcaption>共享卷-02.png</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">注意事项</p><p>① 如果被分享的容器有多个 volume，新容器也将有多个 volume，并且其挂载的目录相同；<br> ② 容器挂载了 volume，且被共享了；即使这个容器停止运行或者删除，该 volume 仍然存在，其它容器的使用不受影响。</p></div><h3 id="备份、恢复或迁移-volume" tabindex="-1"><a class="header-anchor" href="#备份、恢复或迁移-volume"><span>备份、恢复或迁移 volume</span></a></h3><p>  volume 作为数据的载体，在很多情况下需要对其中的数据进行备份、迁移，或是从已有数据恢复。以上文中创建的<code>memos_01</code>为例，该容器在<code>/mnt/data_iStore/docker/volume/memos_data/_data</code>挂载了一个 volume。如果需要将这里面的数据备份，一个很简单方法就是使用<code>docker inspect</code>命令查找到挂载目录在宿主机上对应的路径位置，然后复制其中的内容或是使用 tar 进行打包；同样地，如果需要恢复某个 volume 中的数据，可以查找到 volume 对应的文件夹，将数据复制进这个文件夹或是使用 tar 从存档文件中恢复。</p>',23);function T(w,A){const l=c("Tabs");return r(),i("div",null,[f,x,y,m(l,{id:"48",data:[{id:"匿名挂载"},{id:"具名挂载"},{id:"指定路径挂载"}]},{title0:s(({value:n,isActive:o})=>[e("匿名挂载")]),title1:s(({value:n,isActive:o})=>[e("具名挂载")]),title2:s(({value:n,isActive:o})=>[e("指定路径挂载")]),tab0:s(({value:n,isActive:o})=>[D]),tab1:s(({value:n,isActive:o})=>[z]),tab2:s(({value:n,isActive:o})=>[q]),_:1}),Z])}const N=p(_,[["render",T],["__file","data_volume.html.vue"]]),V=JSON.parse('{"path":"/backend/docker/data_volume.html","title":"容器数据卷","lang":"zh-CN","frontmatter":{"title":"容器数据卷","icon":"create","order":3,"author":"Mr.Zhang","category":["后端"],"tag":["Docker"],"date":"2024-02-25T00:00:00.000Z","description":"什么是容器数据卷 如果数据都在容器中，假如容器删除数据就会丢失，这显然不是我们希望的，所以需要将数据持久化到本地。此外假如有一个配置，在多个容器中使用到了，假如某个地方需要修改，不使用数据卷就需要一个一个容器的去修改，期间可能还会涉及镜像重新构建与部署，使用数据卷就可以很好的解决这个问题。 卷的本质是文件或者目录，存在一个或者多个容器中，有 Docke...","head":[["meta",{"property":"og:url","content":"https://doc.bt66.cn/backend/docker/data_volume.html"}],["meta",{"property":"og:title","content":"容器数据卷"}],["meta",{"property":"og:description","content":"什么是容器数据卷 如果数据都在容器中，假如容器删除数据就会丢失，这显然不是我们希望的，所以需要将数据持久化到本地。此外假如有一个配置，在多个容器中使用到了，假如某个地方需要修改，不使用数据卷就需要一个一个容器的去修改，期间可能还会涉及镜像重新构建与部署，使用数据卷就可以很好的解决这个问题。 卷的本质是文件或者目录，存在一个或者多个容器中，有 Docke..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-06T14:09:17.000Z"}],["meta",{"property":"article:author","content":"Mr.Zhang"}],["meta",{"property":"article:tag","content":"Docker"}],["meta",{"property":"article:published_time","content":"2024-02-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-06T14:09:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"容器数据卷\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-06T14:09:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Zhang\\"}]}"]]},"headers":[{"level":2,"title":"什么是容器数据卷","slug":"什么是容器数据卷","link":"#什么是容器数据卷","children":[]},{"level":2,"title":"卷的操作","slug":"卷的操作","link":"#卷的操作","children":[{"level":3,"title":"挂载数据卷","slug":"挂载数据卷","link":"#挂载数据卷","children":[]},{"level":3,"title":"管理 volume","slug":"管理-volume","link":"#管理-volume","children":[]},{"level":3,"title":"使用 Dockerfile 添加 volume","slug":"使用-dockerfile-添加-volume","link":"#使用-dockerfile-添加-volume","children":[]},{"level":3,"title":"共享 volume (--volume-from)","slug":"共享-volume-volume-from","link":"#共享-volume-volume-from","children":[]},{"level":3,"title":"备份、恢复或迁移 volume","slug":"备份、恢复或迁移-volume","link":"#备份、恢复或迁移-volume","children":[]}]}],"git":{"createdTime":1708875048000,"updatedTime":1709734157000,"contributors":[{"name":"yn-zxj","email":"331134138@qq.com","commits":6},{"name":"ynzxj","email":"ynzxj@qq.com","commits":1}]},"readingTime":{"minutes":6.19,"words":1856},"filePathRelative":"backend/docker/data_volume.md","localizedDate":"2024年2月25日","autoDesc":true}');export{N as comp,V as data};
