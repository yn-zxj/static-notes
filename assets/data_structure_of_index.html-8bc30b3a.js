import{_ as a,o as i,c as e,a as n}from"./app-140f6a29.js";const t="/assets/index_none-94d4d891.png",r="/assets/get_by_index-0a20e83d.png",s="/assets/row_format_diagram-3949dcd7.png",d="/assets/row_format_diagram_two-f46d6781.png",g="/assets/2023-06-29-23-28-47-dd4499ba.png",o="/assets/2023-06-29-23-28-57-d78ed322.png",c="/assets/2023-06-29-23-29-07-2e14ec99.png",h="/assets/2023-06-29-23-29-18-f33248c0.png",f="/assets/2023-06-29-23-29-35-a783d2c1.png",p="/assets/2023-06-29-23-29-41-8eb4c73e.png",_="/assets/2023-06-29-23-29-53-38001def.png",l="/assets/2023-06-29-23-30-04-aec67adc.png",u="/assets/2023-06-29-23-30-38-0b7b8940.png",m="/assets/2023-06-29-23-30-49-eaac326c.png",b="/assets/2023-06-29-23-31-06-72168675.png",x="/assets/2023-06-29-23-31-19-343441f5.png",y="/assets/2023-06-29-23-31-25-14344b7e.png",z="/assets/2023-06-29-23-31-36-7624c7d1.png",M="/assets/2023-06-29-23-31-46-a22f28f0.png",B="/assets/2023-06-29-23-32-02-08a2037f.png",I="/assets/2023-06-29-23-32-12-bbf92667.png",S="/assets/2023-06-29-23-32-19-8c4c36aa.png",k="/assets/2023-06-29-23-32-29-211a4184.png",w="/assets/2023-06-29-23-32-40-5c1240cd.png",v="/assets/2023-06-29-23-32-50-3ce346ee.png",A="/assets/time_complexity_of_algorithm-3adb5972.png",L={},D=n('<h2 id="_1-为什么使用索引" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用索引" aria-hidden="true">#</a> 1.为什么使用索引</h2><figure><img src="'+t+'" alt="无索引数据读取.png" tabindex="0" loading="lazy"><figcaption>无索引数据读取.png</figcaption></figure><p>假如给数据使用<code>二叉树</code>这样的数据结构进行存储，如下图所示：</p><figure><img src="'+r+'" alt="有索引数据读取.png" width="600" tabindex="0" loading="lazy"><figcaption>有索引数据读取.png</figcaption></figure><h2 id="_2-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_2-索引的优缺点" aria-hidden="true">#</a> 2.索引的优缺点</h2><h3 id="_2-1-索引概述" tabindex="-1"><a class="header-anchor" href="#_2-1-索引概述" aria-hidden="true">#</a> 2.1 索引概述</h3><p>MySQL 官方对索引的定义为：<mark>索引(Index)是帮助 MySQL 高效获取数据的数据结构。</mark></p><h3 id="_2-2-优点" tabindex="-1"><a class="header-anchor" href="#_2-2-优点" aria-hidden="true">#</a> 2.2 优点</h3><p>① 类似图书馆建书目索引，<mark>提高数据检索的效率，降低数据库的 IO 成本</mark>，这也是创建索引最主要的原因；<br> ② 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性；<br> ③ 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度；<br> ④ 在使用分组和排序子句进行数据查询时，可以显著减少查询分组和排序的时间，降低了 CPU 的消耗。</p><h3 id="_2-3-缺点" tabindex="-1"><a class="header-anchor" href="#_2-3-缺点" aria-hidden="true">#</a> 2.3 缺点</h3><p>① 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加；<br> ② 索引需要占用磁盘空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸；<br> ③ 虽然索引大大提高了查询速度，但同时却会降低更新表的速度。当对表的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据维护的速度。</p><p><strong><u>因此，选择使用索引时，需要综合考虑索引的优缺点</u></strong>。</p><h2 id="_3-innodb-中索引的推演" tabindex="-1"><a class="header-anchor" href="#_3-innodb-中索引的推演" aria-hidden="true">#</a> 3.InnoDB 中索引的推演</h2><h3 id="_3-1-索引之前的查找" tabindex="-1"><a class="header-anchor" href="#_3-1-索引之前的查找" aria-hidden="true">#</a> 3.1 索引之前的查找</h3><figure><img src="'+s+'" alt="行格式示意图.png" width="500" tabindex="0" loading="lazy"><figcaption>行格式示意图.png</figcaption></figure><figure><img src="'+d+'" alt="行格式示意图-竖.png" width="500" tabindex="0" loading="lazy"><figcaption>行格式示意图-竖.png</figcaption></figure><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-2-设计索引" tabindex="-1"><a class="header-anchor" href="#_3-2-设计索引" aria-hidden="true">#</a> 3.2 设计索引</h3><h3 id="_3-3-常见索引概念" tabindex="-1"><a class="header-anchor" href="#_3-3-常见索引概念" aria-hidden="true">#</a> 3.3 常见索引概念</h3><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-4-innodb-的-b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#_3-4-innodb-的-b-树索引的注意事项" aria-hidden="true">#</a> 3.4 InnoDB 的 B+树索引的注意事项</h3><h2 id="_4-myisam-中的索引方案" tabindex="-1"><a class="header-anchor" href="#_4-myisam-中的索引方案" aria-hidden="true">#</a> 4.MyISAM 中的索引方案</h2><h3 id="_4-1-myisam-索引的原理" tabindex="-1"><a class="header-anchor" href="#_4-1-myisam-索引的原理" aria-hidden="true">#</a> 4.1 MyISAM 索引的原理</h3><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-2-myisam-和-innodb-对比" tabindex="-1"><a class="header-anchor" href="#_4-2-myisam-和-innodb-对比" aria-hidden="true">#</a> 4.2 MyISAM 和 InnoDB 对比</h3><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_5-索引的代价" tabindex="-1"><a class="header-anchor" href="#_5-索引的代价" aria-hidden="true">#</a> 5.索引的代价</h2><h2 id="_6-mysql-数据结构选择的合理性" tabindex="-1"><a class="header-anchor" href="#_6-mysql-数据结构选择的合理性" aria-hidden="true">#</a> 6.MySQL 数据结构选择的合理性</h2><h3 id="_6-1-全表遍历" tabindex="-1"><a class="header-anchor" href="#_6-1-全表遍历" aria-hidden="true">#</a> 6.1 全表遍历</h3><h3 id="_6-2-hash-结构" tabindex="-1"><a class="header-anchor" href="#_6-2-hash-结构" aria-hidden="true">#</a> 6.2 Hash 结构</h3><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-3-二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_6-3-二叉搜索树" aria-hidden="true">#</a> 6.3 二叉搜索树</h3><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-4-avl-树" tabindex="-1"><a class="header-anchor" href="#_6-4-avl-树" aria-hidden="true">#</a> 6.4 AVL 树</h3><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-5-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-5-b-tree" aria-hidden="true">#</a> 6.5 B-Tree</h3><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-6-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-6-b-tree" aria-hidden="true">#</a> 6.6 B+Tree</h3><h3 id="_6-7-r-树" tabindex="-1"><a class="header-anchor" href="#_6-7-r-树" aria-hidden="true">#</a> 6.7 R 树</h3><h3 id="附录-算法的时间复杂度" tabindex="-1"><a class="header-anchor" href="#附录-算法的时间复杂度" aria-hidden="true">#</a> 附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><figure><img src="'+A+'" alt="算法的时间复杂度.png" tabindex="0" loading="lazy"><figcaption>算法的时间复杂度.png</figcaption></figure>',55),Q=[D];function q(T,V){return i(),e("div",null,Q)}const E=a(L,[["render",q],["__file","data_structure_of_index.html.vue"]]);export{E as default};
