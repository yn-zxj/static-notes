import{_ as p,j as o,o as c,c as d,f as n,i as a,g as t,a as s}from"./app-2b6fe2ee.js";const r="/assets/window_of_num-b5d311b0.png",l="/assets/window_of_percent-8e8c4fe9.png",i="/assets/window_of_around-5df705af.png",k="/assets/window_of_fd-3e2bebd3.png",u="/assets/window_of_nth-1d619f74.png",h="/assets/window_of_ntile-64f8c714.png",y={},E=s('<h2 id="mysql-8-新特性概述" tabindex="-1"><a class="header-anchor" href="#mysql-8-新特性概述" aria-hidden="true">#</a> MySQL 8 新特性概述</h2><p>  MySQL 从 5.7 版本直接跳跃发布了 8.0 版本，可见这是一个令人兴奋的里程碑版本。MySQL 8 版本在功能上做了显著的改进与增强，开发者对 MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="新增特性" tabindex="-1"><a class="header-anchor" href="#新增特性" aria-hidden="true">#</a> 新增特性</h3><h4 id="更简便的-nosql-支持" tabindex="-1"><a class="header-anchor" href="#更简便的-nosql-支持" aria-hidden="true">#</a> 更简便的 NoSQL 支持</h4><p>  NoSQL 泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从 5.6 版本开始，MySQL 就开始支持简单的 NoSQL 存储功能。MySQL 8 对这一功能做了优化，以更灵活的方式实现 NoSQL 功能，不再依赖模式(schema)。</p><h4 id="更好的索引" tabindex="-1"><a class="header-anchor" href="#更好的索引" aria-hidden="true">#</a> 更好的索引</h4><p>  在查询中，正确地使用索引可以提高查询的效率。MySQL 8 中新增了<mark>隐藏索引</mark>和<mark>降序索引</mark>。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p><h4 id="更完善的-json-支持" tabindex="-1"><a class="header-anchor" href="#更完善的-json-支持" aria-hidden="true">#</a> 更完善的 JSON 支持</h4><p>  MySQL 从 5.7 开始支持原生 JSON 数据的存储，MySQL 8 对这一功能做了优化，增加了聚合函数<code>JSON_ARRAYAGG()</code>和<code>JSON_OBJECTAGG()</code>，将参数聚合为 JSON 数组或对象，新增了行内操作符<code>-&gt;&gt;</code>，是列路径运算符<code>-&gt;</code>的增强，对 JSON 排序做了提升，并优化了 JSON 的更新操作。</p><h4 id="安全和账户管理" tabindex="-1"><a class="header-anchor" href="#安全和账户管理" aria-hidden="true">#</a> 安全和账户管理</h4><p>  MySQL 8 中新增了<code>caching_sha2_password</code>授权插件、角色、密码历史记录和 FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p><h4 id="innodb-的变化" tabindex="-1"><a class="header-anchor" href="#innodb-的变化" aria-hidden="true">#</a> InnoDB 的变化</h4><p>  <mark>InnoDB 是 MySQL 默认的存储引擎</mark>，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在 MySQL 8 版本中，InnoDB 在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p><h4 id="数据字典" tabindex="-1"><a class="header-anchor" href="#数据字典" aria-hidden="true">#</a> 数据字典</h4><p>  在之前的 MySQL 版本中，字典数据都存储在元数据文件和非事务表中。从 MySQL 8 开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p><h4 id="原子数据定义语句" tabindex="-1"><a class="header-anchor" href="#原子数据定义语句" aria-hidden="true">#</a> 原子数据定义语句</h4><p>  MySQL 8 开始支持原子数据定义语句（Automic DDL），即<code>原子DDL</code>。目前，只有 InnoDB 存储引擎支持原子 DDL。原子数据定义语句（DDL）将与 DDL 操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。使用支持原子操作的存储引擎所创建的表，在执行 DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE 等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从 MySQL 5.7 复制到 MySQL 8 版本中的语句，可以添加 IF EXISTS 或 IF NOT EXISTS 语句来避免发生错误。</p><h4 id="资源管理" tabindex="-1"><a class="header-anchor" href="#资源管理" aria-hidden="true">#</a> 资源管理</h4><p>  MySQL 8 开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。 目前，CPU 时间是可控资源，由“虚拟 CPU”这个概念来表示，此术语包含 CPU 的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟 CPU 数量。拥有对应权限的数据库管理员可以将这些 CPU 与资源组关联，并为资源组分配线程。 资源组组件为 MySQL 中的资源组管理提供了 SQL 接口。资源组的属性用于定义资源组。MySQL 中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些 MySQL 的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是 macOS 系统，资源管理将处于不可用状态。在 FreeBSD 和 Solaris 系统中，资源线程优先级将失效。在 Linux 系统中，只有配置了 CAP_SYS_NICE 属性，资源管理优先级才能发挥作用。</p><h4 id="字符集支持" tabindex="-1"><a class="header-anchor" href="#字符集支持" aria-hidden="true">#</a> 字符集支持</h4><p>  MySQL 8 中默认的字符集由<code>latin1</code>更改为<code>utf8mb4</code>，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</p><h4 id="优化器增强" tabindex="-1"><a class="header-anchor" href="#优化器增强" aria-hidden="true">#</a> 优化器增强</h4><p>  MySQL 优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p><h4 id="公用表表达式" tabindex="-1"><a class="header-anchor" href="#公用表表达式" aria-hidden="true">#</a> 公用表表达式</h4><p>  公用表表达式（Common Table Expressions）简称为 CTE，MySQL 现在支持递归和非递归两种形式的 CTE。CTE 通过在 SELECT 语句或其他特定语句前使用 WITH 语句对临时结果集进行命名。</p><h4 id="窗口函数" tabindex="-1"><a class="header-anchor" href="#窗口函数" aria-hidden="true">#</a> 窗口函数</h4><p>  MySQL 8 开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在 MySQL 8 中也可以作为窗口函数来使用。</p><h4 id="正则表达式支持" tabindex="-1"><a class="header-anchor" href="#正则表达式支持" aria-hidden="true">#</a> 正则表达式支持</h4><p>  MySQL 在 8.0.4 以后的版本中采用支持 Unicode 的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的 Unicode 支持，而且是多字节安全编码。MySQL 增加了 REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit 和 regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p><h4 id="内部临时表" tabindex="-1"><a class="header-anchor" href="#内部临时表" aria-hidden="true">#</a> 内部临时表</h4><p>  <mark>TempTable 存储引擎取代 MEMORY 存储引擎成为内部临时表的默认存储引擎</mark>。TempTable 存储引擎为 VARCHAR 和 VARBINARY 列提供高效存储。internal_tmp_mem_storage_engine 会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable 和 MEMORY，其中 TempTable 为默认的存储引擎。temptable_max_ram 系统配置项定义了 TempTable 存储引擎可使用的最大内存数量。</p><h4 id="日志记录" tabindex="-1"><a class="header-anchor" href="#日志记录" aria-hidden="true">#</a> 日志记录</h4><p>  在 MySQL 8 中错误日志子系统由一系列 MySQL 组件构成。这些组件的构成由系统变量 log_error_services 来配置，能够实现日志事件的过滤和写入。</p><h4 id="备份锁" tabindex="-1"><a class="header-anchor" href="#备份锁" aria-hidden="true">#</a> 备份锁</h4><p>  新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p><h4 id="增强的-mysql-复制" tabindex="-1"><a class="header-anchor" href="#增强的-mysql-复制" aria-hidden="true">#</a> 增强的 MySQL 复制</h4><p>  MySQL 8 复制支持对 JSON 文档进行部分更新的二进制日志记录，该记录使用紧凑的二进制格式，从而节省记录完整 JSON 文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的 binlog_row_value_options 系统变量值设置为 PARTIAL_JSON 来启用。</p><h3 id="移除的旧特性" tabindex="-1"><a class="header-anchor" href="#移除的旧特性" aria-hidden="true">#</a> 移除的旧特性</h3><div class="hint-container warning"><p class="hint-container-title">注意</p><p>在 MySQL 5.7 版本上开发的应用程序如果使用了 MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p></div><h4 id="查询缓存" tabindex="-1"><a class="header-anchor" href="#查询缓存" aria-hidden="true">#</a> 查询缓存</h4><p>查询缓存已被移除，删除的项有：<br> (1) 语句：<code>FLUSH QUERY CACHE</code>和<code>RESET QUERY CACHE</code><br> (2) 系统变量：<br><code>query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate</code><br> (3) 状态变量：<br><code>Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks</code><br> (4) 线程状态：<br><code>checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock</code></p><h4 id="加密相关" tabindex="-1"><a class="header-anchor" href="#加密相关" aria-hidden="true">#</a> 加密相关</h4><p>  删除的加密相关的内容有：<code>ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和 DES_DECRYPT()函数</code>，配置项 des-key-file，系统变量 have_crypt，FLUSH 语句的 DES_KEY_FILE 选项，HAVE_CRYPT CMake 选项。 对于移除的 ENCRYPT()函数，考虑使用 SHA2()替代，对于其他移除的函数，使用 AES_ENCRYPT()和 AES_DECRYPT()替代。</p><h4 id="空间函数相关" tabindex="-1"><a class="header-anchor" href="#空间函数相关" aria-hidden="true">#</a> 空间函数相关</h4><p>  在 MySQL 5.7 版本中，多个空间函数已被标记为过时。这些过时函数在 MySQL 8 中都已被移除，只保留了对应的 ST_和 MBR 函数。</p><h4 id="n和null" tabindex="-1"><a class="header-anchor" href="#n和null" aria-hidden="true">#</a> <code>\\N</code>和<code>NULL</code></h4><p>  在 SQL 语句中，解析器不再将\\N 视为 NULL，所以在 SQL 语句中应使用 NULL 代替\\N。这项变化不会影响使用<code>LOAD DATA INFILE</code>或者<code>SELECT … INTO OUTFILE</code>操作文件的导入和导出。在这类操作中，NULL 仍等同于\\N。</p><h4 id="mysql-install-db" tabindex="-1"><a class="header-anchor" href="#mysql-install-db" aria-hidden="true">#</a> <code>mysql_install_db</code></h4><p>  在 MySQL 分布中，已移除了 mysql_install_db 程序，数据字典初始化需要调用带着–initialize 或者–initialize-insecure 选项的 mysqld 来代替实现。另外，–bootstrap 和 INSTALL_SCRIPTDIR CMake 也已被删除。</p><h4 id="通用分区处理程序" tabindex="-1"><a class="header-anchor" href="#通用分区处理程序" aria-hidden="true">#</a> 通用分区处理程序</h4><p>  通用分区处理程序已从 MySQL 服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。 提供本地分区支持的 MySQL 存储引擎有两个，即 InnoDB 和 NDB，而在 MySQL 8 中只支持 InnoDB。</p><h4 id="系统和状态变量信息" tabindex="-1"><a class="header-anchor" href="#系统和状态变量信息" aria-hidden="true">#</a> 系统和状态变量信息</h4><p>  在 INFORMATION_SCHEMA 数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS 表都已被删除。另外，系统变量 show_compatibility_56 也已被删除。被删除的状态变量有 Slave_heartbeat_period、Slave_last_heartbeat、Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p><h4 id="mysql-plugin-工具" tabindex="-1"><a class="header-anchor" href="#mysql-plugin-工具" aria-hidden="true">#</a> mysql_plugin 工具</h4><p>  mysql_plugin 工具用来配置 MySQL 服务器插件，现已被删除，可使用–plugin-load 或–plugin-load-add 选项在服务器启动时加载插件或者在运行时使用 INSTALL PLUGIN 语句加载插件来替代该工具。</p><h2 id="新特性-窗口函数" tabindex="-1"><a class="header-anchor" href="#新特性-窗口函数" aria-hidden="true">#</a> 新特性-窗口函数</h2><h3 id="窗口函数分类" tabindex="-1"><a class="header-anchor" href="#窗口函数分类" aria-hidden="true">#</a> 窗口函数分类</h3><p>  MySQL 8.0 版本开始支持窗口函数。它的作用类型与在查询中对数据进行的分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为静态窗口函数和动态窗口函数：<br>  静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同<br>  动态窗口函数的窗口大小会随记录的不同而变化</p>',59),w={href:"https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html",target:"_blank",rel:"noopener noreferrer"},_=s(`<p>窗口函数总体可以分为：</p><table><thead><tr><th>分类</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>序号函数</td><td><code>ROW_NUMBER()</code></td><td>顺序排序</td></tr><tr><td>序号函数</td><td><code>RANK()</code></td><td>并列排序，会跳过重复的序号，如：1、1、3</td></tr><tr><td>序号函数</td><td><code>DENSE_RANK()</code></td><td>并列排序，不会跳过重复的序号，如：1、1、2</td></tr><tr><td>分布函数</td><td><code>PERCENT_RANK()</code></td><td>等级值百分比</td></tr><tr><td>分布函数</td><td><code>CUME_DIST()</code></td><td>累计分布值</td></tr><tr><td>前后函数</td><td><code>LAG(expr, n)</code></td><td>返回当前行的前 n 行的 exper 的值</td></tr><tr><td>前后函数</td><td><code>LEAD(expr, n)</code></td><td>返回当前行的后 n 行的 exper 的值</td></tr><tr><td>首尾函数</td><td><code>FIRST_VALUE(expr)</code></td><td>返回第一个 expr 的值</td></tr><tr><td>首尾函数</td><td><code>LAST_VALUE(expr)</code></td><td>返回最后一个 expr 的值</td></tr><tr><td>其它函数</td><td><code>NTH_VALUE(expr, n)</code></td><td>返回第 n 个 expr 的值</td></tr><tr><td>其它函数</td><td><code>NTILE(n)</code></td><td>将分区中的有序数据分为 n 个桶，记录桶编号</td></tr></tbody></table><h3 id="语法结构" tabindex="-1"><a class="header-anchor" href="#语法结构" aria-hidden="true">#</a> 语法结构</h3><div class="language-sql" data-ext="sql"><pre class="language-sql"><code>函数 <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> 字段名 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 字段名 <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 或</span>
函数 <span class="token keyword">OVER</span> 窗口名 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> WINDOW 窗口名 <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> 字段名 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 字段名 <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="序号函数" tabindex="-1"><a class="header-anchor" href="#序号函数" aria-hidden="true">#</a> 序号函数</h4><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>
  ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;row_num&#39;</span><span class="token punctuation">,</span>
  RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;rank&#39;</span><span class="token punctuation">,</span>
  DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;dense_rank&#39;</span>
<span class="token keyword">FROM</span>
  goods<span class="token punctuation">;</span>

<span class="token comment"># 或</span>
<span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>
  ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;row_num&#39;</span><span class="token punctuation">,</span>
  RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;rank&#39;</span><span class="token punctuation">,</span>
  DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;dense_rank&#39;</span>
<span class="token keyword">FROM</span>
  goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+r+`" alt="序号函数.png" tabindex="0" loading="lazy"><figcaption>序号函数.png</figcaption></figure><h4 id="分布函数" tabindex="-1"><a class="header-anchor" href="#分布函数" aria-hidden="true">#</a> 分布函数</h4><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>
  RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;rank&#39;</span><span class="token punctuation">,</span>
  PERCENT_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;percent_rank&#39;</span><span class="token punctuation">,</span>
  CUME_DIST<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token string">&#39;cume_dist&#39;</span>
<span class="token keyword">FROM</span>
  goods<span class="token punctuation">;</span>

<span class="token comment"># 或</span>
<span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category_id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>stock<span class="token punctuation">,</span>
  RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;rank&#39;</span><span class="token punctuation">,</span>
  PERCENT_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;percent_rank&#39;</span><span class="token punctuation">,</span>
  CUME_DIST<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> <span class="token string">&#39;cume_dist&#39;</span>
<span class="token keyword">FROM</span>
  goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price <span class="token keyword">DESC</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+l+`" alt="分布函数.png" tabindex="0" loading="lazy"><figcaption>分布函数.png</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>PERCENT_RANK() : (rank - 1) / (rows - 1)</code><br> 上面第一行数据等于<code>(1-1)/(6-1)=0</code>，第二行数据等于<code>(2-1)/(6-1)=0.2</code>...</p><p><code>CUME_DIST():</code><br><code>ORDER BY ... DESC 查询大于或等于某个值的比例</code><br><code>ORDER BY ... ASC 查询小于或等于某个值的比例</code><br> 上面第一行价格大于等于当前值<code>1/6≈0.166667</code>，第二、三行数据等于<code>3/6=0.5</code>，第四行数据等于<code>4/6≈0.666667</code>...</p></div><h4 id="前后函数" tabindex="-1"><a class="header-anchor" href="#前后函数" aria-hidden="true">#</a> 前后函数</h4><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>
  LAG<span class="token punctuation">(</span> price<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> before_price<span class="token punctuation">,</span> <span class="token comment"># 当前价格的前一个值</span>
  LEAD<span class="token punctuation">(</span> price<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> behind_price <span class="token comment"># 当前价格的后一个值</span>
<span class="token keyword">FROM</span>
  goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+i+`" alt="前后函数.png" width="600" tabindex="0" loading="lazy"><figcaption>前后函数.png</figcaption></figure><h4 id="首尾函数" tabindex="-1"><a class="header-anchor" href="#首尾函数" aria-hidden="true">#</a> 首尾函数</h4><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>
  FIRST_VALUE<span class="token punctuation">(</span> price <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> first_price<span class="token punctuation">,</span>
  LAST_VALUE<span class="token punctuation">(</span> price <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> last_price
<span class="token keyword">FROM</span>
  goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+k+`" alt="首尾函数.png" width="600" tabindex="0" loading="lazy"><figcaption>首尾函数.png</figcaption></figure><h4 id="其他函数" tabindex="-1"><a class="header-anchor" href="#其他函数" aria-hidden="true">#</a> 其他函数</h4><p>① NTH_VALUE(expr, n)</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span>category<span class="token punctuation">,</span>name<span class="token punctuation">,</span>price<span class="token punctuation">,</span>
  NTH_VALUE<span class="token punctuation">(</span> price<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> second_price<span class="token punctuation">,</span> <span class="token comment"># 排第二的价格信息</span>
  NTH_VALUE<span class="token punctuation">(</span> price<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> third_price <span class="token comment"># 排第三的价格信息</span>
<span class="token keyword">FROM</span>
  goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+u+`" alt="NTH_VALUE.png" width="600" tabindex="0" loading="lazy"><figcaption>NTH_VALUE.png</figcaption></figure><p>② NTILE(n)</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 将goods表中的商品按照价格分为 3 组</span>
<span class="token keyword">SELECT</span>
  id<span class="token punctuation">,</span> category<span class="token punctuation">,</span> name<span class="token punctuation">,</span> price<span class="token punctuation">,</span>
  NTILE<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token keyword">OVER</span> w <span class="token keyword">AS</span> nt
<span class="token keyword">FROM</span> goods WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> category_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><figure><img src="`+h+'" alt="NTILE.png" width="500" tabindex="0" loading="lazy"><figcaption>NTILE.png</figcaption></figure><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h2 id="新特性-公用表表达式" tabindex="-1"><a class="header-anchor" href="#新特性-公用表表达式" aria-hidden="true">#</a> 新特性-公用表表达式</h2><p>  公用表表达式（或通用表表达式）简称为 CTE（Common Table Expressions）。CTE 是一个命名的临时结果集，作用范围是当前语句。CTE 可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE 可以引用其他 CTE，但子查询不能引用其他子查询。所以可以考虑代替子查询。</p>',28),S=n("p",null,[a("依据语法结构和执行方式的不同，公用表表达式分为"),n("mark",null,"普通公用表表达式"),a("和"),n("mark",null,"递归公用表表达式"),a(" 2 种。")],-1),g={href:"https://dev.mysql.com/doc/refman/8.0/en/with.html",target:"_blank",rel:"noopener noreferrer"},m=s(`<h3 id="普通公用表表达式" tabindex="-1"><a class="header-anchor" href="#普通公用表表达式" aria-hidden="true">#</a> 普通公用表表达式</h3><p>语法结构：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WITH</span> cte_name
<span class="token keyword">AS</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">|</span> <span class="token keyword">DELETE</span> <span class="token operator">|</span> <span class="token keyword">UPDATE</span> query<span class="token punctuation">;</span>
</code></pre></div><p>示例：查询员工所在的部门的详细信息</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 方式一</span>
<span class="token keyword">SELECT</span>
  <span class="token operator">*</span>
<span class="token keyword">FROM</span> departments
<span class="token keyword">WHERE</span> departmant_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> departmant_id <span class="token keyword">FROM</span> employees<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 方式二</span>
<span class="token keyword">WITH</span> emp_dept_id
<span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> department_id <span class="token keyword">FROM</span> departments<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> departments d<span class="token punctuation">,</span> emp_dept_id e
<span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>department_id <span class="token operator">=</span> e<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>
</code></pre></div><p>  公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</p><h3 id="递归公用表表达式" tabindex="-1"><a class="header-anchor" href="#递归公用表表达式" aria-hidden="true">#</a> 递归公用表表达式</h3><p>语法结构：</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WITH</span> RECURSIVE cte_name
<span class="token keyword">AS</span> <span class="token punctuation">(</span>subquery<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">|</span> <span class="token keyword">DELETE</span> <span class="token operator">|</span> <span class="token keyword">UPDATE</span> query<span class="token punctuation">;</span>
</code></pre></div><blockquote><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字<code>UNION [ALL]</code>进行连接。这里的种子查询，意思就是获得递归的初始值。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p></blockquote><p><strong>示例</strong>：针对于我们常用的 employees 表，包含 employee_id，last_name 和 manager_id 三个字段。如果 a 是 b 的管理者，那么我们可以把 b 叫做 a 的下属，如果同时 b 又是 c 的管理者，那么 c 就是 b 的下属，是 a 的下下属。</p><p><strong>递归思想</strong>：<br> ① 用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。<br> ② 用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。<br> ③ 在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">WITH</span> RECURSIVE cte
<span class="token keyword">AS</span>
<span class="token punctuation">(</span>
<span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>manager_id<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">AS</span> n <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> employee_id <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">-- 种子查询，找到第一代领导</span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>employee_id<span class="token punctuation">,</span>a<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span>a<span class="token punctuation">.</span>manager_id<span class="token punctuation">,</span>n <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">FROM</span> employees a <span class="token keyword">JOIN</span> cte
<span class="token keyword">ON</span> a<span class="token punctuation">.</span>manager_id <span class="token operator">=</span> cte<span class="token punctuation">.</span>employee_id <span class="token comment">-- 递归查询，找出以递归公用表表达式的人为领导的人)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> employee_id<span class="token punctuation">,</span>last_name <span class="token keyword">FROM</span> cte <span class="token keyword">WHERE</span> n <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p></blockquote><h3 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h3><p>  公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其它查询方式难以处理的查询。</p>`,16);function R(T,L){const e=o("ExternalLinkIcon");return c(),d("div",null,[E,n("blockquote",null,[n("p",null,[a("官网介绍："),n("a",w,[a("https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html"),t(e)])])]),_,n("blockquote",null,[S,n("p",null,[a("官网介绍："),n("a",g,[a("https://dev.mysql.com/doc/refman/8.0/en/with.html"),t(e)])])]),m])}const b=p(y,[["render",R],["__file","new_features.html.vue"]]);export{b as default};
