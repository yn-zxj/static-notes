import{_ as c,j as d,o as r,c as p,g as l,w as s,a as o,i as a,f as n}from"./app-f8aacf8c.js";const u="/assets/base-type-fa548d7e.jpg",k="/assets/t-01-a2fd61f9.png",v={},h=o(`<h2 id="java-基础知识" tabindex="-1"><a class="header-anchor" href="#java-基础知识" aria-hidden="true">#</a> Java 基础知识</h2><h3 id="说一下-java-的三种注释" tabindex="-1"><a class="header-anchor" href="#说一下-java-的三种注释" aria-hidden="true">#</a> 说一下 JAVA 的三种注释</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>// 单行注释
/*...*/ 多行注释
/...*/ 文档注释
</code></pre></div><h3 id="面向对象的特征-了解" tabindex="-1"><a class="header-anchor" href="#面向对象的特征-了解" aria-hidden="true">#</a> 面向对象的特征(了解)</h3><p><strong>面向对象的特征</strong>：<u class="under-dot">封装、继承、多态、抽象</u></p><blockquote><p><strong>封装</strong>:把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的，增加安全性。</p><hr><p><strong>继承</strong>：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p><hr><p><strong>多态</strong>：指允许不同的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><hr><p><strong>抽象</strong>：表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用此关键字修饰类时，此类就不能被实例化，这这里可以看出，抽象类(接口)就是为了继承而存在的。</p></blockquote><h3 id="java-的数据类型" tabindex="-1"><a class="header-anchor" href="#java-的数据类型" aria-hidden="true">#</a> Java 的数据类型</h3><div class="hint-container tip"><p class="hint-container-title">数据类型</p><p>  Java 数据类型包括两大类：基本数据类型和引用数据类型；其中八个基本数据类型包括整型(byte、short、int、long)、浮点型(float、double)、字符型(char)、布尔型(boolean)；除此之外的都为引用数据类型，比如类、接口、数组。</p></div><figure><img src="`+u+`" alt="基本数据类型.jpg" width="600" tabindex="0" loading="lazy"><figcaption>基本数据类型.jpg</figcaption></figure><table><thead><tr><th>数据类型</th><th>字节数</th><th>位数</th><th>默认值</th><th>包装类型</th><th>使用说明[取值范围]</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>8</td><td>0</td><td>Byte</td><td>-128~127</td></tr><tr><td>short</td><td>2</td><td>16</td><td>0</td><td>Short</td><td>-2<sup>15</sup>~2<sup>15</sup>-1</td></tr><tr><td>int</td><td>4</td><td>32</td><td>0</td><td>Integer</td><td>-2<sup>31</sup>~2<sup>31</sup>-1</td></tr><tr><td>long</td><td>8</td><td>64</td><td>0L 或 0l</td><td>Long</td><td>-2<sup>63</sup>~2<sup>63</sup>-1</td></tr><tr><td>float</td><td>4</td><td>32</td><td>0.0F 或 0.0f</td><td>Float</td><td>1.4E-45~3.4E38</td></tr><tr><td>double</td><td>8</td><td>64</td><td>0.0d</td><td>Double</td><td>4.9E-324~1.8E308</td></tr><tr><td>char</td><td>2</td><td>16</td><td>空</td><td>Character</td><td>使用 Unicode 编码(2 个字节)，可存汉字</td></tr><tr><td>boolean</td><td>-</td><td>-</td><td>false</td><td>Boolean</td><td>只有 true 和 false 两个取值</td></tr></tbody></table><h3 id="整型的默认数据类型是什么-浮点型的数据类型是什么" tabindex="-1"><a class="header-anchor" href="#整型的默认数据类型是什么-浮点型的数据类型是什么" aria-hidden="true">#</a> 整型的默认数据类型是什么，浮点型的数据类型是什么?</h3><div class="language-txt" data-ext="txt"><pre class="language-txt"><code>整型默认数据类型:int
浮点型默认数据类型:double
</code></pre></div><h3 id="jdk、jre、jvm-的区别-必会" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-的区别-必会" aria-hidden="true">#</a> JDK、JRE、JVM 的区别(必会)</h3><blockquote><p><strong>JDK</strong>：JDK(Java Development Kit)即 Java 开发工具包，是整个 Java 的核心，其包括了 Java 运行环境(JRE)、Java 工具和 Java 基础类库。</p><hr><p><strong>JRE</strong>：JRE(Java Runtime Environment)即 Java 运行环境，它是运行 Java 程序所必须得环境的集合，包含 Java 虚拟机和 Java 程序的一些核心类库。</p><hr><p><strong>JVM</strong>：JVM(Java Virtual Machine)即 Java 虚拟机，是整个 Java 实现跨平台的最核心部分，能够运行以 Java 语言写的软件程序。</p></blockquote><h3 id="重载-overload-与重写-override-的区别" tabindex="-1"><a class="header-anchor" href="#重载-overload-与重写-override-的区别" aria-hidden="true">#</a> 重载(overload)与重写(override)的区别</h3><blockquote><p><strong>重载</strong>：同一个类中，方法名相同，方法的参数的<u class="under-wave">类型、顺序、数量</u>不同的一组方法<br><strong>重写</strong>：子类对父类中的同名方法进行覆盖</p></blockquote><h3 id="java-中-与equals的区别-必会" tabindex="-1"><a class="header-anchor" href="#java-中-与equals的区别-必会" aria-hidden="true">#</a> Java 中<code>==</code>与<code>equals</code>的区别(必会)</h3><blockquote><p><code>==</code>：<br>   基本类型：比较的就是值是否相同<br>   引用类型：比较的就是地址是否相同</p><p><code>equals</code>：<br>   此方法是 Object 类中定义方法，只能实现两个引用类型的变量进行比较，默认比较的是两个对象是否相同(即地址值)，在 String 类，对此方法进行了重写，实现的是比较两个字符串的值是否相同；</p></blockquote><h3 id="string、stringbuffer-与-stringbuilder-的区别-必会" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer-与-stringbuilder-的区别-必会" aria-hidden="true">#</a> String、StringBuffer 与 StringBuilder 的区别(必会)</h3><blockquote><p><strong>String</strong>：字符串常量<br><strong>StringBuffer</strong>：字符串变量(线程安全)<br><strong>StringBuilder</strong>：字符串变量(非线程安全)</p></blockquote><p>  String 构建一个不可变的字符序列，StringBuffer 和 StringBuilder 都是构建一个可变的字符序列。在对字符串进行追加操作时 StringBuffer 比 String 效率高。</p><p>  此外 StringBuffer 是线程安全的，而 StringBuilder 是线程非安全的，在对字符串进行修改操作时，StringBuilder 效率优于 StringBuffer。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>  String 中的 String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，String 对象是不可变的，也就可以理解为常量，线程安全。</p><p>  AbstractStringBuilder 是 StringBuffer 与 StringBuilder 的公共父类，定义了一些字符串的基本操作，如：expandCapacity、append、insert、indexOf 等公共方法。</p><p>  StringBuffer 对方法 jailed 同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p><p>  StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></div><p><strong>小结</strong>：<br> ① 如果要操作少量的数据用 String；<br> ② 多线程操作字符串缓冲区下操作大量数据用 StringBuffer；<br> ③ 单线程操作字符串缓冲区孝操作大量数据用 StringBuilder。</p><h3 id="说一下字符串操作常见的-api-10-个左右即可" tabindex="-1"><a class="header-anchor" href="#说一下字符串操作常见的-api-10-个左右即可" aria-hidden="true">#</a> 说一下字符串操作常见的 API ？(10 个左右即可)</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code>、<code>concat(String str)</code></td><td>字符串连接</td></tr><tr><td><code>==</code>、<code>equals(Object anObject)</code>、<code>equalsIgnoreCase(String another String)</code></td><td>字符串比对</td></tr><tr><td><code>charAt(index)</code></td><td>获取指定位置字符值</td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取指定字符串第一次出现的下标值</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>字符串替换</td></tr><tr><td><code>startsWith(String prefix)</code>、<code>endsWith(String prefix)</code></td><td>判断是否以指定字符串开始|结束</td></tr><tr><td><code>toLowerCase()</code>、<code>toUpperCase()</code></td><td>所有字符转换为小写|大写</td></tr><tr><td><code>substring(index)</code></td><td>字符串截取</td></tr><tr><td><code>trim()</code></td><td>去除左右空格</td></tr><tr><td><code>String.valueOf(int i)</code></td><td>将整型转为字符串</td></tr><tr><td><code>contains(String str)</code></td><td>判断字符串是否包含某子字符串</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空</td></tr><tr><td><code>split(String regex)</code></td><td>指定分隔符返回分割后的字符数组</td></tr><tr><td><code>toCharArray()</code></td><td>将字符串转为字符数组</td></tr></tbody></table><h2 id="如下代码的运行结果" tabindex="-1"><a class="header-anchor" href="#如下代码的运行结果" aria-hidden="true">#</a> 如下代码的运行结果</h2>`,27),b=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{java:"",class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"class"),a(),n("span",{class:"token class-name"},"Test"),a(),n("span",{class:"token punctuation"},"{"),a(`
    `),n("span",{class:"token keyword"},"public"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),a(" args"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" i "),n("span",{class:"token operator"},"="),a(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),a(`
        i `),n("span",{class:"token operator"},"="),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" j "),n("span",{class:"token operator"},"="),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token keyword"},"int"),a(" k "),n("span",{class:"token operator"},"="),a(" i "),n("span",{class:"token operator"},"+"),a(),n("span",{class:"token operator"},"++"),a("i "),n("span",{class:"token operator"},"*"),a(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"i="'),a(),n("span",{class:"token operator"},"+"),a(" i"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"j="'),a(),n("span",{class:"token operator"},"+"),a(" j"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),a("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token string"},'"k="'),a(),n("span",{class:"token operator"},"+"),a(" k"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),a(`
    `),n("span",{class:"token punctuation"},"}"),a(`
`),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("div",{class:"highlight-lines"},[n("br"),n("br"),n("br"),n("div",{class:"highlight-line"}," "),n("br"),n("br"),n("br"),n("br"),n("br"),n("br"),n("br")]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),g=n("div",{class:"language-text line-numbers-mode","data-ext":"text"},[n("pre",{class:"language-text"},[n("code",null,`i=4
j=1
k=11
`)]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),m=o('<div class="hint-container tip"><p class="hint-container-title">解析</p><p><strong>行 4</strong>：先将 1 压入操作数栈，然后局部变量表中的 i 自增变为 2，最后操作树栈中的 1 赋值给 i，2 被覆盖；</p><figure><img src="'+k+`" alt="处理过程.png" tabindex="0" loading="lazy"><figcaption>处理过程.png</figcaption></figure><p><strong>总结</strong>：<br> ① 先赋值再自增、自减(i = i++ 、i = i--)，先自增、自减再赋值(i = ++i 、i = --i)<br> ② = 右边的从左到右加载值依次压入操作数栈<br> ③ 实际先算哪个，看运算符优先级<br> ④ 自增、自减操作都是<mark>直接修改变量的值，不经过操作数栈</mark><br> ⑤ 最后的赋值之前，临时结果也是存储在操作数栈中</p></div><h2 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h2><div class="hint-container tip"><p class="hint-container-title">什么是 Singleton ?</p><p><strong>Singleton</strong> : 在 Java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。单例设计模式，即某个类在整个系统中<mark>只能有一个实例对象</mark>可被获取和使用的代码模式。例如：代表 JVM 运行环境的 Runtime 类</p><p><strong>要点</strong>：</p><p>① 某个类只能有一个实例【构造器私有化】<br> ② 它必须自行创建这个实例【含有一个该类的静态变量来保存这个唯一的实例)】<br> ③ 它必须自行向整个系统提供这个实例【对外提供获取该实例对象的方式：(1)直接暴露 (2)用静态变量的 get 方法获取】</p></div><h3 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式" aria-hidden="true">#</a> 饿汉式</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 直接实例化(简洁直观)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 枚举式(最简洁)</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span>
<span class="token punctuation">}</span>

<span class="token comment">// 静态代码块(适合复杂实例化)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在类初始化时直接创建实例对象，不管是否需要这个对象，不存在线程安全问题</p></blockquote><h3 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式" aria-hidden="true">#</a> 懒汉式</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 静态内部类形式(适用于多线程)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Inner</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用</span>
<span class="token class-name">Singleton</span> s <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>延迟创建对象<br> 线程不安全(适用于单线程)、线程安全(适用于多线程)</p></blockquote><h2 id="集合-⭐️" tabindex="-1"><a class="header-anchor" href="#集合-⭐️" aria-hidden="true">#</a> 集合 ⭐️</h2><h2 id="多线程-⭐️" tabindex="-1"><a class="header-anchor" href="#多线程-⭐️" aria-hidden="true">#</a> 多线程 ⭐️</h2><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> JVM</h2>`,13);function f(S,y){const i=d("CodeTabs");return r(),p("div",null,[h,l(i,{id:"437",data:[{id:"代码"},{id:"输出结果"}]},{title0:s(({value:t,isActive:e})=>[a("代码")]),title1:s(({value:t,isActive:e})=>[a("输出结果")]),tab0:s(({value:t,isActive:e})=>[b]),tab1:s(({value:t,isActive:e})=>[g]),_:1}),m])}const w=c(v,[["render",f],["__file","java-foundation.html.vue"]]);export{w as default};
